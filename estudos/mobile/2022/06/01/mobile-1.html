<p><img src="/img/posts/android-logo.png" alt="Pentesting Android" title="Pentesting Android" /></p>

<ul>
  <li><a href="#introdução">INTRODUÇÃO</a></li>
  <li><a href="#o-princípio">O PRINCÍPIO</a></li>
  <li><a href="#criptografia">CRIPTOGRAFIA</a>
    <ul>
      <li><a href="#criptografia-simétrica">Criptografia Simétrica</a></li>
      <li><a href="#criptografia-assimétrica">Criptografia Assimétrica</a></li>
      <li><a href="#algorítmo-de-hash">Algorítmo de Hash</a></li>
      <li><a href="#assinatura-digital">Assinatura Digital</a></li>
      <li><a href="#certificado-digital">Certificado Digital</a></li>
    </ul>
  </li>
  <li><a href="#ssltls">SSL/TLS</a></li>
  <li><a href="#mtls">mTLS</a></li>
  <li><a href="#proxy">PROXY</a></li>
  <li><a href="#android-e-sua-arquitetura">ANDROID E SUA ARQUITETURA</a>
    <ul>
      <li><a href="#máquina-virtual-android-avm">Máquina Virtual Android (AVM)</a></li>
      <li><a href="#máquina-virtual-android-dalvik">Máquina Virtual Android (Dalvik)</a></li>
      <li><a href="#segurança-de-aplicativos-no-android">Segurança de Aplicativos no Android</a></li>
    </ul>
  </li>
  <li><a href="#conclusão">CONCLUSÃO</a></li>
</ul>

<h1 id="introdução">INTRODUÇÃO</h1>

<p>Recentemente surgiu o desafio profissional de me introduzir no universo dos testes em apk, o que logo no primeiro foi um tanto caótico, dada a necessidade do <code class="language-plaintext highlighter-rouge">fast learning</code> durante este período.</p>

<p>Bom, a falha grave, no <strong>meu ponto de vista</strong>, era simplesmente não estar preparado pelo menos com o mínimo esperado, ante um assunto aquecido no mercado.</p>

<p>Por conta disso, decidi separar uma parte deste ano, somente para me aprofundar nos estudos de pentesting mobile, e como meus estudos são bem melhores aproveitados quando eu expresso o aprendido de alguma forma, irei compartilhar em blog posts, toda a jornada de aprendizado.</p>

<h1 id="o-princípio">O PRINCÍPIO</h1>

<p>Aplicações mobile compreendem um universo de possibilidades que se convergem em vários pontos com outras áreas de segurança, portanto, antes de qualquer contato direto com técnicas específicas, é preciso pincelar sobre alguns temas básicos que fazem parte desta rotina, tais como:</p>

<ul>
  <li>Criptografia</li>
  <li>SSL/TLS</li>
  <li>mTLS</li>
  <li>Proxies</li>
  <li>Android e sua arquitetura</li>
</ul>

<h1 id="criptografia">CRIPTOGRAFIA</h1>

<p>A criptografia é um mecanismo aplicado a segurança e a privacidade utilizada para tornar a comunicação segura de diversas formas. A base principal da criptografia, desde sua origem a alguns séculos atrás, é tornar a comunicação initeligível para qualquer um que não tenha acesso aos mecanismos e códigos de tradução de uma mensagem.</p>

<p>Nas comunicações digitais, por exemplo, a criptografia tem grande papel na proteção de dados transmitidos entre dois ou mais nós, evitando que estes dados sejam lidos em texto claro, caso sejam interceptados, ou até mesmo evitando a interceptação em alguns casos.</p>

<p>Um mecanismo de criptografia tem como base, três principais elementos:</p>

<ul>
  <li><strong>Chave</strong>: Um código que utilizado para encriptar e/ou decriptar uma mensagem, funciona basicamente como a chave de uma porta, onde somente quem possui a mesma, consegue abrir ou fechar esta porta. No mundo digital, existem vários tipos de chave, sendo os mais convencionais simétrica e assimétrica. Sua existência é necessária, pois é inviável manter o algoritmo criptográfico em segredo, sendo assim, utiliza-se a chave criada a partir de um algoritmo de criptografia;</li>
  <li><strong>Encriptar</strong>: É o processo de codificar uma informação utilizando uma chave, de modo que seu resultado final seja algo incompreensível;</li>
  <li><strong>Decriptar</strong>: É o processo de decodificar uma mensagem encriptada utilizando uma chave, ou seja, uma informação encriptada com uma chave é initeligível até que seja decriptada utilizando uma chave.</li>
</ul>

<h2 id="criptografia-simétrica">Criptografia Simétrica</h2>

<p>Um sistema criptográfico é considerado simétrico quando é utilizada a mesma chave, uma chave privada, tanto para encriptar quanto para decriptar uma mensagem. A imagem abaixo mostra este fluxo.</p>

<p><img src="/img/posts/mobile-01.png" alt="Criptografia simétrica" title="Criptografia simétrica" /></p>

<h2 id="criptografia-assimétrica">Criptografia Assimétrica</h2>

<p>Um sistema criptográfico é considerado assimétrico quando são utilizadas duas chaves no processo de encriptação e decriptação, no caso uma chave <code class="language-plaintext highlighter-rouge">privada</code> e um chave <code class="language-plaintext highlighter-rouge">pública</code>. Neste cenário, a chave privada deve ser mantida em segredo e a chave pública pode ser compartilhada.</p>

<p>Neste fluxo de criptografia, a chave pública é utilizada para encriptar uma mensagem, enquanto que somente a chave privada consegue decriptá-la. A imagem abaixo exemplifica este fluxo.</p>

<p><img src="/img/posts/mobile-02.png" alt="Criptografia assimétrica" title="Criptografia assimétrica" /></p>

<h2 id="algorítmo-de-hash">Algorítmo de Hash</h2>

<p>A <code class="language-plaintext highlighter-rouge">hash</code> é um algorítmo que recebe qualquer comprimento de entrada, sejam eles qualquer tipo de dados, e mescla esta entrada para produzir uma saída <strong>pseudoaleatória</strong> de largura fixa, ou seja, independente da largura dos dados encriptados, seu resultado terá sempre uma largura fixa.</p>

<p>Uma hash é identificada pelas seguintes características:</p>

<ol>
  <li>Um algorítmo de hash sempre redumirá os dados de entrada em uma saída de tamanho fixo, independente do conteúdo de entrada;</li>
  <li>A saída de um algorítmo de hash é pseudoaleatória por princípios matemáticos;</li>
  <li>Se um único bit for alterado nos dados de entrada, a saída de uma hash será completamente diferente;</li>
  <li>Não pode ser reversível, ou seja, a partir de uma hash, é impossível reconstruir os dados de entrada, princípio conhecido como “função de via única”;</li>
  <li>Um algorítmo de hash não pode encontrar duas mensagens que produzam a mesma saída.</li>
</ol>

<p>Alguns algoritmos de hash conhecidos:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Algorítmo</th>
      <th style="text-align: center">Tamanho de saída</th>
      <th style="text-align: center">Hashes possíveis</th>
      <th>Exemplo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">MD5</td>
      <td style="text-align: center">16 Bytes / 128 bits</td>
      <td style="text-align: center">2<sup>128</sup></td>
      <td>196024cd532a9b08c8096eb3632a97b7</td>
    </tr>
    <tr>
      <td style="text-align: center">SHA-1</td>
      <td style="text-align: center">20 Bytes / 160 bits</td>
      <td style="text-align: center">2<sup>160</sup></td>
      <td>54aa06f5a16d8eb7d1141cf49ce3da68c81e90a4</td>
    </tr>
    <tr>
      <td style="text-align: center">SHA-256</td>
      <td style="text-align: center">32 Bytes / 256 bits</td>
      <td style="text-align: center">2<sup>256</sup></td>
      <td>ca08547be53fa295c6d3f127fc7692096150cd3a2f3a618991991eb0f9983ad6</td>
    </tr>
    <tr>
      <td style="text-align: center">SHA-512</td>
      <td style="text-align: center">64 Bytes / 512 bits</td>
      <td style="text-align: center">2<sup>512</sup></td>
      <td>abb5d711e31907f0021e346ce34ae7df7e5e866a5369811a4354b533fc451544<br />0ac9f9d5fa08e7ebf42787e4ca569c3a71378a6a4d112ce461628c5214c9632a</td>
    </tr>
  </tbody>
</table>

<h2 id="assinatura-digital">Assinatura Digital</h2>

<p>A assinatura digital, nada mais é que uma chave privada virtual, vinculada a um certificado digital, assim como uma assinatura em um papel, a assinatura digital assume a legalidade de uma assinatura comum.</p>

<p>Uma assinatura digital é composta de dois principais fundamentos:</p>

<ol>
  <li>A chave primária precisa ser segura e somente o proprietário desta chave possa utilizá-la;</li>
  <li>A única maneira de produzir uma assinatura digital seja utilizando uma chave pública.</li>
</ol>

<p>Portanto, para ter uma criptografia segura, os dados devem ser criptografados com a <code class="language-plaintext highlighter-rouge">chave pública</code> para que somente a <code class="language-plaintext highlighter-rouge">chave privada</code> possa decriptar.</p>

<h2 id="certificado-digital">Certificado Digital</h2>

<p>O certificado digital, nada mais é do que uma forma de associar uma chave pública a uma entidade de destino, pois ele associa esta chave a um nome. Ele é composto basicamente do nome, da chave pública e da assinatura digital.</p>

<p>A construção de um certificado digital, é feita de uma maneira que torna perceptível caso alguém ou algo com comportamento malicioso altere qualquer informação que o compõe.</p>

<p>A assinatura de um certificado digital, é normalmente (mas não sempre) feita pr meio de uma autoridade certificadora, ou “CA” (<em>Certification Authority</em>). Atualmente, o certificado digital mais utilizado segue o padrão <a href="https://datatracker.ietf.org/doc/html/rfc5280" title="RFC 5280">X.509</a>.</p>

<p>A estrutura de um certificado digital no padrão <code class="language-plaintext highlighter-rouge">X.509</code> segue exemplificado na imagem abaixo e também pode ser lida com detalhes na <a href="https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.1">RFC 5280 na sessão 4.1.1</a>.</p>

<p><img src="/img/posts/mobile-03.png" alt="Estrutura do certificado no padão X.509" title="Estrutura do certificado no padão X.509" /></p>

<h1 id="ssltls">SSL/TLS</h1>

<p>O SSL/TLS (<em>Secure Sockets Layer</em> e <em>Transport Layer Security</em>) é utilizado para garantir a autenticidade e o sigilo na comunicação entre servidores e clientes, geralmente utilizado nos protocolos HTTP e SMTP.</p>

<p>O SSL/TLS adiciona uma nova camanda, ou <em>layer</em> na comunicação HTTP conforme ilustrado abaixo.</p>

<p><img src="/img/posts/mobile-04.png" alt="Requisição sem e com SSL/TLS" title="Requisição sem e com SSL/TLS" /></p>

<p>Durante o processo de comunicação entre um cliente e um servidor utilizando SSL, fluxo segue da seguinte maneira:</p>

<p><img src="/img/posts/mobile-05.png" alt="Comunicação via SSL" title="Comunicação via SSL" /></p>

<h1 id="mtls">mTLS</h1>

<p>O <code class="language-plaintext highlighter-rouge">mTLS</code> ou Mutual TLS é o proceso pelo qual o servidor solicita ao cliente um certificado TLS durante o estabelecimento do TLS, quendo este certificado é recebido, o servidor possui condições de avaliá-lo.</p>

<p>Este processo chamado de <em>TLS Handshake Certificate Request</em> é uma troca de mensagem opcional enviada do servidor para o cliente. Esta requisição é composta de uma lista de certificados digitais raiz aceitos pelo servidor.</p>

<p>Portanto, quando um cliente recebe esta requisição de um servidor, deve enviar uma resposta com ceu próprio certificado de um dos certificados raiz.</p>

<p>A imagem abaixo, ilustra este fluxo de comunicação.</p>

<p><img src="/img/posts/mobile-06.png" alt="Comunicação via mTLS" title="Comunicação via mTLS" /></p>

<h1 id="proxy">PROXY</h1>

<p>O <code class="language-plaintext highlighter-rouge">proxy</code>, de forma bem simplificada ,é um servidor que age como um intermediário entre requisições de clientes para outros servidores. Esta funçã de intermediação não só monitora, como pode filtrar e/ou armazenar dados transitados.</p>

<p>Desta forma, por mais que um proxy seja diferente de um <code class="language-plaintext highlighter-rouge">firewall</code>, ainda assim pode realizar filtros, e por mais que não seja um <code class="language-plaintext highlighter-rouge">cache</code> também pode implementar esta funcionalidade.</p>

<p>As proxies geralmente são divididas em duas categorias:</p>

<ol>
  <li><strong>Proxy ativo</strong>: O tipo de proxy que precisa ser configurado do lado do cliente, definindo o socket do proxy, o BurpSuite é um exemplo de proxy ativo;</li>
  <li><strong>Proxy transparente</strong>: Este proxy direciona conexões que passam por ele para um servidor ou aplicação específico local. Este tipo de proxy não exige configuração do lado do cliente que geralmente não sabe de sua existência. O webserber <code class="language-plaintext highlighter-rouge">NGINX</code> implementa este tipo de proxy.</li>
</ol>

<h2 id="web-application-proxy">Web Application Proxy</h2>

<p>O <code class="language-plaintext highlighter-rouge">web application proxy</code> atua diretamente na camada de aplicação, ou seja, na camada 7 do modelo <a href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/" title="OSI model">OSI</a> e permitem que os payloads dasrequisições e respostas do protocolo HTTP sejam filtradas, analisadas e armazenadas.</p>

<h1 id="android-e-sua-arquitetura">ANDROID E SUA ARQUITETURA</h1>

<p>O <code class="language-plaintext highlighter-rouge">Android</code> é um sistema operacional de código aberto baseado em Linux, inicialmente para dispositivos móveis, porém largamente utilizado em diversos outros dispositivos.</p>

<p>A arquitetura do sistema Androide consiste em uma série de componentes que podem ser separados em ses camadas, a imagem abaixo foi retirada da própria <a href="https://developer.android.com/guide/platform">Android Developers</a> e listra estas camadas.</p>

<p><img src="/img/posts/mobile-07.png" alt="Arquitetura Android" title="Arquitetura Android" /></p>

<p>Onde:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada System Apps</code></strong>: É a camada onde as aplicações são instaladas, armazenadas e executadas. Nesta camada, estão os instalados os aplicativos nativos e os aplicativos do usuário;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Java API Framework</code></strong>: Esta camada fornece as APIs do sistema para serem utilizadas pelas funcionalidades comuns das aplicações, tais como funcionalidades de compartilhamento de dados, acesso ao telefone, GPS e elementos visuais;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Native C/C++ Libraries</code></strong>: Esta camada fornece as bibliotecas C e C++ que são utilizadas para gerenciar processos em baixo nível, processos como encriptação, renderização de imagens e multimídia, entre outros;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Android Runtime</code></strong>: Cada aplicação dentro do Android executa em uma própria máquina virtual, por fins de segurança e integridade. E é nesta camada que reside a máquina virtual responsável pelas aplicações em execução;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Hardware Abstraction Layer (HAL)</code></strong>: Esta camada define os padrões para os fabricantes de hardware implementarem suas funcionalidades. Utilizando a HAL, os fabricantes podem implementar suas funcionalidades sem afetar o sistema em alto nível;</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Camada Linux Kernel</code></strong>: Esta camada contém o kernel Android que é baseado no kernel Linux 2.6. O kernel é responsável pelo gerenciamento de memória, processos e energia. Esta camada é responsável por controlar o acesso ao hardware do dispositivo por meio de drivers. Como sendo a camada base, ela é quem une todas as camadas superiores.</li>
</ul>

<h2 id="máquina-virtual-android-avm">Máquina Virtual Android (AVM)</h2>

<p>As máquinas virtuais são basicamente camadas abstração entre uma aplicação e as camadas subjacentes do dispositivo. Os aplicativos Android e o Java API Framework são desenvolvidos na linguagem de programação Java ou Kotlin e são executados dentro de uma máquina virtual Dalvik.</p>

<h2 id="máquina-virtual-android-dalvik">Máquina Virtual Android (Dalvik)</h2>

<p>O Dalvik é uma máquina virtual baseada em registro que interpreta códigos em baixo nível em bytes do <code class="language-plaintext highlighter-rouge">Executável Dalvik (DEX)</code>. Para seu funcionamento, o Dalvik depende de funcionalidades fornecidas por várias bibliotecas de código nativo de suporte.</p>

<p>Isso se torna necessário, para que o sistema consiga suportar todas as diferenças entre sistemas operacionais sem que o desenvolvedor precise desenvolver aplicativos diferentes para dispositivos específicos.</p>

<h2 id="segurança-de-aplicativos-no-android">Segurança de Aplicativos no Android</h2>

<p>Por padrão, os aplicativos Android não tem acesso direto a recursos de hardware e cada aplicativo é executado em sua própria <code class="language-plaintext highlighter-rouge">sandbox</code>, ou seja, cada aplicativo é executado “enjaulado” em um ambiente. Como o Android é baseado em Linux, o sistema de permissionamento é similar ao permissionamento entre usuários, onde cada usuário compartilha recursos do sistema, mas não tem acesso a ambientes e recursos específicos de outros usuários.</p>

<p>Isto ocorre, para permitir o controle preciso sobre recursos, pois não permite que um aplicativo com falha ou malicioso efete outros aplicativos em execução no dispositivo.</p>

<h1 id="conclusão">CONCLUSÃO</h1>

<p>Acredito que isto é o básico para iniciar o entendimento sobre Android e seu funcionamento, antes de iniciar os testes em aplicativos.<br />
Com estas informações em mente, avancaremos nos próximos artigos.</p>
