<p>Neste artigo, vamos entender o processo que permite que executemos aplicações que utilizam GUI de dentro de um container.</p>

<p>Este tipo de ação se torna útil no dia-a-dia, ainda falando em sec, pois permite que tenhamos todas as ferramentas necessárias para um teste ou análise de vulnerabilidade, sem que haja a necessidade de instalar ferramentas diretamente no SO ou o uso de virtualização.</p>

<p>O sistema final fica muito leve em comparação a um SO sendo executado em sua totalidade, seja como host ou virtualizado, além de ser extremamente minimalista, instalando somente as ferramentas necessárias. O que o torna performático e isolado do SO host (nem tanto).</p>

<p>Isso nos permite invocar aplicações tanto de terminal quanto GUI integradas ao host. Imagine chamar um <code class="language-plaintext highlighter-rouge">Burpsuite</code> de um container, e interceptar requisições do navegador do host, assim como invocar o <code class="language-plaintext highlighter-rouge">Wireshark</code> do container, para monitorar a rede do host.</p>

<p>O intuito deste artigo, não é demonstrar como funciona o <code class="language-plaintext highlighter-rouge">Docker</code>, ainda mais porque seus recursos são extensos, mas sim demonstrar como podemos utilizá-lo para fins de otimização de testes.</p>

<p>Porém, o que pra muitos pode ser banal, é de extrema importância que abordemos os conceitos básicos envolvidos em todo este processo.</p>

<h1 id="containers">Containers</h1>

<p>Dentro do unverso Linux, um container é uma tecnologia que permite isolar e empacotar uma aplicação e todo o seu ambiente em tempo de execução, ou seja todo o sistema de base e os arquivos necessários para execução de uma aplicação, são executados de forma isolada do sistema operacional.</p>

<p>Isto facilita a movimentação da aplicação em questão, entre diferentes ambientes, pois passa a não depender de bibliotecas e versões de sistemas operacionais específicos. No cenário de desenvolvimento, um container pode transitar entre ambientes de dev, QA e prod mantendo sua integridade completa, independente da infraestrutura de cada ambiente.</p>

<p>Esta independência torna possível a execução de vários processos separadamente uns dos outros tendo melhor aproveitamento dos recursos de hardware e “melhorando” a segurança, ao mentê-los digitalmente em ambientes diferentes.</p>

<h1 id="docker">Docker</h1>

<p><code class="language-plaintext highlighter-rouge">Docker</code> é uma tecnologia que utiliza o <a href="https://www.educative.io/edpresso/what-is-linux-kernel">kernel Linux</a> e seus recursos, para segregar processos de forma que sejam executados de forma isolada e independente. O modelo de implantação do Docker se baseia em imagens, ou seja, para cada sistema e/ou aplicação, existe uma imagem que contém todo o ambiente para seu funcionamento.</p>

<p><img src="/img/posts/gui_docker_01.png" alt="docker" /></p>

<p>Além desta função primordial, o Docker traz uma série de funcionalidades que permitem o fácil gerenciamento dos containers, automatizando implantações, compartilhamento de recursos, arquivos e diretórios entre o container e o host, compartilhamento ou isolamento de redes entre diversos outros.</p>

<p>Entre os benefícios de utilizarmos um gerenciador de containers, podemos citar:</p>

<ul>
  <li>Controle de versões de imagens</li>
  <li>Modularidade</li>
  <li>Escalabilidade</li>
</ul>

<p>Existem outras ferramentas que oferecem as mesmas funcionalidades como <code class="language-plaintext highlighter-rouge">Kubernetes</code> e o <code class="language-plaintext highlighter-rouge">CRI-O</code>. Porém, devido ao seu ambiente “amigável”, vamos focar este artigo em <code class="language-plaintext highlighter-rouge">Docker</code>. Podendo afirmar que a tecnologia Docker tem uma abordagem controlável, baseada em microserviços e eficiente.</p>

<h1 id="x11">X11</h1>

<p><code class="language-plaintext highlighter-rouge">X Window System</code>, também chamado de <code class="language-plaintext highlighter-rouge">X11</code>, é um sistema de janelas <em>client/server</em> para exibição de bitmaps. O X11 é comumente implantado na maioria dos sistemas operacionas baseados em <code class="language-plaintext highlighter-rouge">UNIX</code> e já foi portado até mesmo para outros sistemas.</p>

<p>O <em>server</em> X11, de forma bem resumida, pode ser considerado como o sistema que exibe as janelas e manipula os dispositivos de entrada, como mouses, teclados e telas <em>touch screen</em>. Já os <em>clients</em> são os aplicativos em execução.</p>

<p>O X11 utiliza arquivos <code class="language-plaintext highlighter-rouge">UNIX Socket</code> que agem na comunicação entre processos dentro de uma mesma máquina de forma eficiente. O próprio <a href="https://man7.org/linux/man-pages/man7/unix.7.html">manual do unix socket</a> o descreve como:</p>

<blockquote>
  <p><em>The AF_UNIX (also known as AF_LOCAL) socket family is used to communicate between processes on the same machine efficiently. Traditionally, UNIX domain sockets can be either unnamed, or bound to a filesystem pathname (marked as being of type socket). Linux also supports an abstract namespace which is ndependent of the filesystem.</em></p>
</blockquote>

<p>Assim como vários tipos de servidores, o X11 também trabalha com sistema de permissionamento, do qual pode ser gerenciado pelo comando <code class="language-plaintext highlighter-rouge">xhost</code>.</p>

<p>O <code class="language-plaintext highlighter-rouge">xhost</code> de acordo com seu <a href="https://linux.die.net/man/1/xhost">manual</a> é o programa utilizado para adicionar e deletar <em>host names</em> ou <em>user names</em> da lista de permissões do X <em>server</em>.</p>

<p>Por padrão, o X <em>server</em> permite que somente o usuário local utilize seus recursos, é possível confirmar isso ao executar o comando <code class="language-plaintext highlighter-rouge">sudo xhost</code>.</p>

<p><img src="/img/posts/gui_docker_02.png" alt="docker" /></p>

<p>Conforme podemos ver, somente o usuário logado e seus processos tem permissão de utilizar o X11. Porém, é preciso permitir que toda a família de usuários locais, possam utilizar o X <em>server</em>. Para isso, pode-se utiliar o comando <code class="language-plaintext highlighter-rouge">xhost +local:*</code>.</p>

<p><img src="/img/posts/gui_docker_03.png" alt="docker" /></p>

<p>Como podemos ver, agora temos o <code class="language-plaintext highlighter-rouge">LOCAL</code> entre os usuários permitidos. Esta configuração é resetada toda vez que o sistema operacional é reinicializado.</p>

<p>Além destas configurações, existe uma variável de ambiente extremamente importante neste processo, a <code class="language-plaintext highlighter-rouge">$DISPLAY</code>. Esta variável de ambiente é utilizada pelo X11 para identificar nossos dispositivos de IO e sua interação com a tela. Normalmente esta variável de ambiente contém o valor <code class="language-plaintext highlighter-rouge">:0</code> em dispositivos Desktop, referenciando o monitor primário. Quando se utiliza uma sessão SSH com conexão X, o valor desta variável pode ser um número alto, pois ela indica para o X <em>server</em> que as aplicações devem receber seu <em>input</em> e <em>output</em> de conexões externas. Conforme observado abaixo.</p>

<p><img src="/img/posts/gui_docker_04.png" alt="docker" /></p>

<p>Por ultimo, é preciso encontrar o próprio <code class="language-plaintext highlighter-rouge">UNIX Socket</code> do X <em>server</em>. Este arquivo de socket pode ser encontrado no diretório <code class="language-plaintext highlighter-rouge">/tmp</code> conforme mostrado abaixo.</p>

<p><img src="/img/posts/gui_docker_05.png" alt="docker" /></p>

<p>Normalmente em sistemas baseados em UNIX, toda vez que o X <em>server</em> se inicia junto com o sistema operacional, este diretório é criado.</p>

<h1 id="criando-uma-imagem-personalizada">Criando uma imagem personalizada</h1>

<p>Quando fazemos o <code class="language-plaintext highlighter-rouge">pull</code> de uma imagem Docker, estamos basicamente capturando a imagem que contém somente os arquivos necessários para o funcionamento daquela aplicação. Por exemplo, uma imagem do servidor web <code class="language-plaintext highlighter-rouge">Apache</code>, virá somente com o kernell de uma distribuição Linux e os arquivos necessários para o funcionamento do próprio Apache, tornando a imagem leve o suficiente para ter somente alguns mega bytes.</p>

<p>Já quando fazemos o pull de uma imagem de uma distribuição Linux pura, por exemplo, estamos baixando somente o kernel compilado e um emulador de terminal, tornando a imagem extremamente leve.</p>

<p>Uma imagem de container pode ser usada para criar novas imagens personalizadas que contenha as instalações que precisamos, e cada imagem pode ser usada para o <em>deploy</em> de quantos containers forem necessários. E esta é a grande vantagem em relação ao minimalismo. Uma distribuição que contém somente o necessário e mais nada.</p>

<p>Para a prova de conceito deste artigo, vamos utilizar a imagem da distribuição Kali Linux que pode ser encontrada no <a href="https://hub.docker.com/r/kasmweb/core-kali-rolling">Docker Hub</a>. Esta imagem é atualizada constantemente e contém somente o <em>core</em> do Kali, sem absolutamente nenhuma ferramenta.</p>

<p>Para melhor gerenciamento e controle ao criar uma imagem, um dos recursos do Docker é o <code class="language-plaintext highlighter-rouge">Dockerfile</code>. Basicamente é um arquivo onde configuramos como queremos montar uma imagem, sua referência oficial pode ser encontrada <a href="https://docs.docker.com/engine/reference/builder/">aqui</a>. O script abaixo mostra o conteúdo do exemplo que iremos utilizar.</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># informando qual a imagem base a ser utilizada</span>
<span class="k">FROM</span><span class="s"> kalilinux/kali-rolling</span>

<span class="c"># criando um diretório de trabalho</span>
<span class="k">WORKDIR</span><span class="s"> /resources</span>

<span class="c"># update da imagem</span>
<span class="k">RUN </span>apt update

<span class="c"># instalação de aplicações importantes para o X11</span>
<span class="k">RUN </span>apt <span class="nb">install </span>dbus-x11 packagekit-gtk3-module libcanberra-gtk3-0 <span class="nt">-y</span>

<span class="c"># instalando programas de teste</span>
<span class="k">RUN </span>apt <span class="nb">install </span>firefox-esr burpsuite <span class="nt">-y</span>
</code></pre></div></div>

<p>Onde neste arquivo:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">kalilinux/kali-rolling</code>: indica qual a imagem será utilizada como base para uma imagem personalizada</li>
  <li><code class="language-plaintext highlighter-rouge">/resources</code>: será o diretório de trabalho desta imagem, isso significa que toda vez que um container for invocado a partir desta imagem, o diretório principal de trabalho será esse. (podemos montar um volume do host neste diretório para compartilharmos recursos)</li>
  <li><code class="language-plaintext highlighter-rouge">dbus-x11</code>: é o <em>add-on</em> necessário para o D-Bus no X11. O D-Bus é um mecanismo de <em>middleware</em> que permite a comunicação entre multiplos processos executando simultaneamente na mesma máquina. Neste caso, ele fará este papel no X11, entre o host e o container.</li>
  <li><code class="language-plaintext highlighter-rouge">packagekit-gtk3-module</code>: é um pacote de fontes para melhorar a experiência.</li>
  <li><code class="language-plaintext highlighter-rouge">libcanberra-gtk3-0</code>: é a implementação que vai gerar sons de eventos em aplicações GUI, mais um pacote para melhorar a experiência.</li>
</ol>

<p>Como não é possível a interação com o usuário durante a construção de uma imagem, é preciso que todas as instalações possuam a flag <code class="language-plaintext highlighter-rouge">-y</code> para que o não seja solicitada a confirmação. Também é importante que o primeiro comando a ser executado seja o <code class="language-plaintext highlighter-rouge">update</code> da distribuição, para garantir que os pacotes sejam carreegados do repositório.</p>

<p>Para fins de teste, vamos instalar somente o <code class="language-plaintext highlighter-rouge">Firefox</code> e o <code class="language-plaintext highlighter-rouge">Burpsuite</code>, após a comprovação da prova de conceito, podemos montar uma imagem com ferramentas do dia-a-dia.</p>

<p>Com o arquivo configurado, podemos executar o comando <code class="language-plaintext highlighter-rouge">sudo docker build -t kali .</code> de dentro do diretório onde o Dockerfile está.<br />
Neste caso, o <code class="language-plaintext highlighter-rouge">build</code> informa ao Docker para construir uma imagem, a flag <code class="language-plaintext highlighter-rouge">-t</code> diz para o Docker que vamos dar um nome para a imagem, neste caso <code class="language-plaintext highlighter-rouge">kali</code> e o <code class="language-plaintext highlighter-rouge">.</code> indica que é para buscar o Dockerfile no diretório atual.</p>

<p><img src="/img/posts/gui_docker_06.png" alt="docker" /></p>

<p>Como podemos ver, a primeira coisa que o Docker faz, é o <code class="language-plaintext highlighter-rouge">pull</code> da imagem do Kali Linux</p>

<p><img src="/img/posts/gui_docker_07.png" alt="docker" /></p>

<p>Logo após, ele inicia os comandos para <em>update</em> e instalação dos programas, este passo pode demorar um pouco.</p>

<p>Após a execução de todos os processos, podemos consultar as imagens existentes e verificar que a imagem <code class="language-plaintext highlighter-rouge">kali</code> foi criada, conforme mostrado abaixo.</p>

<p><img src="/img/posts/gui_docker_08.png" alt="docker" /></p>

<p>Neste ponto, temos uma imagem de Kali Linux extremamente minimalista para testes que contém somente os programas Firefox e Burpsuite.</p>

<h1 id="invocando-o-bash-de-um-container">Invocando o bash de um container</h1>

<p>Containers são dinâmicos, podem ser criados, destruídos, inicializados, parados, movidos e alterados.<br />
Podemos compartilhar recursos entre o host e um container, assim como podemos isolá-lo totalmente.</p>

<p>Quando inciamos um container, ele vai ler a imagem base e iniciar a aplicação invocada permanecendo em operação até que seja parado de alguma forma. Aí entra uma granda cautela necessária, se invocarmos várias aplicações de uma imagem, vários contaners serão criados e permanecerão em execução consumindo recursos, a menos que sejam parados ou destruídos.</p>

<p>Para lidar com este tipo de situação, podemos utilizar uma série de flags ao invocar um container. Abaixo, exemplifico a forma que <code class="language-plaintext highlighter-rouge">EU</code> utilizo na istuação específica abordada neste artigo.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> kali bash
</code></pre></div></div>

<p>Onde:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">run</code>: é o comando para o deploy de um container a partir de uma imagem.</li>
  <li><code class="language-plaintext highlighter-rouge">--rm</code>: esta é a flag importante, ela indica para o Docker, que após o encerramento do programa ou aplicação invocada, este container deve se auto destruir, desocupando a memória e o espaço em disco. Isso faz com que não seja necessária a preocupação com vários containers reduntantes executando em paralelo sem uso e torna as alterações não permanentes, ou seja, o container sempre será executado no estado inicial do Kali.</li>
  <li><code class="language-plaintext highlighter-rouge">-it</code>: a flag que faz o container ficar “interativo” (<code class="language-plaintext highlighter-rouge">-i</code> mantém o STDIN ativo e <code class="language-plaintext highlighter-rouge">-t</code> aloca um pseuto TTY).</li>
  <li><code class="language-plaintext highlighter-rouge">kali</code>: o nome da imagem que utilizaremos para invocar o container.</li>
  <li><code class="language-plaintext highlighter-rouge">bash</code>: o programa que queremos invocar, neste caso um simples terminal bash.</li>
</ol>

<p><img src="/img/posts/gui_docker_09.png" alt="docker" /></p>

<p>Até então, tudo funcionando normalmente como qualquer container, porém, como utilizamos a flag <code class="language-plaintext highlighter-rouge">--rm</code> ao executar o comando <code class="language-plaintext highlighter-rouge">exit</code>, o container se auto destrói e nenhuma alteração é persistente.</p>

<p>Neste primeiro comando, utilizamos o comando <code class="language-plaintext highlighter-rouge">bash</code> para invocar o terminal, mas com todas as configurações que fizemos, podemos agora invocar um programa que utiliza GUI</p>

<h1 id="invocando-um-programa-gui-de-um-container">Invocando um programa GUI de um container</h1>

<p>Conforme entendemos sobre o X11, precisamos compartilhar o recurso de <code class="language-plaintext highlighter-rouge">UNIX Socket</code> que se encontra em <code class="language-plaintext highlighter-rouge">/tmp/</code> entre o container e o host. O Docker, permite que compartilhemos diretórios e arquivos através de volumes, com este recurso, podemos “montar” um diretório do host em qualquer lugar do container.<br />
Também precisamos compartilhar a variável de ambiente <code class="language-plaintext highlighter-rouge">$DISPLAY</code> que o X11 irá utilizar para saber onde mandar a aplicação GUI. O comando fica desta forma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> /tmp/.X11-unix:/tmp/.X11-unix <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">-d</span> kali firefox
</code></pre></div></div>

<p>Onde:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">-v /tmp/.X11-unix:/tmp/.X11-unix</code>: a flag <code class="language-plaintext highlighter-rouge">-v</code> monta um volume da máquina host para um diretório do container, no caso estamos montando o diretório <code class="language-plaintext highlighter-rouge">/tmp/.X11-unix</code> do host para o mesmo caminho dentro do container.</li>
  <li><code class="language-plaintext highlighter-rouge">-e DISPLAY=$DISPLAY</code>:  a flag <code class="language-plaintext highlighter-rouge">-e</code> cria uma variável de ambiente no container com o valor que passarmos, no caso estamos criando a <code class="language-plaintext highlighter-rouge">DISPLAY</code> dentro do container com o mesmo valor da <code class="language-plaintext highlighter-rouge">DISPLAY</code> do host.</li>
  <li><code class="language-plaintext highlighter-rouge">-d</code>: esta flag faz com que a execução ocorra em background sem comprometer o terminal.</li>
</ol>

<p>Ao executar o comando, temos o Firefox invocado diretamente do container.</p>

<p><img src="/img/posts/gui_docker_10.png" alt="docker" /></p>

<p>Todo este processo, torna o container menos isolado do host, porém o objetivo desta prova de conceito não é subir uma aplicação, mas sim chamar aplicações GUI que possam ajudar no dia-a-dia sem que haja a necessidade da instalação na máquina host.</p>

<p>Ainda é possível compartilhar mais recursos com o container, para interagir com o host, por exemplo, podemos compartilhar as mesmas interfaces de rede do host com o container, e utilizar o Burpsuite do container para interceptar requisições do browser do host, podemos fazer isto com a flag <code class="language-plaintext highlighter-rouge">--net=host</code>. O comando fica desta forma:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> /tmp/.X11-unix:/tmp/.X11-unix <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">--net</span><span class="o">=</span>host <span class="nt">--privileged</span> <span class="nt">-d</span> kali burpsuite
</code></pre></div></div>

<p>Ao executar o comando e chamar o Firefox do host, podemos interagir entre as aplicações.</p>

<p><img src="/img/posts/gui_docker_11.png" alt="docker" /></p>

<p>Caso seja necessário persistir algum dado, ou compartilhar algum arquivo ou diretório entre o container e o host, podemos utilizar a flag <code class="language-plaintext highlighter-rouge">-v</code> novamente e montar um novo compartilhamento. Na verdade, esta foi a real razão da qual o comando <code class="language-plaintext highlighter-rouge">WORKDIR /resource</code> foi inserida no <code class="language-plaintext highlighter-rouge">Dockerfile</code>, pois podemos montar um diretório compartilhado lá de forma mais organizada.</p>

<h1 id="automatizando-a-chamada">Automatizando a chamada</h1>

<p>Como o comando fica relativamente grande, fiz um script para automatizar esta chamada onde, a depender do argumento, ele toma uma ação diferente, como chamar um terminal ou abrir uma aplicação GUI.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="nb">dir</span><span class="o">=</span><span class="nv">$HOME</span>/pentest/
<span class="nv">xh</span><span class="o">=</span><span class="si">$(</span><span class="nb">sudo </span>xhost | <span class="nb">grep </span>LOCAL | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$xh</span> <span class="nt">-eq</span> 0 <span class="o">]</span>
<span class="k">then
		</span><span class="nb">sudo </span>xhost +Local:<span class="k">*</span> <span class="o">&gt;</span>/dev/null
<span class="k">fi

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">""</span> <span class="o">]</span>
<span class="k">then
		</span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Use:</span><span class="se">\n\t</span><span class="nv">$0</span><span class="s2"> &lt;command&gt;"</span>
		<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"Ex:</span><span class="se">\n\t</span><span class="nv">$0</span><span class="s2"> bash"</span>
		<span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="se">\t</span><span class="nv">$0</span><span class="s2"> burpsuite"</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"bash"</span> <span class="o">]</span>
<span class="k">then
		</span><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span> <span class="nv">$dir</span>:/resources <span class="nt">-v</span> /tmp/.X11-unix/:/tmp/.X11-unix/ <span class="nt">--net</span><span class="o">=</span>host <span class="nt">--privileged</span> <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> kali <span class="nv">$1</span>
<span class="k">else
		</span><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-v</span> <span class="nv">$dir</span>:/resources <span class="nt">-v</span> /tmp/.X11-unix/:/tmp/.X11-unix/ <span class="nt">--net</span><span class="o">=</span>host <span class="nt">-e</span> <span class="nv">DISPLAY</span><span class="o">=</span><span class="nv">$DISPLAY</span> <span class="nt">--privileged</span> <span class="nt">-d</span> kali <span class="nv">$1</span> <span class="o">&gt;</span>/dev/null
<span class="k">fi</span>
</code></pre></div></div>
<p>Este script nos permite chamar tanto o bash:</p>

<p><img src="/img/posts/gui_docker_12.png" alt="docker" /></p>

<p>Como chamar uma aplicação GUI:</p>

<p><img src="/img/posts/gui_docker_13.png" alt="docker" /></p>

<h1 id="melhorando-a-utilidade">Melhorando a utilidade</h1>

<p>Neste artigo, fizemos um treste simples ao criar uma imagem que contém somente o Firefox e o Burpsuite, porém, esta imagem pode ser construida com toda e qualquer <em>tool</em>  necessária para o dia-a-dia, tanto com aplicações GUI quanto programas de terminal tornando versátil o uso do Kali Linux em ambientes distintos. Tudo a depender de como o Dockerfile é configurado.</p>

<p>Eu fiz um repositório no GitHub com a construção e automação deste recurso com algumas ferramentas mais habituais, o recurso pode ser encontrado no link abaixo:</p>

<ul>
  <li><a href="https://github.com/h41stur/kali_container">KALI CONTAINER</a></li>
</ul>

<p>Espero que tenha ajudado de alguma forma!</p>

<p>HACK THE PLANET!!</p>
